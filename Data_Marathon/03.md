# 3. Запросы с условиями

## Содержание

+ [3.1 Выбираем данные из таблицы](#31-выбираем-данные-из-таблицы)
+ [3.2 WHERE: задаем условия запроса](#32-where-задаем-условия-запроса)

[Оглавление](/Data_Marathon/README.md)

# 3.1 Выбираем данные из таблицы

В рамках прошлого урока мы с вами познакомились с тем, как с помощью языка запросов получить все данные из таблицы, то есть все столбцы и строки. Давайте научимся решать новый тип задач на SQL.

Итак, представьте, что у нас есть следующая задача: нужно узнать какие категории игровых действий существуют в таблице. Чтобы решить это, мы можем запустить уже знакомый нам запрос:

```sql
SELECT *
FROM game_events
```

В ответе получим все столбцы и строки из исходной таблицы. Можем пробежаться глазами по строкам, чтобы понять какие есть категории, но строк может быть достаточно много, и быстро решить задачу не получится.

SQL позволяет сделать это удобнее. Для начала давайте попробуем выбрать только колонку с категориями, потому что для решения этой задачи остальные не понадобятся. Это можно сделать следующим образом:

```sql
SELECT event_name
FROM game_events
```

Таким образом, у нас получится вывести на экран только одну колонку, без всех остальных, но количество строк мы сохраним:  

![03](/Data_Marathon/img/03_01.png)

Выделенные серым столбцы не будут выведены на экран.

Согласитесь, не очень удобно, что остаются дублирующие значения. SQL предоставляет инструмент для того, чтобы оставить только уникальные значения. Конструкция выглядит следующим образом:

```sql
SELECT DISTINCT event_name
FROM game_events
```

С английского `DISTINCT` – уникальный, то есть, мы буквально говорим: выбери уникальные значения категорий из таблицы `game_events`.

![03](/Data_Marathon/img/03_02.png)

В итоге, с помощью оператора `SELECT` мы можем выбрать не только все столбцы, а какие-то определенные, а так же можем сократить значения только до уникальных.

![03](/Data_Marathon/img/03_03.png)

Так держать! Вы успешно справляетесь с задачами! Впереди вас ждут вопросы на повторение пройденного материала. При выполнении заданий старайтесь не подглядывать в предыдущие уроки, чтобы проверить, как вы усвоили новые знания.

<hr>

[Содержание](#содержание)

# 3.2 WHERE: задаем условия запроса

Давайте попробуем теперь найти все данные по определенному событию. Для этого нам необходимо наложить условие фильтрации. С этим нам поможет оператор WHERE, который накладывает ограничения на строки. Допустим, нам необходимы данные по событию app_first_launch. Выглядит это следующим образом:

```sql
SELECT *
FROM game_events
WHERE event_name = 'app_first_launch'
```

Попробуйте запустить этот запрос.

Обратите внимание, что название события указано в кавычках.

```
+----------+------------------+------------+---------------+------------+---------+
| user_id  | event_name       | level_name | level_success | event_date | revenue |
+----------+------------------+------------+---------------+------------+---------+
| f5ef9841 | app_first_launch | NULL       | NULL          | 2021-01-15 | NULL    |
+----------+------------------+------------+---------------+------------+---------+
```

Итак, давайте разберемся как это работает.  В первую очередь очень важно понять в каком порядке работают команды, которые мы только что написали.

Давайте разберем схему ниже.

![03](/Data_Marathon/img/03_04.png)

Первым всегда будет отрабатывать оператор `FROM`, потому что перед тем как начинать работать с данными, нам необходимо указать источник этих данных.

После него всегда будет отрабатывать оператор `WHERE`, так как, после того как мы указали источник данных, нам необходимо его отфильтровать.

И только после того, как мы отфильтровали данные, они передаются в оператор `SELECT`, и там уже мы сможем выбрать столбцы, которые нам необходимы, и вывести их на экран.

А что происходит с самой таблицей? Давайте посмотрим на картинку ниже

![03](/Data_Marathon/img/03_05.png)

Как мы уже сказали, первым делом срабатывает оператор `FROM`. Фактически, он запоминает из какой именно таблицы нам необходимо получить данные и «открывает» ее для дальнейших операций. После этого мы уже можем отфильтровать строки в этой таблице.

Как показано на рисунке, `WHERE` идет по каждой строчке сверху вниз и выбирает только те из них, которые подходят условию (в нашем случае event_name должно соответствовать 'app_first_launch'). После того, как мы убрали ненужные нам строки, мы передаем отфильтрованный набор данных далее, то есть в  `SELECT`.

Все кажется очень просто и логично, но для работы в SQL (когда все станет намного сложнее) крайне важно понимать порядок отработки каждой операции.

Фильтровать данные также можно с помощью неравенств: 

+ Нестрогие неравенства обозначаются как >= (больше либо равно) или <= (меньше либо равно);
+ Строгие неравенства обозначаются как > (больше) или < (меньше).

**Например:**

+ Для вывода строк с 31 января 2021 года (включительно), требуется условие WHERE event_date >= '2021-01-31'. Мы используем неравенство >= '2021-01-31', так как нам нужны даты, которые больше или равны '2021-01-31'.
+ Если мы захотим вывести строки, где выручка меньше 5, то ставим условие WHERE revenue < 5

В отличие от строкового типа данных, когда мы ставим условие на числовые типы данных, то указываем число без кавычек.

<hr>

[Содержание](#содержание)