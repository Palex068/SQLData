# 4. Агрегирующие функции и группировка данных

## Содержание

+ [4.1 Агрегация данных](#41-агрегация-данных)
+ [4.2 Группировки](#42-группировки)

[Оглавление](/Data_Marathon/README.md)


# 4.1 Агрегация данных

В прошлом уроке мы с вами узнали, как выбирать только нужные строки с помощью запроса. В этом уроке мы познакомимся с таким понятием как агрегирующие функции*.

Давайте напишем первый запрос с агрегатной функцией: 

```sql
SELECT COUNT(*)
FROM game_events
```

Такой запрос всегда вернет только одно значение – количество строк в таблице, которая указана во FROM.

>**Агрегирующие функции** (иногда их ещё называют **агрегатными**) обрабатывают набор строк для подсчета и возвращают одно обобщенное значение.

Итак, что же происходит под капотом? Давайте разбираться.
Как мы уже знаем – FROM всегда работает первым, но в SELECT у нас написана агрегирующая функция. Эта функция считает количество строк в таблице.

1. `COUNT()` – считает количество строк 
2. `SUM()`– считает сумму в рамках столбца  
3. `AVG()`– считает среднее в рамках столбца 
4. `MIN()`– находит минимальное значение в рамках столбца
5. `MAX()`– находит максимальное значение в рамках столбца

Давайте рассмотрим каждую функцию в отдельности.

`COUNT()` считает количество строк, но при этом может работать по-разному в некоторых условиях.

`COUNT(*)` – считает количество строк в таблице

`COUNT(level_name)` – считает количество заполненных `НЕ NULL` значений в рамках столбца `level_name`

`COUNT(DISTINCT level_name)` – считает количество уникальных `НЕ NULL` значений в рамках столбца `level_name`, это означает, что повторяющиеся значения считаются только один раз

Вставь запрос ниже, чтобы проверить как это работает

```sql
SELECT COUNT(*), COUNT(level_name), COUNT(DISTINCT level_name)
FROM game_events
```

```
+----------+-------------------+----------------------------+
| COUNT(*) | COUNT(level_name) | COUNT(DISTINCT level_name) |
+----------+-------------------+----------------------------+
| 44       | 16                | 5                          |
+----------+-------------------+----------------------------+
```

Отлично! А теперь давайте дадим нашим столбцам более говорящие имена. Надеюсь Вы еще не забыли про оператор AS.

Вставь запрос в окно ниже и запустите, чтобы проверить названия столбцов:

```sql
SELECT COUNT(*) AS cnt, COUNT(level_name) AS cnt_ln, COUNT(DISTINCT level_name) AS cnt_distinct_ln
FROM game_events
```

С помощью оператора `AS` можно назвать колонки по-разному. Мы постарались дать  «говорящие» имена столбцам.
`cnt` — часто используемое сокращение от count.
`cnt_ln` — сокращение от count и первые буквы level_name.
В `cnt_distinct_ln` так же используется сокращение от `count`, слово `distinct` указывает на уникальные значения, и `ln` — сокращенно `level_name` (по первым буквам).

`SUM()` используется, чтобы посчитать сумму значений в столбце. Запрос с функцией SUM()  будет выглядеть следующим образом: 

```sql
SELECT SUM(revenue)
FROM game_events
```

Результатом будет сумма всех значений в столбце revenue.

>Используйте `SUM()` с числовым типом данных. Если использовать `SUM()` со строковым типом данных, программа отработает, но результат работы программы будет не всегда очевидный. Например, если в строке нет чисел, то функция `SUM()` посчитает ее как ноль. Если в строке на первом месте стоит число, то `SUM()` выделит его из строки как число и посчитает.

```
+-------------------+
| SUM(revenue)      |
+-------------------+
| 68.33614611625671 |
+-------------------+
```

`AVG()` считает среднее значение в столбце, к примеру: 

```sql
SELECT AVG(revenue)
FROM game_events
```

>Используйте `AVG()` с числовым типом данных. Если использовать `AVG()` со строковым типом данных, программа отработает, но результат работы программы будет не всегда очевидный. Например, если в строке нет чисел, то функция `AVG()` посчитает ее как ноль. Если в строке на первом месте стоит число, то `AVG()` выделит его из строки как число и посчитает.

```
+-------------------+
| AVG(revenue)      |
+-------------------+
| 6.212376919659701 |
+-------------------+
```

Функции `MIN()` и `MAX()` находят минимальное и максимальное значение в столбце соответственно.

```sql
SELECT MIN(event_date), MAX(event_date)
FROM game_events
```

>Если использовать `MIN()` и `MAX()` со строковыми типами данных, то функции выберут минимальное и максимальное значение по алфавиту.

```
+-----------------+-----------------+
| MIN(event_date) | MAX(event_date) |
+-----------------+-----------------+
| 2021-01-10      | 2021-01-17      |
+-----------------+-----------------+
```

В случае, когда необходимо предварительно отфильтровать данные для агрегации, можно написать соответствующее условие в WHERE. К примеру, если нам необходимо посчитать количество строк в таблице с пользователем 00aa49ac, тогда запрос будет выглядеть следующим образом: 

```sql
SELECT COUNT(*)
FROM game_events
WHERE user_id = '00aa49ac'
```

```
+----------+
| COUNT(*) |
+----------+
| 13       |
+----------+
```

Посчитайте количество покупок за все время (используйте условие event_name = 'in_app_purchase')

Вам понадобится столбец event_name

```
+----------+
| COUNT(*) |
+----------+
| 11       |
+----------+
```

<hr>

[Содержание](#содержание)

# 4.2 Группировки

Теперь, когда мы познакомились с агрегатными функциями, попробуем решить следующую задачу: посчитать сумму внутриигровых покупок каждого пользователя.

Если мы напишем запрос `SELECT SUM(revenue) FROM game_events`, то посчитаем сумму, которая поступила к нам от всех пользователей за все время. Очевидно, это не то, что нам нужно.

Для решения нам необходимо просуммировать покупки каждого пользователя по отдельности. Для этого существует `GROUP BY`. Выглядит такой запрос следующим образом: 

```sql
SELECT user_id, SUM(revenue)
FROM game_events
GROUP BY user_id
```

Давайте попробуем запустить запрос и посмотреть на результат!

```
+----------+--------------------+
| user_id  | SUM(revenue)       |
+----------+--------------------+
| 7f0344f8 | 0.9900000095367432 |
| 00aa49ac | 28.959999322891235 |
| f5ef9841 | 19.46999955177307  |
| 13d17d67 | 18.916147232055664 |
+----------+--------------------+
```

Как же это работает? Для примера давайте разберем скриншот ниже. 

![04](/Data_Marathon/img/04_01.png)

На скриншоте отображено 2 таблицы. Слева часть данных из полной таблицы game_events, справа – то, что вычисляется с помощью запроса на прошлом шаге. 

Давайте разберем что происходит на каждом этапе по порядку: 

```sql
SELECT user_id, SUM(revenue)
FROM game_events
GROUP BY user_id
```

`FROM` всегда работает в первую очередь, соответственно сначала мы получаем все данные из таблицы. 

Следующим в нашем запросе срабатывает `GROUP BY`, это как раз и есть группировка. По сути группировка разбивает всю таблицу на множество секций, в каждой секции значения указанного столбца (в нашем случае `user_id`) одинаковы. 

Далее в части `SELECT` вычисления внутри каждой из секций (в нашем случае `user_id`) будут производиться независимо. В `SELECT` у нас указано поле группировки — `user_id`, а также агрегатная функция, которая является указанием на то, что именно необходимо посчитать в рамках выделенной группы.

По своей сути группировка «схлопывает» множество строчек в одну, в примере указано порядка `30` строк, но среди них только `3` уникальных значения `user_id`, поэтому в результате и получается `3` строки. 

Также, в примере показана особенность работы функции `SUM()` с пустыми ячейками (то есть значениями `NULL`*). Функция `SUM()` не учитывает значения `NULL` при подсчете, то есть при подсчете это будет равносильно тому, что вместо `NULL` мы подставим ноль, но сама функция `SUM()` такое преобразование не делает. Поэтому у пользователя, который не совершал внутриигровых покупок, в агрегирующем столбце не будет данных и пропишется `NULL`.

>*На скриншоте значения `NULL` не прописывались, чтобы агрегация была визуально яснее.

Группировать данные можно не по одному полю, а по нескольким. Представьте, что мы хотим посчитать сумму совершенных покупок для **каждого пользователя** игры **за каждый день** (в который у пользователя была хотя бы какая-то активность). 

Как же в этом случае нам группировать данные?
+ Во-первых, нас интересует **каждый пользователь** в отдельности, значит в `GROUP BY` добавляем `user_id`.
+ Во-вторых, нам нужны данные **за каждый день**, значит в `GROUP BY` требуется добавить также `event_date`.

Целиком запрос будет выглядеть следующим образом:

```sql
SELECT user_id, event_date, SUM(revenue) 
FROM game_events
GROUP BY user_id, event_date
```

Скопируйте его и запустите, чтобы посмотреть полученные данные.

>Если бы мы сделали группировку только по полю user_id, то у нас получилась бы сумма внутриигровых покупок для каждого пользователя за всё время.<br>
>Если бы мы сделали группировку только по полю event_date, то у нас получилась бы сумма внутриигровых покупок за каждый день для всех пользователей.

```
+----------+------------+--------------------+
| user_id  | event_date | SUM(revenue)       |
+----------+------------+--------------------+
| 7f0344f8 | 2021-01-10 | 0.9900000095367432 |
| 00aa49ac | 2021-01-13 | 19.46999955177307  |
| 00aa49ac | 2021-01-14 | 9.489999771118164  |
| f5ef9841 | 2021-01-16 | 9.489999771118164  |
| f5ef9841 | 2021-01-15 | 9.979999780654907  |
| 13d17d67 | 2021-01-13 | 11.837027072906494 |
| 13d17d67 | 2021-01-15 | 7.07912015914917   |
| 13d17d67 | 2021-01-17 | NULL               |
+----------+------------+--------------------+
```

А теперь посчитайте, сколько игровых событий (`event_name`) произошло у каждого игрока за каждый день. Выведите идентификатор игрока, дату и количество событий.

Вам понадобятся столбцы `user_id`, `event_date` и `event_name` из таблицы `game_events`.

```sql
SELECT user_id,
       event_date,
       COUNT(event_name)
FROM game_events
GROUP BY 1, 2
```

```
+----------+------------+-------------------+
| user_id  | event_date | COUNT(event_name) |
+----------+------------+-------------------+
| 7f0344f8 | 2021-01-10 | 3                 |
| 00aa49ac | 2021-01-13 | 9                 |
| 00aa49ac | 2021-01-14 | 4                 |
| f5ef9841 | 2021-01-16 | 9                 |
| f5ef9841 | 2021-01-15 | 8                 |
| 13d17d67 | 2021-01-13 | 6                 |
| 13d17d67 | 2021-01-15 | 3                 |
| 13d17d67 | 2021-01-17 | 2                 |
+----------+------------+-------------------+
```

На прошлых шагах вы посчитали сумму внутриигровых покупок и количество внутриигровых событий для каждого пользователя за каждый день. На основе этих данных можно построить графики, чтобы спрогнозировать доход, а также понять сохраняется ли интерес пользователей к игре.

![04](/Data_Marathon/img/04_02.png)

Так как мы делали группировку по пользователям, то проведя более глубокую аналитику с дополнительными данными, можно выделить тип пользователей, которые тратят больше денег на внутриигровые покупки и постоянно играют. Для таких пользователей можно проводить отдельные маркетинговые кампании. А тем, кто стал играть реже, можно предлагать скидки или внутриигровые подарки, чтобы привлечь их обратно в игру.

Давайте разберем наиболее распространенные ошибки при группировке данных в `SQL`.

В части `SELECT` необходимо указывать поля, которые указываются в `GROUP BY`, или агрегирующие функции(`SUM()`, `MAX()`, `MIN()`, `AVG()`, `COUNT()`), например:

```sql
SELECT user_id, event_date, SUM(revenue) 
FROM game_events
GROUP BY user_id, event_date
```

Как видно на примере, в `SELECT` указано три поля: `user_id`, `event_date` и `revenue`. По первым двум полям мы производим группировку, поэтому данные поля указаны в `GROUP BY`. А вот к полю `revenue` применена функция `SUM()`, то есть по полю `revenue` будет считаться сумма в разрезе установленной группы (`GROUP BY user_id, event_date`).

Если мы добавим еще один столбец в `SELECT`, но не пропишем его в `GROUP BY`, то при выполнении программа не будет понимать как обрабатывать этот столбец. Выглядеть это будет примерно так:

![04](/Data_Marathon/img/04_03.gif)

Если необходимо предварительно отфильтровать данные, то между FROMи GROUP BYнужно написать WHERE. К примеру, если необходимо посчитать сумму внутриигровых покупок каждого пользователя за 13 января 2021 года, то в запрос необходимо добавить WHERE event_date = '2021-01-13'. Тогда запрос будет выглядеть таким образом:

```sql
SELECT user_id, SUM(revenue)
FROM game_events
WHERE event_date = '2021-01-13'
GROUP BY user_id
```

```
+----------+--------------------+
| user_id  | SUM(revenue)       |
+----------+--------------------+
| 00aa49ac | 19.46999955177307  |
| 13d17d67 | 11.837027072906494 |
+----------+--------------------+
```

Теперь давайте посмотрим, как посчитать **количество уникальных пользователей за каждый день**. 

Для начала нужно определиться с данными, которые необходимо получить на выходе. 

+ Так как данные нужно посчитать **за каждый день**, необходимо использовать столбец `event_date` в качестве поля для группировки.
+ Для подсчета **количества** уникальных пользователей используем функцию `COUNT()`.
+ И не забываем оператор `DISTINCT`, чтобы посчитать именно уникальных пользователей.

Решение задачи будет выглядеть так: 

```sql
SELECT event_date, COUNT(DISTINCT user_id)
FROM game_events
GROUP BY event_date
```

Порядок работы остается такой же, какой мы обсуждали ранее. Здесь хочется подробнее рассмотреть функцию `COUNT()` и ее возможности. 

Так как за один день пользователь совершает множество игровых действий, соответственно записей будет множество. Для примера рассмотрим часть данных из полной таблицы `game_events`. Взглянем на 10 января 2021 года (первые строки). Несмотря на то, что в таблице за этот день отображено 3 строки, уникальных пользователей будет двое. 


![04](/Data_Marathon/img/04_04.png)

Простыми словами, после того, как с помощью `GROUP BY` был выделен каждый день, в каждом дне происходит подсчет уникальных пользователей, это происходит в момент работы `SELECT`.

Посчитайте количество уникальных пользователей за каждый день в нашей таблице game_events. 

Скопируйте запрос ниже и запустите его:

```sql
SELECT event_date, COUNT(DISTINCT user_id)
FROM game_events
GROUP BY event_date
```

```
+------------+-------------------------+
| event_date | COUNT(DISTINCT user_id) |
+------------+-------------------------+
| 2021-01-10 | 1                       |
| 2021-01-13 | 2                       |
| 2021-01-14 | 1                       |
| 2021-01-15 | 2                       |
| 2021-01-16 | 1                       |
| 2021-01-17 | 1                       |
+------------+-------------------------+
```

Найти дату первого и последнего игрового события для каждого игрока. 

Вам понадобятся столбцы `user_id` и `event_date` из таблицы `game_events`.

```sql
SELECT user_id,
       MIN(event_date),
       MAX(event_date)
FROM game_events
GROUP BY 1
```

```
+----------+-----------------+-----------------+
| user_id  | MIN(event_date) | MAX(event_date) |
+----------+-----------------+-----------------+
| 7f0344f8 | 2021-01-10      | 2021-01-10      |
| 00aa49ac | 2021-01-13      | 2021-01-14      |
| f5ef9841 | 2021-01-15      | 2021-01-16      |
| 13d17d67 | 2021-01-13      | 2021-01-17      |
+----------+-----------------+-----------------+
```

А теперь давайте узнаем, какие внутриигровые активности происходят каждый день: посчитайте количество записей по каждой внутриигровой активности (`event_name`) за каждый день. Выведите дату, название внутриигровой активности и количество записей.

Вам понадобятся столбцы event_name и event_date из таблицы game_events.

```sql
SELECT event_name,
       event_date,
       COUNT(*)
FROM game_events
GROUP BY 1, 2
```

```
+------------------------+------------+----------+
| event_name             | event_date | COUNT(*) |
+------------------------+------------+----------+
| in_app_purchase        | 2021-01-10 | 1        |
| daily_game_events      | 2021-01-10 | 1        |
| daily_battle_victories | 2021-01-10 | 1        |
| level_end              | 2021-01-13 | 3        |
| level_start            | 2021-01-13 | 3        |
| level_start            | 2021-01-14 | 1        |
| in_app_purchase        | 2021-01-13 | 5        |
| in_app_purchase        | 2021-01-14 | 1        |
| daily_game_events      | 2021-01-13 | 2        |
| daily_game_events      | 2021-01-14 | 1        |
| daily_battle_victories | 2021-01-14 | 1        |
| daily_battle_victories | 2021-01-13 | 2        |
| level_end              | 2021-01-16 | 3        |
| level_end              | 2021-01-15 | 1        |
| level_start            | 2021-01-16 | 3        |
| level_start            | 2021-01-15 | 2        |
| app_first_launch       | 2021-01-15 | 1        |
| in_app_purchase        | 2021-01-15 | 3        |
| in_app_purchase        | 2021-01-16 | 1        |
| daily_game_events      | 2021-01-16 | 1        |
| daily_game_events      | 2021-01-15 | 2        |
| daily_battle_victories | 2021-01-16 | 1        |
| daily_battle_victories | 2021-01-15 | 2        |
| daily_game_events      | 2021-01-17 | 1        |
| daily_battle_victories | 2021-01-17 | 1        |
+------------------------+------------+----------+
```

Теперь немного усложним предыдущий запрос. Посчитайте количество записей по каждой внутриигровой активности (`event_name`) за каждый день, начиная с 14 января 2021 года (включительно). Выведите дату, название внутриигровой активности и количество записей.

Вам понадобятся столбцы `event_name` и `event_date` из таблицы `game_events`.

```sql
SELECT event_name,
       event_date,
       COUNT(*)
FROM game_events
WHERE event_date >= '2021-01-14'
GROUP BY 1, 2
```

```
+------------------------+------------+----------+
| event_name             | event_date | COUNT(*) |
+------------------------+------------+----------+
| level_start            | 2021-01-14 | 1        |
| in_app_purchase        | 2021-01-14 | 1        |
| daily_game_events      | 2021-01-14 | 1        |
| daily_battle_victories | 2021-01-14 | 1        |
| level_end              | 2021-01-16 | 3        |
| level_end              | 2021-01-15 | 1        |
| level_start            | 2021-01-16 | 3        |
| level_start            | 2021-01-15 | 2        |
| app_first_launch       | 2021-01-15 | 1        |
| in_app_purchase        | 2021-01-15 | 3        |
| in_app_purchase        | 2021-01-16 | 1        |
| daily_game_events      | 2021-01-16 | 1        |
| daily_game_events      | 2021-01-15 | 2        |
| daily_battle_victories | 2021-01-16 | 1        |
| daily_battle_victories | 2021-01-15 | 2        |
| daily_game_events      | 2021-01-17 | 1        |
| daily_battle_victories | 2021-01-17 | 1        |
+------------------------+------------+----------+
```

Выведите дату, сумму внутриигровых покупок и количество уникальных пользователей за каждый день до 15 января 2021 года (включительно).
Столбец, содержащий сумму внутриигровых покупок, назовите `total_revenue`, а столбец, содержащий количество уникальных пользователей, назовите `cnt_users`.

Вам понадобятся столбцы `event_date`, `revenue`, `user_id`  из таблицы `game_events`.

Название столбца `cnt_users` сокращение от `count users`.

```sql
SELECT event_date,
       SUM(revenue) AS total_revenue,
       COUNT(DISTINCT user_id) AS cnt_users
FROM game_events
WHERE event_date <= '2021-01-15'
GROUP BY 1
```

```
+------------+--------------------+-----------+
| event_date | total_revenue      | cnt_users |
+------------+--------------------+-----------+
| 2021-01-10 | 0.9900000095367432 | 1         |
| 2021-01-13 | 31.307026624679565 | 2         |
| 2021-01-14 | 9.489999771118164  | 1         |
| 2021-01-15 | 17.059119939804077 | 2         |
+------------+--------------------+-----------+
```

А теперь давайте усложним предыдущую задачу и посчитаем, какую сумму в среднем тратили пользователи каждый день на внутриигровые покупки. Как и в предыдущем запросе, возьмем все дни до 15 января 2021 года (включительно).

Сперва решим, как посчитать, сколько в среднем денег потратили пользователи на внутриигровые покупки. Для этого сумму покупок за день `SUM(revenue)` нужно разделить на количество уникальных пользователей `COUNT(DISTINCT user_id)`.  Такую математическую операцию можно сделать прямо в `SELECT: SUM(revenue)/COUNT(DISTINCT user_id)`.

Используя предыдущий запрос, выведите дату и сколько в среднем денег потратили пользователи на внутриигровые покупки.

Столбец «сколько в среднем денег потратили пользователи на внутриигровые покупки» назовите `avg_revenue`.

Вам понадобятся столбцы `event_date`, `revenue`, `user_id`  из таблицы `game_events`.

>**Дополнение:**<br>
>Вы же помните про функцию `AVG()`? В данном случае мы ее применить не можем, так как она даст другой результат. `AVG(revenue)` посчитает средний чек, то есть среднюю сумму покупки. А нам нужно посчитать сколько в среднем денег тратил пользователь на покупки. Чтобы было более понятно, давайте рассмотрим простой пример. За день было совершено 10 покупок, и каждая на сумму 10 рублей. Все эти покупки совершил один и тот же пользователь. Если посчитать AVG(revenue), то мы получим 10 рублей (средняя стоимость одной покупки): (10 покупок * 10 руб.) / 10 покупок.
>А если посчитать, сколько в среднем денег потратили пользователи на покупки, то нам нужно всю сумму поделить на количество пользователей  (10 покупок * 10 руб.) / 1 пользователя. Тогда мы получим, что 1 пользователь в среднем тратит на покупки 100 рублей.

```sql
SELECT event_date,
       SUM(revenue) / COUNT(DISTINCT user_id) AS avg_revenue
FROM game_events
WHERE event_date <= '2021-01-15'
GROUP BY 1
```

```
+------------+--------------------+
| event_date | avg_revenue        |
+------------+--------------------+
| 2021-01-10 | 0.9900000095367432 |
| 2021-01-13 | 15.653513312339783 |
| 2021-01-14 | 9.489999771118164  |
| 2021-01-15 | 8.529559969902039  |
+------------+--------------------+
```

![04](/Data_Marathon/img/04_05.png)

Друзья, наше погружение в SQL подошло к концу! Надеемся, что это короткое знакомство с SQL стало для вас полезным и теперь вы захотите изучить этот язык еще глубже.
Двигаемся дальше, на очереди – Python!

<hr>

[Содержание](#содержание)
