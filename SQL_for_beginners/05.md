# 5. Группировка данных

## Содержание

+ [5.1 Агрегатные функции](#51-агрегатные-функции)
    + [Агрегатные функции](#агрегатные-функции)
    + [Функция `AVG()`](#функция-avg)
    + [Функция `COUNT()`](#функция-count)
    + [Функции `MIN()` и `MAX()`](#функции-min-и-max)
    + [Функция `SUM()`](#функция-sum)
    + [Функция `GROUP_CONCAT()`](#функция-group_concat)
+ [5.2 Группировка данных](#52-группировка-данных)
    + [Группировка данных]()
        + [Создание групп](#создание-групп)
        + [Группировка по нескольким полям](#группировка-по-нескольким-полям)
        + [Группировка по вычисляемому полю](#группировка-по-вычисляемому-полю)
    + [Фильтрация групп](#фильтрация-групп)
    + [Сортировка групп](#сортировка-групп)
    + [Порядок обработки и выполнения операторов](#порядок-обработки-и-выполнения-операторов)
+ [5.3 Решение задач](#53-решение-задач)

[Оглавление](/SQL_for_beginners/README.MD)

# 5.1 Агрегатные функции

Урок посвящен итоговым вычислениям, выполняемым с помощью агрегатных функций.

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем Songs, которая содержит информацию о десяти наиболее популярных песнях на некоторой площадке для прослушивания музыки:

```
+----+-------+-------------------------+------------+---------+--------------+--------+
| id | place | trackname               | artist     | streams | release_year | length |
+----+-------+-------------------------+------------+---------+--------------+--------+
| 1  | 4     | Crazy on You            | Heart      | 303885  | 1976         | 254    |
| 2  | 7     | My Lover                | The Sounds | 211133  | 2009         | 266    |
| 3  | 3     | Running up That Hill    | Kate Bush  | 339583  | NULL         | 296    |
| 4  | 5     | Thrill                  | The Sounds | 294264  | 2016         | 228    |
| 5  | 9     | Spent the Day in Bed    | Morrissey  | 174994  | 2017         | 259    |
| 6  | 2     | Bigmouth Strikes Again  | The Smiths | 379112  | 1986         | 195    |
| 7  | 6     | Painted By Numbers      | The Sounds | 265121  | 2006         | 200    |
| 8  | 8     | Let Me Kiss You         | Morrissey  | 197426  | 2004         | 210    |
| 9  | 1     | Keep Yourself Alive     | Queen      | 385991  | NULL         | 235    |
| 10 | 10    | Everyday is Like Sunday | Morrissey  | 160404  | 1988         | 216    |
+----+-------+-------------------------+------------+---------+--------------+--------+
```
Первое поле этой таблицы содержит идентификатор песни, второе — позицию песни в топе, третье — название песни, четвертое — псевдоним исполнителя или название группы, пятое — количество прослушиваний, шестое — дату выхода, седьмое — продолжительность в секундах.

Скрипт для создания таблицы `Songs`

```sql
DROP TABLE IF EXISTS Songs;
CREATE TABLE Songs
(
    id           INT PRIMARY KEY AUTO_INCREMENT,
    place        INT,
    trackname    VARCHAR(40),
    artist       VARCHAR(40),
    streams      INT,
    release_year INT,
    length       INT
);

INSERT INTO Songs (place, trackname, artist, streams, release_year, length)
VALUES (4, 'Crazy on You', 'Heart', 303885, 1976, 254),
       (7, 'My Lover', 'The Sounds', 211133, 2009, 266),
       (3, 'Running up That Hill', 'Kate Bush', 339583, NULL, 296),
       (5, 'Thrill', 'The Sounds', 294264, 2016, 228),
       (9, 'Spent the Day in Bed', 'Morrissey', 174994, 2017, 259),
       (2, 'Bigmouth Strikes Again', 'The Smiths', 379112, 1986, 195),
       (6, 'Painted By Numbers', 'The Sounds', 265121, 2006, 200),
       (8, 'Let Me Kiss You', 'Morrissey', 197426, 2004, 210),
       (1, 'Keep Yourself Alive', 'Queen', 385991, NULL, 235),
       (10, 'Everyday is Like Sunday', 'Morrissey', 160404, 1988, 216);
```

<hr>

[Содержание](#содержание)

## Агрегатные функции

Нередко при извлечении данных бывает необходимо не просто отобразить их в исходном или форматированном виде, а выполнить с ними определенного рода итоговые вычисления, например, определить сумму возвращенных значений или найти среди них минимальное. В SQL для этого предусмотрены агрегатные функции — функции, которые выполняют вычисления на наборе значений и возвращают одиночное значение. Запросы с такими функциями часто используются для анализа данных и создания отчетов.

<hr>

[Содержание](#содержание)

## Функция `AVG()`

Функция `AVG()` используется для вычисления среднего арифметического числовых значений поля. Например, с помощью данной функции мы можем определить среднее количество прослушиваний всех песен.

Результатом приведенного ниже запроса:

```sql
SELECT AVG(streams) AS avg_streams
FROM Songs;
```

является:

```
+-------------+
| avg_streams |
+-------------+
| 271191.3000 |
+-------------+
```

Запрос выше возвращает единственное значение, соответствующее среднему количеству прослушиваний всех десяти песен. Дополнительно можно воспользоваться блоком `WHERE` и найти среднее значение на основе не всех значений поля, а лишь тех, что удовлетворяют определенным условиям.

Результатом приведенного ниже запроса:

```sql
SELECT AVG(streams) AS avg_streams
FROM Songs
WHERE release_year >= 2000;
```

является:

```
+-------------+
| avg_streams |
+-------------+
| 228587.6000 |
+-------------+
```

В этом запросе выбираются только те записи, значение поля `release_year` которых больше или равно 2000, поэтому итоговое значение является средним количеством прослушиваний только тех песен, что были выпущены в 2000 году и позднее.

Функция `AVG()` игнорирует значения `NULL` при вычислении среднего арифметического значений поля.

<hr>

[Содержание](#содержание)

## Функция `COUNT()`

Функция `COUNT()` используется для подсчета количества записей в таблице или количества значений в поле. Для определения количества записей в таблице в функцию `COUNT()` в качестве аргумента необходимо передать звездочку (*).

Результатом приведенного ниже запроса:

```sql
SELECT COUNT(*) AS num_of_songs
FROM Songs;
```

является:

```
+--------------+
| num_of_songs |
+--------------+
| 10           |
+--------------+
```

Аналогично функции `AVG()`, функция `COUNT()` может использоваться для подсчета количества записей, удовлетворяющих определенным условиям. К примеру, мы можем определить, сколько песен принадлежит исполнителю Morrisey.

Результатом приведенного ниже запроса:

```sql
SELECT COUNT(*) AS num_of_songs
FROM Songs
WHERE artist = 'Morrissey';
```

является:

```
+--------------+
| num_of_songs |
+--------------+
| 3            |
+--------------+
```

Для определения количества значений в поле функции `COUNT()` в качестве аргумента необходимо передать это поле.

Результатом приведенного ниже запроса:

```sql
SELECT COUNT(trackname) AS num_of_tracknames
FROM Songs;
```

является:

```
+-------------------+
| num_of_tracknames |
+-------------------+
| 10                |
+-------------------+
```

Важным отличием между вызовами `COUNT(*)` и `COUNT(<название поля>)` является то, что в первом случае возвращается количество записей в таблице без учета значений в этих записях, в то время как во втором случае возвращается количество значений в поле, причем значения `NULL` не учитываются.

Результатом приведенного ниже запроса:

```sql
SELECT COUNT(*) AS num_of_songs,
       COUNT(release_year) AS num_of_years
FROM Songs;
```

является:

```
+--------------+--------------+
| num_of_songs | num_of_years |
+--------------+--------------+
| 10           | 8            |
+--------------+--------------+
```

<hr>

[Содержание](#содержание)

## Функции `MIN()` и `MAX()`

Функции `MIN()` и `MAX()` используются для поиска минимального и максимального значений в поле соответственно. Например, с помощью функции `MIN()` мы можем найти продолжительность самой короткой песни.

Результатом приведенного ниже запроса:

```sql
SELECT MIN(length) AS min_length
FROM Songs;
```

является:

```
+------------+
| min_length |
+------------+
| 195        |
+------------+
```

Функции `MIN()` и `MAX()`, как и другие агрегатные функции, могут использоваться не на всех значениях поля, а лишь на определенных. К примеру, с помощью функции `MAX()` можно определить продолжительность самой долгой песни группы `The Sounds`.

Результатом приведенного ниже запроса:

```sql
SELECT MAX(length) AS max_length
FROM Songs
WHERE artist = 'The Sounds';
```

является:

```
+------------+
| max_length |
+------------+
| 266        |
+------------+
```

Функции `MIN()` и `MAX()` игнорируют значения `NULL` при вычислении минимального и максимального значений поля соответственно.

Несмотря на то что функции `MIN()` и `MAX()` обычно применяются к полям, содержащим числовые значения или даты, они могут применяться и к строковым полям.

Результатом приведенного ниже запроса:

```sql
SELECT MIN(trackname) AS min_trackname,
       MAX(artist) AS max_artist
FROM Songs;
```

является:

```
+------------------------+------------+
| min_trackname          | max_artist |
+------------------------+------------+
| Bigmouth Strikes Again | The Sounds |
+------------------------+------------+
```

При работе со строками функция `MIN()` возвращает строку, которая была бы первой, если бы эти строки были отсортированы в лексикографическом порядке. Функция `MAX()`, напротив,  возвращает строку, которая была бы последней, если бы строки были отсортированы в лексикографическом порядке.

<hr>

[Содержание](#содержание)

## Функция `SUM()`

Функция `SUM()` используется для вычисления суммы числовых значений поля. Например, с помощью данной функции мы можем определить количество прослушиваний всех десяти песен.

Результатом приведенного ниже запроса:

```sql
SELECT SUM(streams) AS sum_streams
FROM Songs;
```

является:

```
+-------------+
| sum_streams |
+-------------+
| 2711913     |
+-------------+
```

Аналогично предыдущим примерам, можно дополнительно воспользоваться блоком `WHERE`, чтобы вычислить количество прослушиваний не всех песен, а лишь определенного исполнителя, например, `Morrissey`.

Результатом приведенного ниже запроса:

```sql
SELECT SUM(streams) AS sum_streams
FROM Songs
WHERE artist = 'Morrissey';
```

является:

```
+-------------+
| sum_streams |
+-------------+
| 532824      |
+-------------+
```

Функция `SUM()` игнорирует значения `NULL` при вычислении суммы значений поля.

<hr>

[Содержание](#содержание)

## Функция `GROUP_CONCAT()`

Функция `GROUP_CONCAT()` используется для перечисления значений поля через запятую. Например, с помощью данной функции мы можем перечислить названия первых пяти песен.

Результатом приведенного ниже запроса:

```sql
SELECT GROUP_CONCAT(trackname) AS songs
FROM Songs
WHERE id <= 5;
```

является:

```sql
+------------------------------------------------------------------------+
| songs                                                                  |
+------------------------------------------------------------------------+
| Crazy on You,My Lover,Running up That Hill,Thrill,Spent the Day in Bed |
+------------------------------------------------------------------------+
```

Перечисляемые функцией `GROUP_CONCAT()` значения можно сортировать. Для этого после названия поля, значения которого необходимо перечислить, нужно указать оператор `ORDER BY`, а затем предоставить одно или несколько полей, по которым должна быть выполнена сортировка.

Результатом приведенного ниже запроса:

```sql 
SELECT GROUP_CONCAT(trackname ORDER BY trackname) AS songs
FROM Songs
WHERE id <= 5;
```

является:

```
+------------------------------------------------------------------------+
| songs                                                                  |
+------------------------------------------------------------------------+
| Crazy on You,My Lover,Running up That Hill,Spent the Day in Bed,Thrill |
+------------------------------------------------------------------------+
```

Запятая является разделителем по умолчанию, и его можно изменить. Чтобы задать собственный разделитель, необходимо воспользоваться ключевым словом `SEPARATOR`, после которого предоставить строку, содержащую разделитель.

Результатом приведенного ниже запроса:

```sql
SELECT GROUP_CONCAT(trackname SEPARATOR '; ') AS songs
FROM Songs
WHERE id <= 5;
```

является:

```
+----------------------------------------------------------------------------+
| songs                                                                      |
+----------------------------------------------------------------------------+
| Crazy on You; My Lover; Running up That Hill; Thrill; Spent the Day in Bed |
+----------------------------------------------------------------------------+
```

При совместном использовании операторов `ORDER BY` и `SEPARATOR` внутри функции `GROUP_CONCAT()` важно соблюдать их расположение относительно друг друга: сначала указываются правила сортировки, после определяется разделитель.

Результатом приведенного ниже запроса:

```sql
SELECT GROUP_CONCAT(trackname ORDER BY trackname SEPARATOR '; ') AS songs
FROM Songs
WHERE id <= 5;
```

является:

```
+----------------------------------------------------------------------------+
| songs                                                                      |
+----------------------------------------------------------------------------+
| Crazy on You; My Lover; Running up That Hill; Spent the Day in Bed; Thrill |
+----------------------------------------------------------------------------+
```

Функция `GROUP_CONCAT()` игнорирует значения `NULL` при перечислении значений поля.

<hr>

[Содержание](#содержание)

## Примечания 1

**Примечание 1.** Внутри функций `AVG()`, `COUNT()`, `SUM()` и `GROUP_CONCAT()` можно использовать ключевое слово `DISTINCT`, чтобы в итоговых вычислениях участвовали лишь уникальные значения поля:

```sql
... AVG(DISTINCT <название поля>)
... COUNT(DISTINCT <название поля>)
... SUM(DISTINCT <название поля>)
... GROUP_CONCAT(DISTINCT <название поля>)
```

**Примечание 2.** Помимо обычных полей, в качестве аргумента агрегатным функциям можно передавать и вычисляемые поля.

Результатом приведенного ниже запроса:

```sql
SELECT MAX(length DIV 60) AS max_length_in_mins
FROM Songs;
```

является:

```
+--------------------+
| max_length_in_mins |
+--------------------+
| 4                  |
+--------------------+
```

Так, в запросе выше сперва все значения поля `length` делятся нацело на `60`, а затем среди них выполняется поиск максимального.

**Примечание 3.** Функции `AVG()` и `SUM()` возвращают значение `0.0`, если применяются к нечисловым полям.

Результатом приведенного ниже запроса:

```sql
SELECT AVG(trackname) as trackname,
       SUM(artist) as avg_artist
FROM Songs;
```

является:

```
+-----------+------------+
| trackname | avg_artist |
+-----------+------------+
| 0.0       | 0.0        |
+-----------+------------+
```

**Примечание 4.** Если все значения поля, переданного в качестве аргумента в агрегатную функцию, имеют значение `NULL`, возвращаемым значением функции также будет значение `NULL`.

**Примечание 5.** Агрегатные функции не могут использоваться в блоке `WHERE`.

Результатом приведенного ниже запроса:

```sql
SELECT trackname
FROM Songs
WHERE place = MAX(place);
```

является ошибка, а не название песни, находящейся на последнем месте.

Данное поведение достаточно логично, ведь оператор `WHERE` используется для фильтрации записей. Поэтому если мы указываем в какой-либо части условия поле `place`, то мы имеем в виду значение, которое содержит запись в поле `place`, а не все значения, которые содержит таблица в поле `place`.

<hr>

[Содержание](#содержание)

# 5.2 Группировка данных

Урок посвящен группировке данных.

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем Songs, которая содержит информацию о десяти наиболее популярных песнях на некоторой площадке для прослушивания музыки:

```
+----+--------------------------+--------------------------------+------------+---------+
| id | album                    | trackname                      | artist     | streams |
+----+--------------------------+--------------------------------+------------+---------+
| 1  | American Idiot           | Wake Me up When September Ends | Green Day  | 23454   |
| 2  | Dreamboat Annie          | Crazy on You                   | Heart      | 44371   |
| 3  | No Exit                  | Maria                          | Blondie    | 99581   |
| 4  | The Queen Is Dead        | Bigmouth Strikes Again         | The Smiths | 42700   |
| 5  | American Idiot           | American Idiot                 | Green Day  | 15630   |
| 6  | Crossing the Rubicon     | Midnight Sun                   | The Sounds | 66928   |
| 7  | Crossing the Rubicon     | Queen of Apology               | The Sounds | 53147   |
| 8  | American Idiot           | Holiday                        | Green Day  | 12786   |
| 9  | Pollinator               | Gravity                        | Blondie    | 80603   |
| 10 | Dying to Say This to You | Painted By Numbers             | The Sounds | 88726   |
+----+--------------------------+--------------------------------+------------+---------+
```

Первое поле этой таблицы содержит идентификатор песни, второе — название альбома, в состав которого входит песня, третье — название песни, четвертое — псевдоним исполнителя или название группы, пятое — количество прослушиваний.

Скрипт для создания таблицы `Songs`

```sql
DROP TABLE IF EXISTS Songs;
CREATE TABLE Songs
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    album     VARCHAR(40),
    trackname VARCHAR(40),
    artist    VARCHAR(40),
    streams   INT
);

INSERT INTO Songs (album, trackname, artist, streams)
VALUES ('American Idiot', 'Wake Me up When September Ends', 'Green Day', 23454),
       ('Dreamboat Annie', 'Crazy on You', 'Heart', 44371),
       ('No Exit', 'Maria', 'Blondie', 99581),
       ('The Queen Is Dead', 'Bigmouth Strikes Again', 'The Smiths', 42700),
       ('American Idiot', 'American Idiot', 'Green Day', 15630),
       ('Crossing the Rubicon', 'Midnight Sun', 'The Sounds', 66928),
       ('Crossing the Rubicon', 'Queen of Apology', 'The Sounds', 53147),
       ('American Idiot', 'Holiday', 'Green Day', 12786),
       ('Pollinator', 'Gravity', 'Blondie', 80603),
       ('Dying to Say This to You', 'Painted By Numbers', 'The Sounds', 88726);
```

<hr>

[Содержание](#содержание)

## Группировка данных

Агрегатные функции позволяют выполнить ряд итоговых вычислений с данными. Например, с помощью функции `COUNT()` мы можем определить количество песен, принадлежащих группе `Green Day`.

Результатом приведенного ниже запроса:

```sql
SELECT COUNT(*) AS num_of_songs
FROM Songs
WHERE artist = 'Green Day';
```

является:

```
+--------------+
| num_of_songs |
+--------------+
| 3            |
+--------------+
```

Аналогичным образом мы можем определить количество песен, принадлежащих какому-либо другому определенному исполнителю. Однако если нам понадобится вычислить количество песен, принадлежащих каждому исполнителю, сделать это лишь с помощью агрегатных функций не выйдет.

Для решения подобной задачи используются группы. Группировка дает возможность разделить все данные на логические наборы, благодаря чему становится возможным выполнение итоговых вычислений отдельно по каждой группе.

<hr>

[Содержание](#содержание)

### Создание групп

Группа представляет собой набор записей, которые определенным образом связаны друг с другом. Создание групп выполняется с помощью оператора `GROUP BY`, после которого указывается название поля, определяющего принцип группировки. Так, две записи попадают в одну группу, если их значения поля, указанного после оператора `GROUP BY`, совпадают.

В качестве примера использования оператора группировки напишем запрос, решающий предложенную ранее задачу по определению количества песен, принадлежащих каждому исполнителю.

Результатом приведенного ниже запроса:

```sql
SELECT artist,
       COUNT(*) AS num_of_songs
FROM Songs
GROUP BY artist;
```

является:

```
+------------+--------------+
| artist     | num_of_songs |
+------------+--------------+
| Green Day  | 3            |
| Heart      | 1            |
| Blondie    | 2            |
| The Smiths | 1            |
| The Sounds | 3            |
+------------+--------------+
```

Часть запроса `GROUP BY` `artist` говорит о том, что записи при извлечении должны быть сгруппированы по полю `artist`, в результате чего в части запроса `SELECT artist, COUNT(*) AS num_of_songs` выполняется работа не со всеми записями из таблицы, а с определенной группой записей. Таким образом, для каждой группы определяются значения полей `artist` и `num_of_songs`, первое из которых содержит название исполнителя, второе — количество записей в группе, что соответствует количеству песен исполнителя.

<hr>

[Содержание](#содержание)

### Группировка по нескольким полям

После оператора `GROUP BY` не обязательно должно указываться единственное поле, их может быть несколько, и в таком случае группировка будет выполняться по всем перечисленным полям. Другими словами, две записи попадут в одну группу, если их значения по всем полям, указанным после оператора `GROUP BY`, совпадают.

Группировка по нескольким полям позволяет распределять данные более строго. Например, рассмотренные ранее музыкальные песни мы можем разбить на группы не только по исполнителям, но и по альбомам, которым эти песни принадлежат.

Результатом приведенного ниже запроса:

```sql
SELECT artist, album,
       COUNT(*) AS num_of_songs
FROM Songs
GROUP BY artist, album;
```

является:

```
+------------+--------------------------+--------------+
| artist     | album                    | num_of_songs |
+------------+--------------------------+--------------+
| Green Day  | American Idiot           | 3            |
| Heart      | Dreamboat Annie          | 1            |
| Blondie    | No Exit                  | 1            |
| The Smiths | The Queen Is Dead        | 1            |
| The Sounds | Crossing the Rubicon     | 2            |
| Blondie    | Pollinator               | 1            |
| The Sounds | Dying to Say This to You | 1            |
+------------+--------------------------+--------------+
```

<hr>

[Содержание](#содержание)

###  Группировка по вычисляемому полю

Поля, указываемые после оператора `GROUP BY`, могут быть вычисляемыми. Например, для группировки записей по полям `artist` и `album` мы можем не просто перечислить их после оператора `GROUP BY`, а использовать их конкатенацию.

Результатом приведенного ниже запроса:

```sql
SELECT CONCAT(artist, ', ', album) AS artist_and_album,
       COUNT(*) AS num_of_songs
FROM Songs
GROUP BY CONCAT(artist, ', ', album);
```

является:

```
+--------------------------------------+--------------+
| artist_and_album                     | num_of_songs |
+--------------------------------------+--------------+
| Green Day, American Idiot            | 3            |
| Heart, Dreamboat Annie               | 1            |
| Blondie, No Exit                     | 1            |
| The Smiths, The Queen Is Dead        | 1            |
| The Sounds, Crossing the Rubicon     | 2            |
| Blondie, Pollinator                  | 1            |
| The Sounds, Dying to Say This to You | 1            |
+--------------------------------------+--------------+
```

Записи при выполнении запроса выше группируются по возвращаемому значению функции `CONCAT()`, а не прямым значениям полей `artist` и `album`, то есть при такой группировке две записи попадают в одну группу в том случае, если их значения, возвращаемые функцией `CONCAT()`, совпадают.

<hr>

[Содержание](#содержание)

### Особенности группировки

При использовании оператора `GROUP BY` мы работаем не с одиночными записями, а с наборами записей, в связи с чем возникает ряд ограничений. Например, нельзя извлечь поле, не участвующее в группировке, так как у двух записей в группе могут быть разные значения по этому полю.

Результатом приведенного ниже запроса:

```sql
SELECT artist, trackname
FROM Songs
GROUP BY artist;
```

является ошибка:

```
ERROR 1055: Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'stepik_T2WUgrEW.Songs.trackname' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
```

Также нельзя осуществлять сортировку по полю, не участвующему в группировке.

Результатом приведенного ниже запроса:

```sql
SELECT artist
FROM Songs
GROUP BY artist
ORDER BY album;
```

является ошибка:

```
ERROR 1055: Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column 'beegeek.Songs.album' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
```

Таким образом, при использовании группировки для извлечения доступен лишь ограниченный объем данных, а именно: поля группировки, результаты агрегатных функций и константы. 

Наиболее полезными являются поля группировки и результаты агрегатных функций, поскольку первые характеризуют каждую группу и позволяют отличить одну группу от другой, а благодаря вторым появляется возможность выполнять различные манипуляции с группами.

Результатом приведенного ниже запроса:

```sql
SELECT artist,
       SUM(streams) AS streams
FROM Songs
GROUP BY artist;
```

является:

```
+------------+---------+
| artist     | streams |
+------------+---------+
| Green Day  | 51870   |
| Heart      | 44371   |
| Blondie    | 180184  |
| The Smiths | 42700   |
| The Sounds | 208801  |
+------------+---------+
```

Запрос выше группирует записи по полю `artist` и для каждой группы определяет сумму значений поля `streams`, тем самым извлекает данные о каждом исполнителе и количестве прослушиваний всех его песен.

<hr>

[Содержание](#содержание)

## Фильтрация групп

Данные при извлечении можно не только группировать, но и фильтровать, то есть определять, какие группы должны быть включены в результат запроса, а какие — исключены. К примеру, при извлечении музыкальных исполнителей и суммарного количества прослушиваний их песен нам могут понадобиться лишь те, число прослушиваний которых превышает определенное значение.

Нам уже знаком оператор `WHERE`, однако для фильтрации групп он не подходит, так как его задачей является фильтрация записей при извлечении из таблицы. Для фильтрации групп в SQL используется оператор `HAVING`. В качестве примера использования этого оператора напишем запрос, решающий рассмотренную выше ситуацию по извлечению музыкальных исполнителей, суммарное количество прослушиваний песен которых превышает заданное число.

Результатом приведенного ниже запроса:

```sql
SELECT artist,
       SUM(streams) AS streams
FROM Songs
GROUP BY artist
HAVING SUM(streams) > 50000;
```

является:

```
+------------+---------+
| artist     | streams |
+------------+---------+
| Green Day  | 51870   |
| Blondie    | 180184  |
| The Sounds | 208801  |
+------------+---------+
```

Как и прежде, в этом запросе записи сперва группируются по полю `artist`, однако в результирующую таблицу попадают не все группы, а лишь те, сумма значений поля `streams` которых превышает 50000. Несложно понять, что оператор `WHERE` для подобной фильтрации не подходит, так как данная фильтрация основана на итоговом значении группы, а не на значениях извлеченных из таблицы записей.

Оператор `WHERE` фильтрует записи до того, как данные будут сгруппированы, а оператор `HAVING` — после того, как данные были сгруппированы.

Поскольку операторы `WHERE` и `HAVING` предназначены для разных задач, они могут быть использованы вместе. Примером их совместной работы может быть ситуация, в которой нам необходимо определить исполнителей, которые имеют как минимум две песни с определенным количеством прослушиваний.

Результатом приведенного ниже запроса:

```sql
SELECT artist,
       COUNT(*) AS num_of_songs
FROM Songs
WHERE streams > 40000
GROUP BY artist
HAVING COUNT(*) > 1;
```

является:

```
+------------+--------------+
| artist     | num_of_songs |
+------------+--------------+
| Blondie    | 2            |
| The Sounds | 3            |
+------------+--------------+
```

Выполнение данного запроса начинается с извлечения записей, значение поля `streams` которых превышает `40000`. Затем полученные записи группируются по полю `artist`. После выполняется фильтрация сформированных групп путем исключения тех, которые состоят из одной и менее записей. Завершается запрос формированием результирующей таблицы, которая включает поле `artist`, содержащее название исполнителя, и поле `num_of_songs`, содержащее количество песен исполнителя, число прослушиваний которых превышает `40000`.

Оператор `HAVING` следует использовать только вместе с оператором `GROUP BY`, а оператор `WHERE` для стандартной фильтрации на уровне записей.

<hr>

[Содержание](#содержание)

## Сортировка групп

Сгруппированные данные при извлечении могут быть не только отфильтрованы, но и отсортированы. Для сортировки групп не предусмотрен какой-либо отдельный оператор, поэтому она выполняется с помощью уже изученного ранее оператора `ORDER BY`.

В качестве примера совместного использования операторов группировки и сортировки дополним предложенный в начале урока запрос по определению количества песен, принадлежащих каждому исполнителю, сортировкой по количеству песен.

Результатом приведенного ниже запроса:

```sql
SELECT artist,
       COUNT(*) AS num_of_songs
FROM Songs
GROUP BY artist
ORDER BY COUNT(*);
```

является:

```
+------------+--------------+
| artist     | num_of_songs |
+------------+--------------+
| Heart      | 1            |
| The Smiths | 1            |
| Blondie    | 2            |
| Green Day  | 3            |
| The Sounds | 3            |
+------------+--------------+
```

Здесь, как и в предыдущих запросах, записи сперва группируются по полю `artist`, однако затем сортируются по количеству записей в полученных группах.

<hr>

[Содержание](#содержание)

## Порядок обработки и выполнения операторов

При формировании SQL-запроса всегда необходимо соблюдать порядок используемых операторов. К примеру, оператор `FROM` должен быть указан после оператора `SELECT`. В таблице ниже перечислены все изученные нами на данный момент операторы в том порядке, в котором они должны располагаться в запросе:

Оператор | Описание
-|-
`SELECT` | Данные для извлечения
`FROM` | Таблица для извлечения данных
`WHERE` | Фильтрация на уровне записей
`GROUP BY` | Создание групп
`HAVING` | Фильтрация на уровне групп
`ORDER BY` | Порядок сортировки результатов
`LIMIT` | Ограничение количества записей

При выполнении SQL-запроса операторы выполняются в определенном порядке. В таблице ниже представлен порядок их выполнения:

Оператор | Описание
-|-
`FROM` | Таблица для извлечения данных
`WHERE` | Фильтрация на уровне записей
`GROUP BY` | Создание групп
`HAVING` | Фильтрация на уровне групп
`SELECT` | Данные для извлечения
`ORDER BY` | Порядок сортировки результатов
`LIMIT` | Ограничение количества записей

<hr>

[Содержание](#содержание)

## Примечания 2

**Примечание 1.** Для оператора `GROUP BY` все значения `NULL` трактуются как равные. Таким образом, при группировке по полю, содержащему значения `NULL`, все такие записи попадут в одну группу.

**Примечание 2.** Если группировка записей выполняется по вычисляемому полю, причем этому полю присвоен псевдоним, то в операторе `GROUP BY` можно воспользоваться этим псевдонимом.

Результатом приведенного ниже запроса:

```sql
SELECT CONCAT(artist, ', ', album) AS artist_and_album,
       COUNT(*) AS num_of_songs
FROM Songs
GROUP BY artist_and_album;
```

является:

```
+--------------------------------------+--------------+
| artist_and_album                     | num_of_songs |
+--------------------------------------+--------------+
| Green Day, American Idiot            | 3            |
| Heart, Dreamboat Annie               | 1            |
| Blondie, No Exit                     | 1            |
| The Smiths, The Queen Is Dead        | 1            |
| The Sounds, Crossing the Rubicon     | 2            |
| Blondie, Pollinator                  | 1            |
| The Sounds, Dying to Say This to You | 1            |
+--------------------------------------+--------------+
```

При фильтрации и сортировке групп также можно пользоваться псевдонимами, если они были присвоены.

Результатом приведенного ниже запроса:

```sql
SELECT artist,
       COUNT(*) AS num_of_songs
FROM Songs
GROUP BY artist
HAVING num_of_songs > 1
ORDER BY num_of_songs;
```

является:

```
+------------+--------------+
| artist     | num_of_songs |
+------------+--------------+
| Blondie    | 2            |
| Green Day  | 3            |
| The Sounds | 3            |
+------------+--------------+
```

В запросе выше записи сперва группируются по полю `artist`, а затем фильтруются и сортируются по псевдониму `num_of_songs`, который содержит количество записей в группе.

Если псевдоним вычисляемого поля совпадает с именем какого-либо поля таблицы, группировка и фильтрация будет выполняться именно по значениям поля таблицы.

Результатом приведенного ниже запроса:

```sql
SELECT LEFT(artist, 1) AS artist,
       COUNT(*) AS num_of_artists
FROM Songs
GROUP BY artist
HAVING artist != 'B'
ORDER BY artist;
```
является:

```
+--------+----------------+
| artist | num_of_artists |
+--------+----------------+
| B      | 2              |
| G      | 3              |
| H      | 1              |
| T      | 1              |
| T      | 3              |
+--------+----------------+
```

**Примечание 3.** Оператор `DISTINCT` тесно связан с оператором `GROUP BY` и во многих случаях они являются взаимозаменяемыми.

Приведенный ниже запрос:

```sql
SELECT artist
FROM Songs
GROUP BY artist;
```

примерно эквивалентен следующему запросу:

```sql
SELECT DISTINCT artist
FROM Songs;
```

Такая связь также накладывает некоторые ограничения. Например, если в запросе, использующем `DISTINCT`, необходимо осуществить сортировку, то сделать это можно только по тем полям, которые указаны в операторе `SELECT`, в противном случае произойдет ошибка.

Результатом приведенного ниже запроса:

```sql
SELECT DISTINCT artist
FROM Songs
ORDER BY album;
```

является ошибка:

```
ERROR 3065: Expression #1 of ORDER BY clause is not in SELECT list, references column 'beegeek.Songs.album' which is not in SELECT list; this is incompatible with DISTINCT
```

**Примечание 4.** Оператор `HAVING` достаточно сильно похож на оператор `WHERE`, и в действительности все типы фильтраций, выполняемые оператором `WHERE` (сравнения, поиск с помощью метасимволов), также поддерживаются оператором `HAVING`. Единственная разница состоит в том, что `WHERE` фильтрует записи, a `HAVING` — группы.

<hr>

[Содержание](#содержание)

# 5.3 Решение задач

<hr>

[Содержание](#содержание)