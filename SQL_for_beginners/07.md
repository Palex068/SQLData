# 7.  Соединение таблиц

## Содержание

+ [7.1 Связи между таблицами](#71-связи-между-таблицами)
    + [Связи между таблицами](#связи-между-таблицами)
    + [Виды первичных и внешних ключей](#виды-первичных-и-внешних-ключей)
        + [Суррогатные и естественные ключи](#суррогатные-и-естественные-ключи)
        + [Рекурсивные внешние ключи](#рекурсивные-внешние-ключи)
    + [Виды связей между таблицами](#виды-связей-между-таблицами)
        + [Связь "один к одному"](#связь-один-к-одному)
        + [Связь "один ко многим"](#связь-один-ко-многим)
        + [Связь "многие ко многим"](#связь-многие-ко-многим)
+ [7.2 Внутреннее соединение](#72-внутреннее-соединение)
    + [Соединение таблиц](#соединение-таблиц)
    + [Внутреннее соединение](#внутреннее-соединение)
    + [Оператор `INNER JOIN`](#оператор-inner-join)
        + [Соединение нескольких таблиц](#соединение-нескольких-таблиц)
        + [Самосоединения](#самосоединения)
+ [7.3 Внешнее и перекрестное соединения](#73-внешнее-и-перекрестное-соединения)
    + [Внешнее соединение]()
    + [Оператор `LEFT OUTER JOIN`]()
    + [Оператор `RIGHT OUTER JOIN`]()
    + [Перекрестное соединение]()
    + [Оператор `CROSS JOIN`]()
+ [7.4 Объединение результатов запросов](#74-объединение-результатов-запросов)
+ [7.5 Решение задач. Часть 1](#75-решение-задач-часть-1)
+ [7.6 Решение задач. Часть 2](#76-решение-задач-часть-2)

[Оглавление](/SQL_for_beginners/README.MD)

# 7.1 Связи между таблицами

Урок посвящен связям между таблицами.

## Связи между таблицами

Основной идеей реляционной модели хранения данных является разбиение информации по тематическим таблицам и установление связей между этими таблицами с помощью первичных и внешних ключей. Такие связи позволяют избежать избыточности информации, а также обеспечивают структурированный способ хранения данных и их целостность.

В качестве простого примера установления связи между таблицами рассмотрим базу данных некоторого интернет-магазина, которая хранит персональные данные покупателей и информацию об их заказах.

Персональные данные покупателей располагаются в таблице Покупатели, которая имеет следующий вид:

ID | Имя и фамилия
-|-
1 | Билл Гейтс
2 | Алан Тьюринг

Информация о заказах покупателей располагается в таблице Заказы, которая имеет следующий вид:

ID | ID покупателя | Стоимость
-|-|-
1 | 2 | 1500
2 | 1 | 1000
3 | 2 | 3500

Поле `ID` в обеих таблицах является первичным ключом. В таблице `Покупатели` оно представляет собой уникальный идентификатор покупателя, в таблице `Заказы` — уникальный идентификатор заказа.

Поскольку каждый заказ принадлежит определенному покупателю, в таблице `Заказы` присутствует поле `ID покупателя`, которое и определяет владельца заказа. В качестве значений этого поля используются идентификаторы покупателей, то есть значения поля `ID` таблицы `Покупатели`. Таким образом, поле `ID` покупателя является внешним ключом, которое вместе с первичным ключом таблицы `Покупатели` — полем `ID` — устанавливает связь между таблицами `Покупатели` и `Заказы`.

С помощью данной связи можно определить всю необходимую информацию о владельце любого заказа. Например, первый и третий заказы принадлежат `Алану Тьюрингу`, а второй — `Биллу Гейтсу`.

<hr>

[Содержание](#содержание)

## Виды первичных и внешних ключей

Первичные и внешние ключи бывают нескольких видов. Первичные ключи разделяют в зависимости от того, какие именно данные используются для однозначного определения каждой записи таблицы, внешние же ключи разделяют в зависимости от того, на поле какой таблицы ссылается внешний ключ.

<hr>

[Содержание](#содержание)

### Суррогатные и естественные ключи

Первичные ключи делятся на два вида: `суррогатные` и `естественные`. **Суррогатный ключ** — это первичный ключ, созданный специально для идентификации записей таблицы, значения которого (часто числовые или символьные) не имеют прямого отношения к самим данным. Например, в рассмотренной ранее таблице Заказы поле `ID` является суррогатным ключом. Оно было специально создано для идентификации каждого заказа и не имеет прямого отношения к самому заказу.

**Естественный ключ** — это первичный ключ, значения которого непосредственно связаны с реальными данными или характеристиками хранимых сущностей. Например, в таблице, хранящей персональные данные людей, естественным ключом может выступать поле, содержащее номер паспорта человека или другого документа, скажем, водительских прав.

Первичный ключ, состоящий из одного поля, обычно называют `простым`. Если же первичный ключ включает несколько полей, его называют `составным`.

<hr>

[Содержание](#содержание)

### Рекурсивные внешние ключи

Внешние ключи могут ссылаться на первичный ключ не только другой таблицы, но и той, в которой находится сам внешний ключ. Во втором случае внешний ключ называют **рекурсивным**. Рекурсивные внешние ключи используются для установления связей между разными записями в одной и той же таблице.

В качестве примера использования рекурсивного внешнего ключа рассмотрим таблицу `Сотрудники`, которая хранит информацию о сотрудниках некоторой компании:

ID | Имя и фамилия | ID руководителя
-|-|-
1 | Билл Гейтс | NULL
2 | Алан Тьюринг | 1
3 | Исаак Ньютон | 1
4 | Эдгар Кодд | 2

Поле `ID` этой таблицы является первичным ключом — уникальным идентификатором каждого сотрудника. Поле `ID` руководителя является внешним ключом и для каждого сотрудника определяет идентификатор его руководителя, который, в свою очередь, также является сотрудником и содержится в таблице `Сотрудники`. `Следовательно`, поле `ID` руководителя является рекурсивным внешним ключом, поскольку ссылается на первичный ключ той же таблицы, в которой находится сам.

Например, рекурсивный внешний ключ `ID` руководителя позволяет определить, что у `Билла Гейтса` нет руководителя. Также с его помощью можно выяснить, что руководителем `Эдгара Кодда` является Алан Тьюринг.

<hr>

[Содержание](#содержание)

## Виды связей между таблицами

Сочетание первичных и внешних ключей позволяет установить связь между таблицами, однако эта связь не всегда имеет один и тот же вид. Выделяют три вида связей между таблицами: "**один к одному**", "**один ко многим**" и "**многие ко многим**​​​​​​​".

<hr>

[Содержание](#содержание)

## Связь "один к одному"

Связь "один к одному" предполагает, что каждая запись в одной таблице связана с одной записью в другой таблице. Это означает, что одна запись в первой таблице имеет только одну соответствующую ей запись во второй таблице, и наоборот.

В качестве примера установления этого вида связи рассмотрим базу данных, которая хранит персональные данные различных людей и их паспортные данные.

Персональные данные людей располагаются в таблице Люди, которая имеет следующий вид:

ID | Имя и фамилия | Номер паспорта
-|-|-
1 | Билл Гейтс | 548491
2 | Алан Тьюринг | 121685
3 | Эдгар Кодд | 144789

Паспортные данные людей располагаются в таблице Паспортные данные, которая имеет следующий вид:

Номер паспорта | Дата выдачи | Гражданство
-|-|-
121685 | 1940-06-23 | Великобритания
144789 | 1970-03-15 | Великобритания
548491 | 2005-08-10 | США

Номер паспорта каждого человека уникален, поэтому поле `Номер паспорта` в таблице `Паспортные данные` используется в качестве первичного ключа. В таблице `Люди` поле `Номер паспорта` выступает в качестве внешнего ключа и ссылается на первичный ключ таблицы `Паспортные данные` — поле `Номер паспорта`.

В обеих таблицах поле `Номер паспорта` содержит уникальные значения. Следовательно, какую бы запись из таблицы `Люди` мы ни взяли, в соответствие ей мы сможем поставить только одну запись из таблицы `Паспортные данные`. Справедливо и обратное: какую бы запись из таблицы `Паспортные данные` мы ни взяли, в соответствие ей мы сможем поставить только одну запись из таблицы `Люди`.

Например, первой записи из таблицы `Люди` соответствует третья запись из таблицы `Паспортные данные` и никакая другая. То же самое наоборот: третьей записи из таблицы `Паспортные данные` соответствует первая запись из таблицы `Люди` и никакая другая. Подобная связь и соответствует связи "один к одному".

На схеме данных связь "один к одному" обычно обозначается линией, с обеих концов помеченной одной черточкой. Например, для таблиц `Люди` и `Паспортные данные` схема данных будет иметь следующий вид:

![07](/SQL_for_beginners/img/07_01.svg)

<hr>

[Содержание](#содержание)

## Связь "один ко многим"

Связь "один ко многим" предполагает, что одна запись в одной таблице связана с несколькими записями в другой таблице. Это означает, что у одной записи в первой таблице может быть несколько соответствующих ей записей во второй таблице, но каждая запись во второй таблице может быть связана только с одной записью в первой таблице.

В качестве примера установления этого вида связи рассмотрим предложенную в начале урока базу данных некоторого интернет-магазина, которая хранит персональные данные покупателей и информацию об их заказах.

Персональные данные покупателей располагаются в таблице Покупатели, которая имеет следующий вид:

ID | Имя и фамилия
-|-
1 | Билл Гейтс
2 | Алан Тьюринг

Информация о заказах покупателей располагается в таблице Заказы, которая имеет следующий вид:

ID | ID покупателя | Стоимость
-|-|-
1 | 2 | 1500
2 | 1 | 1000
3 | 2 | 3500

Напомним, что в обеих таблицах поле `ID` является первичным ключом, а поле `ID покупателя` таблицы `Заказы` является внешним ключом, который ссылается на первичный ключ таблицы `Покупатели` — поле `ID`.

В интернет-магазине один покупатель может совершить как один заказ, так и несколько. Следовательно, одной записи из таблицы `Покупатели` мы также можем поставить в соответствие одну или несколько записей из таблицы `Заказы`. Например, второй записи из таблицы `Покупатели` соответствуют две записи из таблицы `Заказы`: первая и третья.

В то же время один и тот же заказ не может быть совершен несколькими покупателями. Следовательно, какую бы запись из таблицы `Заказы` мы ни взяли, в соответствие ей мы сможем поставить только одну запись из таблицы `Покупатели`. Например, третьей записи из таблицы `Заказы` соответствует только вторая запись из таблицы `Покупатели`. Подобная связь и соответствует связи "один ко многим".

На схеме данных связь "один ко многим" обычно обозначается линией, с одного конца помеченной одной черточкой, с другой — тремя черточками. Например, для таблиц `Покупатели` и `Заказы` схема данных будет иметь следующий вид:

![07](/SQL_for_beginners/img/07_02.svg)

<hr>

[Содержание](#содержание)

## Связь "многие ко многим"

Связь "многие ко многим" предполагает, что несколько записей в одной таблице могут быть связаны с несколькими записями в другой таблице. Это означает, что у одной записи в первой таблице может быть множество соответствующих записей во второй таблице, и наоборот.

В качестве примера установления этого вида связи рассмотрим базу данных некоторого вуза, которая хранит персональные данные студентов, информацию о преподаваемых в вузе предметах, а также информацию о том, какие предметы изучает каждый студент.

Персональные данные студентов располагаются в таблице `Студенты`, которая имеет следующий вид:

ID | Имя и фамилия
-|-
1 | Билл Гейтс
2 | Алан Тьюринг

Информация о преподаваемых предметах располагается в таблице `Предметы`, которая имеет следующий вид:

ID | Название
-|-
1 | Математика
2 | Физика
3 | Химия

Информация об изучаемых студентами предметах располагается в таблице Изучаемые предметы, которая имеет следующий вид:

ID студента | ID предмета
-|-
1 | 2
1 | 3
2 | 1
2 | 2

Таблица `Изучаемые предметы` состоит из двух внешних ключей, первый из которых ссылается на первичный ключ таблицы `Студенты` (поле `ID`), второй — таблицы `Предметы` (поле `ID`). Например, первая запись таблицы `Изучаемые предметы` говорит о том, что студент с идентификатором 1 изучает предмет с идентификатором 2, что соответствует тому, что `Билл Гейтс` изучает `физику`.

Каждый студент вуза может изучать несколько предметов, при этом каждый предмет также может изучаться несколькими студентами. Таким образом, выбрав группу студентов, мы можем получить группу предметов, которые они изучают. И наоборот: выбрав группу предметов, мы можем получить группу студентов, которые изучают выбранные предметы. Подобная связь и соответствует связи "многие ко многим".

Особенностью связи "многие ко многим" является то, что она не устанавливается между двумя таблицами напрямую, а требует использования вспомогательной промежуточной таблицы. В нашем случае для установления такой связи между таблицами `Студенты` и `Предметы` используется таблица `Изучаемые предметы`.

Фактически, связь "многие ко многим" осуществляется с помощью двух связей "один ко многим". В нашем примере связь "один ко многим" присутствует между таблицами `Студенты` и `Изучаемые предметы`, а также между таблицами `Предметы` и `Изучаемые предметы`. Поэтому схема данных для таблиц `Студенты`, `Предметы` и `Изучаемые предметы` будет иметь следующий вид:

![07](/SQL_for_beginners/img/07_03.svg)

<hr>

[Содержание](#содержание)

## Примечания 1

**Примечание 1.** Дополнительно ознакомиться с видами связей между таблицами и примерами их установления можно в статье по ссылке.

<hr>

[Содержание](#содержание)

# 7.2 Внутреннее соединение

Урок посвящен соединению таблиц и внутреннему соединению в частности.

## Используемая база данных
Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из четырех таблиц и содержит информацию о книгах, размещенных в некоторой электронной библиотеке. Также база данных включает информацию о пользователях библиотеки и арендованных ими книгах.

Первая таблица. Информация об авторах книг располагается в таблице `Authors`, которая имеет следующий вид:

```
+----+-----------------+
| id | author          |
+----+-----------------+
| 1  | Chuck Palahniuk |
| 2  | Stephen King    |
| 3  | John Tolkien    |
+----+-----------------+
```

Первое поле этой таблицы содержит идентификатор автора, второе — имя и фамилию.

Вторая таблица. Информация о размещенных в библиотеке книгах располагается в таблице `Books`, которая имеет следующий вид:

```
+----+-----------+-----------------------+
| id | author_id | title                 |
+----+-----------+-----------------------+
| 1  | 1         | Fight Club            |
| 2  | 2         | The Green Mile        |
| 3  | 3         | The Lord of the Rings |
| 4  | 2         | It                    |
| 5  | 1         | Haunted               |
+----+-----------+-----------------------+
```

Первое поле этой таблицы содержит идентификатор книги, второе — идентификатор автора, третье — название книги.

Третья таблица. Информация о пользователях библиотеки располагается в таблице `Users`, которая имеет следующий вид:

```
+----+---------------------+
| id | user                |
+----+---------------------+
| 1  | Keanu Reeves        |
| 2  | Matthew McConaughey |
| 3  | Thomas Hanks        |
| 4  | Bradd Pitt          |
| 5  | Liam Neeson         |
+----+---------------------+
```

Первое поле этой таблицы содержит идентификатор пользователя, второе — имя и фамилию.

Четвертая таблица. Информация об аренде книг, то есть о том, какой пользователь какую книгу взял на чтение, располагается в таблице `BooksRental`, которая имеет следующий вид:

```
+----+---------+---------+
| id | book_id | user_id |
+----+---------+---------+
| 1  | 4       | 1       |
| 2  | 1       | 3       |
| 3  | 2       | 3       |
| 4  | 4       | 4       |
| 5  | 3       | 1       |
+----+---------+---------+
```

Первое поле этой таблицы содержит идентификатор аренды, второе — идентификатор арендованной книги, третье — идентификатор пользователя, арендовавшего книгу.

Схема базы данных

![07](/SQL_for_beginners/img/07_04.svg)

Скрипт для создания таблиц `Authors`, `Books`, `Users` и `BooksRental`

```sql
DROP TABLE IF EXISTS BooksRental;
DROP TABLE IF EXISTS Users;
DROP TABLE IF EXISTS Books;
DROP TABLE IF EXISTS Authors;

-- Создание таблицы Authors
CREATE TABLE Authors
(
    id     INT PRIMARY KEY AUTO_INCREMENT,
    author VARCHAR(40)
);

INSERT INTO Authors (author)
VALUES ('Chuck Palahniuk'),
       ('Stephen King'),
       ('John Tolkien');

-- Создание таблицы Books
CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    author_id INT,
    title     VARCHAR(40)
);

INSERT INTO Books (author_id, title)
VALUES (1, 'Fight Club'),
       (2, 'The Green Mile'),
       (3, 'The Lord of the Rings'),
       (2, 'It'),
       (1, 'Haunted');

-- Создание таблицы Users
CREATE TABLE Users
(
    id   INT PRIMARY KEY AUTO_INCREMENT,
    user VARCHAR(30)
);

INSERT INTO Users (user)
VALUES ('Keanu Reeves'),
       ('Matthew McConaughey'),
       ('Thomas Hanks'),
       ('Bradd Pitt'),
       ('Liam Neeson');

-- Создание таблицы BooksRental
CREATE TABLE BooksRental
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    book_id INT,
    user_id INT
);

INSERT INTO BooksRental (book_id, user_id)
VALUES (4, 1),
       (1, 3),
       (2, 3),
       (4, 4),
       (3, 1);
```

<hr>

[Содержание](#содержание)

## Соединение таблиц

Во время работы с базой данных, включающей множество таблиц, в рамках одного запроса часто приходится обращаться к нескольким таблицам. Например, если мы решим извлечь из нашей базы данных названия всех книг и для каждой книги указать ее автора, нам придется обратиться к двум таблицам: `Books` и `Authors`.

На данный момент решить такую задачу мы можем с помощью подзапроса. Для этого нужно извлечь все записи из таблицы `Books` и на основе значения поля `author_id` каждой извлекаемой записи отыскать соответствующую ей запись в таблице `Authors`.

Результатом приведенного ниже запроса:

```sql
SELECT title,
      (SELECT author
       FROM Authors
       WHERE Authors.id = Books.author_id) AS author
FROM Books;
```

является:

```
+-----------------------+-----------------+
| title                 | author          |
+-----------------------+-----------------+
| Fight Club            | Chuck Palahniuk |
| The Green Mile        | Stephen King    |
| The Lord of the Rings | John Tolkien    |
| It                    | Stephen King    |
| Haunted               | Chuck Palahniuk |
+-----------------------+-----------------+
```

Несмотря на простую формулировку исходной задачи, решение с подзапросом выглядит достаточно сложным, поэтому в SQL для подобных целей предусмотрены не подзапросы, а соединения.

Соединение представляет собой операцию объединения двух таблиц в одну таблицу согласно определенному правилу. Таблица, получаемая в результате соединения, включает все поля соединяемых таблиц, что значительно упрощает работу с исходными данными, поскольку вся необходимая информация автоматически собирается вместе и предоставляется в виде одной таблицы.

Например, результатом соединения таблиц `Books` и `Authors` является таблица, состоящая из следующих полей:

```
+----+-----------+-------+----+--------+
| id | author_id | title | id | author |
+----+-----------+-------+----+--------+
```

Первые три поля этой таблицы принадлежат таблице `Books`, остальные два — таблице `Authors`.

Также таблица, получаемая в результате соединения, включает записи из соединяемых таблиц. То, как эти записи будут располагаться относительно друг друга, определяет условие соединения. Обычно таким условием является сравнение на равенство значений по определенным полям: рядом с записью из одной таблицы ставится такая запись из другой таблицы, что их значения по определенным полям совпадают.

Например, результатом соединения таблиц `Books` и `Authors` с условием `Books.author_id = Authors.id` является следующая таблица:

```
+----+-----------+-----------------------+----+-----------------+
| id | author_id | title                 | id | author          |
+----+-----------+-----------------------+----+-----------------+
| 1  | 1         | Fight Club            | 1  | Chuck Palahniuk |
| 2  | 2         | The Green Mile        | 2  | Stephen King    |
| 3  | 3         | The Lord of the Rings | 3  | John Tolkien    |
| 4  | 2         | It                    | 2  | Stephen King    |
| 5  | 1         | Haunted               | 1  | Chuck Palahniuk |
+----+-----------+-----------------------+----+-----------------+
```

Условие соединения в данном примере говорит о том, что рядом с записью из таблицы `Books` должна располагаться такая запись из таблицы `Authors`, значение поле `id` которой равняется значению поля `author_id` записи из таблицы `Books`. Фактически, это соответствует тому, что каждой книге должен быть сопоставлен ее автор.

<hr>

[Содержание](#содержание)

## Внутреннее соединение

То, какие записи из соединяемых таблиц попадут в результат соединения, определяется видом выполняемого соединения. Например, во время выполнения соединения может возникнуть ситуация, что для одной записи нет соответствующей записи в другой таблице. Поведение при таких ситуациях будет зависеть именно от вида соединения. В этом уроке мы рассмотрим соединение, которое называют внутренним.

При внутреннем соединении двух таблиц отбираются все пары записей, для которых выполняется условие соединения. Если записи невозможно поставить в пару запись из другой таблицы так, чтобы условие соединения выполнялось, запись будет отброшена.

В качестве примера рассмотрим внутреннее соединение таблиц `BooksRental` и `Users` с условием `BooksRental.user_id = Users.id`. Таблица, получаемая в результате данного соединения, имеет следующий вид:

```
+----+---------+---------+----+--------------+
| id | book_id | user_id | id | user         |
+----+---------+---------+----+--------------+
| 1  | 4       | 1       | 1  | Keanu Reeves |
| 2  | 1       | 3       | 3  | Thomas Hanks |
| 3  | 2       | 3       | 3  | Thomas Hanks |
| 4  | 4       | 4       | 4  | Bradd Pitt   |
| 5  | 4       | 1       | 1  | Keanu Reeves |
+----+---------+---------+----+--------------+
```

В данной таблице присутствуют все записи из таблицы `BooksRental`, поскольку для каждой из них можно подобрать соответствующую запись из таблицы `Users`. С другой стороны, в таблице отсутствуют вторая и пятая записи из таблицы `Users`, так как для них соответствующих записей в таблице `BooksRental` нет.

Говоря простыми словами, в примере выше каждой арендованной книге сопоставляется информация о том, кто ее арендовал, и, поскольку некоторые пользователи не арендовали ни одной книги, информации о них в таблице, полученной в результате соединения, нет.

<hr>

[Содержание](#содержание)

## Оператор `INNER JOIN`

В SQL внутреннее соединение выполняется с помощью оператора `INNER JOIN` и ключевого слова `ON`. Сначала указывается первая таблица, затем оператор `INNER JOIN`, а после вторая таблица. Завершается выражение ключевым словом `ON`, после которого располагается условие соединения.

Общий синтаксис внутреннего соединения имеет следующий вид:

```sql
<первая таблица> INNER JOIN <вторая таблица> ON <условие соединения>
```

В качестве примера выполним рассмотренное ранее соединение таблиц `Books` и `Authors` с условием `Books.author_id = Authors.id` и извлечем из полученной в результате соединения таблицы все данные.

Результатом приведенного ниже запроса:

```sql
SELECT *
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;
```

является:

```
+----+-----------+-----------------------+----+-----------------+
| id | author_id | title                 | id | author          |
+----+-----------+-----------------------+----+-----------------+
| 1  | 1         | Fight Club            | 1  | Chuck Palahniuk |
| 2  | 2         | The Green Mile        | 2  | Stephen King    |
| 3  | 3         | The Lord of the Rings | 3  | John Tolkien    |
| 4  | 2         | It                    | 2  | Stephen King    |
| 5  | 1         | Haunted               | 1  | Chuck Palahniuk |
+----+-----------+-----------------------+----+-----------------+
```

По сути, связка операторов `INNER JOIN` и `ON` выполняет внутреннее соединение двух таблиц и возвращает полученный результат в виде новой таблицы. Поэтому, указывая после ключевого слова `FROM` выражение, выполняющее соединение таблиц, мы подразумеваем то, что извлечение должно происходить из таблицы, что будет получена в результате соединения.

Запрос, который извлекает данные из таблицы, полученной в результате соединения, называют многотабличным.

Таблица, полученная в результате приведенного выше соединения, сопоставляет каждой книге ее автора. Поэтому если мы извлечем из нее лишь поля `title` и `author`, то получим решение задачи, что была предложена в начале урока.

Результатом приведенного ниже запроса:

```sql
SELECT title, author
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;
```

является:

```
+-----------------------+-----------------+
| title                 | author          |
+-----------------------+-----------------+
| Fight Club            | Chuck Palahniuk |
| The Green Mile        | Stephen King    |
| The Lord of the Rings | John Tolkien    |
| It                    | Stephen King    |
| Haunted               | Chuck Palahniuk |
+-----------------------+-----------------+
```

Таблица, получаемая во время соединения таблиц, нередко может включать поля, имеющие одинаковые имена. К примеру, в таблицах `Books` и `Authors` такими полями являются поля с именем `id`. Обращаться к таким полям можно, но только по их полным именам.

Результатом приведенного ниже запроса:

```sql
SELECT Books.id, Authors.id
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;
```

является:

```
+----+----+
| id | id |
+----+----+
| 1  | 1  |
| 2  | 2  |
| 3  | 3  |
| 4  | 2  |
| 5  | 1  |
+----+----+
```

Поскольку таблица, получаемая в результате соединения, это все еще обычная таблица, с ней допустимо выполнять все изученные нами операции: сортировку, фильтрацию и группировку. Например, с помощью фильтрации мы можем получить названия книг лишь определенного автора.

Результатом приведенного ниже запроса:

```sql
SELECT title
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id
WHERE author = 'Chuck Palahniuk';
```

является:

```
+------------+
| title      |
+------------+
| Fight Club |
| Haunted    |
+------------+
```

В качестве дополнительного примера выполним соединение таблиц `BooksRental` и `Books` с условием `BooksRental.book_id = Books.id`.

Результатом приведенного ниже запроса:

```sql
SELECT *
FROM BooksRental INNER JOIN Books ON BooksRental.book_id = Books.id;
```

является:

```
+----+---------+---------+----+-----------+-----------------------+
| id | book_id | user_id | id | author_id | title                 |
+----+---------+---------+----+-----------+-----------------------+
| 1  | 4       | 1       | 4  | 2         | It                    |
| 2  | 1       | 3       | 1  | 1         | Fight Club            |
| 3  | 2       | 3       | 2  | 2         | The Green Mile        |
| 4  | 4       | 4       | 4  | 2         | It                    |
| 5  | 3       | 1       | 3  | 3         | The Lord of the Rings |
+----+---------+---------+----+-----------+-----------------------+
```

В таблице, полученной в результате данного соединения, каждой арендованной книге сопоставляется ее название. И вновь следует обратить внимание на то, как именно выполняется внутреннее соединение: из таблиц `BooksRental` и `Books` берутся лишь те пары записей, для которых выполняется условие соединения. Например, пятая запись из таблицы `Books` не берется, так как для нее нельзя подобрать запись из таблицы `BooksRental` так, чтобы условие соединения выполнялось.

Используя таблицу, полученную в результате приведенного выше соединения, можно получить названия книг, которые были арендованы хотя бы раз. Для этого достаточно извлечь все уникальные значения поля `title`.

Результатом приведенного ниже запроса:

```sql
SELECT DISTINCT title
FROM BooksRental INNER JOIN Books ON BooksRental.book_id = Books.id;
```

является:

```
+-----------------------+
| title                 |
+-----------------------+
| It                    |
| Fight Club            |
| The Green Mile        |
| The Lord of the Rings |
+-----------------------+
```

<hr>

[Содержание](#содержание)

### Соединение нескольких таблиц

Таблица, полученная в результате соединения, сама может быть соединена с другой таблицей, благодаря чему мы можем выполнять соединение не только двух таблиц, но и большего их количества.

В качестве примера выполним соединение трех таблиц: `BooksRental`, `Books` и `Users`.

Результатом приведенного ниже запроса:

```sql
SELECT *
FROM BooksRental INNER JOIN Books ON BooksRental.book_id = Books.id
                 INNER JOIN Users ON BooksRental.user_id = Users.id;
```                 

является:

```
+----+---------+---------+----+-----------+-----------------------+----+--------------+
| id | book_id | user_id | id | author_id | title                 | id | user         |
+----+---------+---------+----+-----------+-----------------------+----+--------------+
| 1  | 4       | 1       | 4  | 2         | It                    | 1  | Keanu Reeves |
| 2  | 1       | 3       | 1  | 1         | Fight Club            | 3  | Thomas Hanks |
| 3  | 2       | 3       | 2  | 2         | The Green Mile        | 3  | Thomas Hanks |
| 4  | 4       | 4       | 4  | 2         | It                    | 4  | Bradd Pitt   |
| 5  | 3       | 1       | 3  | 3         | The Lord of the Rings | 1  | Keanu Reeves |
+----+---------+---------+----+-----------+-----------------------+----+--------------+
```

В данном примере выполняется поочередное соединение таблиц `BooksRental`, `Books` и `Users`:
+ сначала соединяются таблицы `BooksRental` и `Books`,
+ затем полученный результат соединяется с таблицей `Users`. 

Обратите внимание, что в условии соединения с таблицей `Users` обращение к полю `user_id` происходит по имени первой таблицы — `BooksRental`. Несмотря на то что таблица Users соединяется с результатом соединения таблиц `BooksRental` и `Books`, а не с таблицей `BooksRental`, такое обращение корректно.

Используя таблицу, полученную в результате приведенного выше соединения, можно получить информацию о том, какие книги были арендованы каждым пользователем. Для этого достаточно извлечь все значения полей user и `title`.

```sql
SELECT user, title
FROM BooksRental INNER JOIN Books ON BooksRental.book_id = Books.id
                 INNER JOIN Users ON BooksRental.user_id = Users.id
ORDER BY user;
```

является:

```
+--------------+-----------------------+
| user         | title                 |
+--------------+-----------------------+
| Bradd Pitt   | It                    |
| Keanu Reeves | It                    |
| Keanu Reeves | The Lord of the Rings |
| Thomas Hanks | Fight Club            |
| Thomas Hanks | The Green Mile        |
+--------------+-----------------------+ 
```

<hr>

[Содержание](#содержание)

## Самосоединения

Соединять одну таблицу можно не только с другой таблицей, но и с самой собой. Подобное может быть удобно во время работы с таблицей, содержащей рекурсивный внешний ключ.

Предположим, мы имеем таблицу `Staff`, которая хранит информацию о сотрудниках некоторой компании:

```
+----+----------------+------------+
| id | staffer        | manager_id |
+----+----------------+------------+
| 1  | Bill Gates     | NULL       |
| 2  | Alan Turing    | 1          |
| 3  | Isaac Newton   | 1          |
| 4  | Edgar Codd     | 2          |
+----+----------------+------------+
```

Первое поле этой таблицы содержит идентификатор сотрудника, второе — имя и фамилию, третье — идентификатор руководителя (также является сотрудником). Если у сотрудника нет руководителя, значением поля `manager_id` является `NULL`.

Закономерной задачей при работе с таблицей `Staff` возникает определение руководителя каждого сотрудника. Решить такую задачу можно, соединив таблицу с самой собой и сопоставив каждой записи из первой таблицы такую запись из второй таблицы, значение поля `id` которой равняется значению поля `manager_id` записи из первой таблицы. Условием соединения в таком случае будет `Staff.id = Staff.manager_id`. Несложно понять, что в таком случае мы сталкиваемся с проблемой именования таблиц, поскольку по условию неясно, какие таблицы имеются в виду (разные или одна и та же), поэтому для однозначного определения таблиц каждой таблице необходимо дополнительно дать псевдоним.

Результатом приведенного ниже запроса:

```sql
SELECT S1.staffer,
       S2.staffer AS manager
FROM Staff AS S1 INNER JOIN Staff AS S2 ON S1.manager_id = S2.id;
```

является:

```
+----------------+-------------+
| staffer        | manager     |
+----------------+-------------+
| Alan Turing    | Bill Gates  |
| Isaac Newton   | Bill Gates  |
| Edgar Codd     | Alan Turing |
+----------------+-------------+
```

<hr>

[Содержание](#содержание)

## Примечания 2

**Примечание 1.** Соединение не является физической таблицей, то есть оно не существует как реальная таблица в базе данных. Соединение создается СУБД по мере необходимости и сохраняется только на время выполнения запроса.

**Примечание 2.** Условие соединения таблиц является обыкновенным условием, поэтому может иметь произвольную сложность. Например, оно может быть составлено с использованием ключевых слов `AND` и `OR`, а также операторов сравнения, отличных от `=`.

**Примечание 3.** При выполнении внутреннего соединения порядок таблиц не имеет значения. Если мы соединим первую таблицу со второй или вторую с первой, результат будет равнозначным.

Результатом приведенного ниже запроса:

```sql
SELECT title, author
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;
```

как и результатом приведенного ниже запроса:

```sql
SELECT title, author
FROM Authors INNER JOIN Books ON Books.author_id = Authors.id;
```

является:

```
+-----------------------+-----------------+
| title                 | author          |
+-----------------------+-----------------+
| Fight Club            | Chuck Palahniuk |
| The Green Mile        | Stephen King    |
| The Lord of the Rings | John Tolkien    |
| It                    | Stephen King    |
| Haunted               | Chuck Palahniuk |
+-----------------------+-----------------+
```

Единственная разница заключается, разве что, в порядке полей в таблице, получаемой в результате соединения: сначала следуют все поля первой таблицы, затем — второй.

**Примечание 4.** При использовании оператора `INNER JOIN` ключевое слово `INNER` (в переводе на русский "внутренний") является опциональным и может быть опущено.

Например, приведенные ниже запросы функционально полностью идентичны:

```sql
SELECT *
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;
SELECT *
FROM Books JOIN Authors ON Books.author_id = Authors.id;
```

**Примечание 5.** SQL поддерживает дополнительный синтаксис для внутреннего соединения, который имеет следующий вид:

```sql
<первая таблица>, <вторая таблица> WHERE <условие соединения>
```

Например, приведенные ниже запросы функционально полностью идентичны:

```sql
SELECT *
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;
SELECT *
FROM Books, Authors WHERE Books.author_id = Authors.id;
```

Внутреннее соединение, выполняемое с помощью данного дополнительного синтаксиса, называют неявным соединением. В нынешнее время неявные соединения считаются устаревшими и не рекомендуются для использования, однако они до сих пор могут встречаться в профильной литературе.

<hr>

[Содержание](#содержание)

# 7.3 Внешнее и перекрестное соединения

Урок посвящен внешнему и перекрестному соединению таблиц.

##  Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из двух таблиц и содержит информацию о книгах, размещенных в некоторой электронной библиотеке.

Первая таблица. Информация об авторах книг располагается в таблице `Authors`, которая имеет следующий вид:

```
+----+-----------------+
| id | author          |
+----+-----------------+
| 1  | Leo Tolstoy     |
| 2  | Chuck Palahniuk |
| 3  | Stephen King    |
| 4  | John Tolkien    |
| 5  | Joanne Rowling  |
+----+-----------------+
```

Первое поле этой таблицы содержит идентификатор автора, второе — имя и фамилию.

Вторая таблица. Информация о размещенных в библиотеке книгах располагается в таблице `Books`, которая имеет следующий вид:

```
+----+-----------+-----------------------+
| id | author_id | title                 |
+----+-----------+-----------------------+
| 1  | NULL      | Old Gods of Asgard    |
| 2  | 1         | Fight Club            |
| 3  | 2         | The Green Mile        |
| 4  | 3         | The Lord of the Rings |
| 5  | 2         | It                    |
| 6  | 1         | Haunted               |
| 7  | 2         | The Shining           |
| 8  | NULL      | Friendly Neighborhood |
| 9  | 2         | Pet Sematary          |
| 10 | NULL      | Homesick              |
+----+-----------+-----------------------+
```

Первое поле этой таблицы содержит идентификатор книги, второе — идентификатор автора, третье — название книги. Если автор книги неизвестен, значением поля `author_id` является `NULL`.

Схема базы данных

![07](/SQL_for_beginners/img/07_05.svg)

Скрипт для создания таблиц `Authors` и `Books`

```sql
-- Создание таблицы Authors
DROP TABLE IF EXISTS Authors;
CREATE TABLE Authors
(
    id     INT PRIMARY KEY AUTO_INCREMENT,
    author VARCHAR(50)
);

INSERT INTO Authors (author)
VALUES ('Leo Tolstoy'),
       ('Chuck Palahniuk'),
       ('Stephen King'),
       ('John Tolkien'),
       ('Joanne Rowling');

-- Создание таблицы Books
DROP TABLE IF EXISTS Books;
CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    author_id INT,
    title     VARCHAR(50)
);

INSERT INTO Books (author_id, title)
VALUES (NULL, 'Old Gods of Asgard'),
       (1, 'Fight Club'),
       (2, 'The Green Mile'),
       (3, 'The Lord of the Rings'),
       (2, 'It'),
       (1, 'Haunted'),
       (2, 'The Shining'),
       (NULL, 'Friendly Neighborhood'),
       (2, 'Pet Sematary'),
       (NULL, 'Homesick');
```

<hr>

[Содержание](#содержание)

## Внешнее соединение

При внутреннем соединении двух таблиц отбираются только те пары записей, для которых выполняется условие соединения. Данное поведение безусловно удобно, однако не всегда нужно, поскольку нередки ситуации, когда записи, для которых невозможно подобрать пару, также должны быть отобраны.

Например, в таблице `Books` содержится информация о книгах и их авторах, но у части книг автор считается неизвестным. Если мы выполним внутреннее соединение таблиц `Books` и `Authors` с целью извлечь названия всех книг с указанием авторства каждой, то потеряем те книги, авторство которых неизвестно.

Результатом приведенного ниже запроса:

```sql
SELECT title, author
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;
```

является: 

```
+-----------------------+-----------------+
| title                 | author          |
+-----------------------+-----------------+
| Fight Club            | Leo Tolstoy     |
| The Green Mile        | Chuck Palahniuk |
| The Lord of the Rings | Stephen King    |
| It                    | Chuck Palahniuk |
| Haunted               | Leo Tolstoy     |
| The Shining           | Chuck Palahniuk |
| Pet Sematary          | Chuck Palahniuk |
+-----------------------+-----------------+
```

Как видно из результата, книги `Old Gods of Asgard`, `Friendly Neighborhood` и `Homesick` не были учтены. Для того чтобы результат соединения включал информацию обо всех книгах, независимо от того, известен ли автор, необходимо воспользоваться другим видом соединения — внешним.

Внешнее соединение бывает двух видов:
+ левое и
+ правое. 

При левом внешнем соединении двух таблиц отбираются все пары записей, для которых выполняется условие соединения, а также все оставшиеся записи из левой таблицы, для которых пара не нашлась.

Например, результатом левого внешнего соединения таблиц `Books` и `Authors` с условием `Books.author_id = Authors.id` является следующая таблица:

```
+----+-----------+-----------------------+------+-----------------+
| id | author_id | title                 | id   | author          |
+----+-----------+-----------------------+------+-----------------+
| 1  | NULL      | Old Gods of Asgard    | NULL | NULL            |
| 2  | 1         | Fight Club            | 1    | Leo Tolstoy     |
| 3  | 2         | The Green Mile        | 2    | Chuck Palahniuk |
| 4  | 3         | The Lord of the Rings | 3    | Stephen King    |
| 5  | 2         | It                    | 2    | Chuck Palahniuk |
| 6  | 1         | Haunted               | 1    | Leo Tolstoy     |
| 7  | 2         | The Shining           | 2    | Chuck Palahniuk |
| 8  | NULL      | Friendly Neighborhood | NULL | NULL            |
| 9  | 2         | Pet Sematary          | 2    | Chuck Palahniuk |
| 10 | NULL      | Homesick              | NULL | NULL            |
+----+-----------+-----------------------+------+-----------------+
```

Данная таблица включает все пары записей из таблиц `Books` и `Authors`, для которых выполняется условие соединения, а также все оставшиеся записи из таблицы `Books`, для которых нет соответствующей записи в таблице `Authors`.

При внешнем соединении записям без пары в соответствие ставятся значения `NULL`.

При правом внешнем соединении двух таблиц отбираются все пары записей, для которых выполняется условие соединения, а также все оставшиеся записи из правой таблицы, для которых пара не нашлась.

Например, результатом правого внешнего соединения таблиц `Books` и `Authors` с условием `Books.author_id = Authors.id` является следующая таблица:

```
+------+-----------+-----------------------+----+-----------------+
| id   | author_id | title                 | id | author          |
+------+-----------+-----------------------+----+-----------------+
| 6    | 1         | Haunted               | 1  | Leo Tolstoy     |
| 2    | 1         | Fight Club            | 1  | Leo Tolstoy     |
| 9    | 2         | Pet Sematary          | 2  | Chuck Palahniuk |
| 7    | 2         | The Shining           | 2  | Chuck Palahniuk |
| 5    | 2         | It                    | 2  | Chuck Palahniuk |
| 3    | 2         | The Green Mile        | 2  | Chuck Palahniuk |
| 4    | 3         | The Lord of the Rings | 3  | Stephen King    |
| NULL | NULL      | NULL                  | 4  | John Tolkien    |
| NULL | NULL      | NULL                  | 5  | Joanne Rowling  |
+------+-----------+-----------------------+----+-----------------+
```

Данная таблица включает все пары записей из таблиц `Books` и `Authors`, для которых выполняется условие соединения, а также все оставшиеся записи из таблицы `Authors`, для которых нет соответствующей записи в таблице `Books`.

Внешнее соединение отличается от внутреннего лишь тем, что дополнительно отбирает оставшиеся без пары записи из левой или правой таблицы, ставя им в соответствие значения `NULL`.

<hr>

[Содержание](#содержание)

## Оператор `LEFT OUTER JOIN`

В SQL левое внешнее соединение выполняется с помощью оператора `LEFT OUTER JOIN` и ключевого слова ON. Сначала указывается первая таблица, затем оператор `LEFT OUTER JOIN`, а после вторая таблица. Завершается выражение ключевым словом ON, после которого располагается условие соединения.

Общий синтаксис левого внешнего соединения имеет следующий вид:

```sql
<первая таблица> LEFT OUTER JOIN <вторая таблица> ON <условие соединения>
```

В качестве примера выполним левое внешнее соединение таблиц `Books` и `Authors` с условием `Books.author_id = Authors.id`.

Результатом приведенного ниже запроса:

```sql
SELECT *
FROM Books LEFT OUTER JOIN Authors ON Books.author_id = Authors.id;
```

является:

```
+----+-----------+-----------------------+------+-----------------+
| id | author_id | title                 | id   | author          |
+----+-----------+-----------------------+------+-----------------+
| 1  | NULL      | Old Gods of Asgard    | NULL | NULL            |
| 2  | 1         | Fight Club            | 1    | Leo Tolstoy     |
| 3  | 2         | The Green Mile        | 2    | Chuck Palahniuk |
| 4  | 3         | The Lord of the Rings | 3    | Stephen King    |
| 5  | 2         | It                    | 2    | Chuck Palahniuk |
| 6  | 1         | Haunted               | 1    | Leo Tolstoy     |
| 7  | 2         | The Shining           | 2    | Chuck Palahniuk |
| 8  | NULL      | Friendly Neighborhood | NULL | NULL            |
| 9  | 2         | Pet Sematary          | 2    | Chuck Palahniuk |
| 10 | NULL      | Homesick              | NULL | NULL            |
+----+-----------+-----------------------+------+-----------------+
```

Таблица, полученная в результате данного соединения, сопоставляет каждой книге ее автора, причем, если автор книги неизвестен, значением поля `author` является `NULL`. Используя эту таблицу, мы можем извлечь названия всех книг с указанием авторства каждой. Если авторство неизвестно, укажем строку `Unknown`.

Результатом приведенного ниже запроса:

```sql
SELECT title,
       IFNULL(author, 'Unknown') AS author
FROM Books LEFT OUTER JOIN Authors ON Books.author_id = Authors.id;
```

является:

```
+-----------------------+-----------------+
| title                 | author          |
+-----------------------+-----------------+
| Old Gods of Asgard    | Unknown         |
| Fight Club            | Leo Tolstoy     |
| The Green Mile        | Chuck Palahniuk |
| The Lord of the Rings | Stephen King    |
| It                    | Chuck Palahniuk |
| Haunted               | Leo Tolstoy     |
| The Shining           | Chuck Palahniuk |
| Friendly Neighborhood | Unknown         |
| Pet Sematary          | Chuck Palahniuk |
| Homesick              | Unknown         |
+-----------------------+-----------------+
```

<hr>

[Содержание](#содержание)

## Оператор `RIGHT OUTER JOIN`

В SQL правое внешнее соединение выполняется с помощью оператора `RIGHT OUTER JOIN` и ключевого слова ON. Сначала указывается первая таблица, затем оператор `RIGHT OUTER JOIN`, а после вторая таблица. Завершается выражение ключевым словом ON, после которого располагается условие соединения.

Общий синтаксис правого внешнего соединения имеет следующий вид:

```sql
<первая таблица> RIGHT OUTER JOIN <вторая таблица> ON <условие соединения>
```

В качестве примера выполним правое внешнее соединение таблиц `Books` и `Authors` с условием `Books.author_id = Authors.id`.

Результатом приведенного ниже запроса:

```sql
SELECT *
FROM Books RIGHT OUTER JOIN Authors ON Books.author_id = Authors.id;
```

является:

```
+------+-----------+-----------------------+----+-----------------+
| id   | author_id | title                 | id | author          |
+------+-----------+-----------------------+----+-----------------+
| 6    | 1         | Haunted               | 1  | Leo Tolstoy     |
| 2    | 1         | Fight Club            | 1  | Leo Tolstoy     |
| 9    | 2         | Pet Sematary          | 2  | Chuck Palahniuk |
| 7    | 2         | The Shining           | 2  | Chuck Palahniuk |
| 5    | 2         | It                    | 2  | Chuck Palahniuk |
| 3    | 2         | The Green Mile        | 2  | Chuck Palahniuk |
| 4    | 3         | The Lord of the Rings | 3  | Stephen King    |
| NULL | NULL      | NULL                  | 4  | John Tolkien    |
| NULL | NULL      | NULL                  | 5  | Joanne Rowling  |
+------+-----------+-----------------------+----+-----------------+
```

Используя таблицу, полученную в результате приведенного выше соединения, мы можем определить, сколько книг принадлежит каждому автору. Для этого достаточно сгруппировать записи по авторам и посчитать количество существующих книг у каждого из них.

Результатом приведенного ниже запроса:

```sql
SELECT author,
       COUNT(Books.id) AS books
FROM Books RIGHT OUTER JOIN Authors ON Books.author_id = Authors.id
GROUP BY author;
```

является:

```
+-----------------+-------+
| author          | books |
+-----------------+-------+
| Leo Tolstoy     | 2     |
| Chuck Palahniuk | 4     |
| Stephen King    | 1     |
| John Tolkien    | 0     |
| Joanne Rowling  | 0     |
+-----------------+-------+
```

<hr>

[Содержание](#содержание)

## Примечания

**Примечание 1.** Левое и правое внешние соединения являются взаимозаменяемыми. Например, левое внешнее соединение таблиц `Books` и `Authors` равнозначно правому внешнему соединению таблиц `Authors` и `Books`.

**Примечание 2.** При использовании оператора `LEFT OUTER JOIN` ключевое слово `OUTER` (в переводе на русский "внешний") является опциональным и может быть опущено.

Например, приведенные ниже запросы функционально полностью идентичны:

```sql
SELECT *
FROM Books LEFT OUTER JOIN Authors ON Books.author_id = Authors.id;
SELECT *
FROM Books LEFT JOIN Authors ON Books.author_id = Authors.id;
```

Аналогичное справедливо и для оператора `RIGHT OUTER JOIN`.

**Примечание 3.** Виды соединений допустимо комбинировать. Например, при соединении трех таблиц, между первыми двумя таблицами можно выполнить внутреннее соединение, между полученным результатом и третьей таблицей — внешнее.

**Примечание 4.** Если при использовании соединений необходимо извлечь значения всех полей одной из соединяемых таблиц, можно использовать символ `*`, указав его после имени этой таблицы.

Результатом приведенного ниже запроса:

```sql
SELECT Books.*, author
FROM Books
LEFT JOIN Authors ON author_id = Authors.id
```

является:

```
+----+-----------+-----------------------+-----------------+
| id | author_id | title                 | author          |
+----+-----------+-----------------------+-----------------+
| 1  | NULL      | Old Gods of Asgard    | NULL            |
| 2  | 1         | Fight Club            | Leo Tolstoy     |
| 3  | 2         | The Green Mile        | Chuck Palahniuk |
| 4  | 3         | The Lord of the Rings | Stephen King    |
| 5  | 2         | It                    | Chuck Palahniuk |
| 6  | 1         | Haunted               | Leo Tolstoy     |
| 7  | 2         | The Shining           | Chuck Palahniuk |
| 8  | NULL      | Friendly Neighborhood | NULL            |
| 9  | 2         | Pet Sematary          | Chuck Palahniuk |
| 10 | NULL      | Homesick              | NULL            |
+----+-----------+-----------------------+-----------------+
```

**Примечание 5.** Ранее при изучении группировки мы говорили о том, что нельзя извлечь поле, не участвующее в группировке.

Результатом приведенного ниже запроса:

```sql
SELECT title, author
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id
GROUP BY title;
```

является ошибка:

```
ERROR 1055: Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'beegeek.Authors.author' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
```

Однако если группировка осуществляется по первичному или внешнему ключу, то мы можем извлечь значения полей, которые связаны с этим ключом. Это может быть удобно, например, в случае, когда необходимо извлечь несколько полей, исключив необходимость перечислять их дважды — в выборке и группировке.

Результатом приведенного ниже запроса:

```sql
SELECT Authors.id, author, COUNT(author) AS count_of_books
FROM Books
INNER JOIN Authors ON Books.author_id = Authors.id
GROUP BY Books.author_id;
```

является:

```
+----+-----------------+----------------+
| id | author          | count_of_books |
+----+-----------------+----------------+
| 1  | Leo Tolstoy     | 2              |
| 2  | Chuck Palahniuk | 4              |
| 3  | Stephen King    | 1              |
+----+-----------------+----------------+
```

<hr>

[Содержание](#содержание)

# 7.4 Объединение результатов запросов

<hr>

[Содержание](#содержание)

# 7.5 Решение задач. Часть 1

<hr>

[Содержание](#содержание)

# 7.6 Решение задач. Часть 2


<hr>

[Содержание](#содержание)