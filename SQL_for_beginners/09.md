# 9. Создание таблиц и работа с ними

## Содержание

+ [9.1 Создание таблиц. Часть 1](#91-создание-таблиц-часть-1)
    + [Создание таблиц](#создание-таблиц)
    + [Табличные ограничения](#табличные-ограничения)
        + [Непустые значения](#непустые-значения)
        + [Уникальные значения](#уникальные-значения)
        + [Значение по умолчанию](#значение-по-умолчанию)
        + [Дополнительные проверки](#дополнительные-проверки)
        + [Комбинирование ограничений](#комбинирование-ограничений)
+ [9.2 Создание таблиц. Часть 2](#92-создание-таблиц-часть-2)
    + [Табличные ограничения](#табличные-ограничения-2)
    + [Первичный ключ](#первичный-ключ)
        + [Составной первичный ключ](#составной-первичный-ключ)
        + [Автоматическое заполнение](#автоматическое-заполнение)
    + [Внешний ключ](#внешний-ключ)
        + [Поведение при обновлении и удалении](#поведение-при-обновлении-и-удалении)
+ [9.3 Удаление, переименование и обновление таблиц](#93-удаление-переименование-и-обновление-таблиц)
    + [Удаление таблицы](#удаление-таблицы)
    + [Переименование таблицы](#переименование-таблицы)
    + [Обновление таблицы](#обновление-таблицы)
        + [Удаление поля](#удаление-поля)
        + [Переименование поля](#переименование-поля)
        + [Добавление поля](#добавление-поля)
        + [Обновление поля](#обновление-поля)
        + [Добавление и удаление первичного ключа](#добавление-и-удаление-первичного-ключа)
        + [Добавление и удаление внешнего ключа](#добавление-и-удаление-внешнего-ключа)
        + [Добавление и удаление дополнительной проверки](#добавление-и-удаление-дополнительной-проверки)
+ [9.4 Триггеры](#94-триггеры)
    + [Триггеры](#триггеры)
    + [Создание триггеров](#создание-триггеров)
        + [Доступ к значениям записи](#доступ-к-значениям-записи)
    + [Примеры использования триггеров](#примеры-использования-триггеров)
    + [Удаление триггеров](#удаление-триггеров)
+ [9.5 Представления](#95-представления)
    + [Представления](#представления)
    + [Создание представлений](#создание-представлений)
        + [Представления для упрощения запросов](#представления-для-упрощения-запросов)
        + [Представления для форматирования данных](#представления-для-форматирования-данных)
    + [Удаление представлений](#удаление-представлений)
    + [Изменение представлений](#изменение-представлений)
+ [9.6 Обобщенные табличные выражения. Часть 1](#96-обобщенные-табличные-выражения-часть-1)
    + [Представления и CTE](#представления-и-cte)
+ [9.7 Обобщенные табличные выражения. Часть 2](#97-обобщенные-табличные-выражения-часть-2)
    + [Рекурсивные CTE](#рекурсивные-cte)
    + [Примеры использования рекурсивных CTE](#примеры-использования-рекурсивных-cte)
+ [9.8 Обобщенные табличные выражения. Часть 3](#98-обобщенные-табличные-выражения-часть-3)
    + [Обработка иерархических данных](#обработка-иерархических-данных)

[Оглавление](/SQL_for_beginners/README.MD)

# 9.1 Создание таблиц. Часть 1

Урок посвящен основным правилам создания таблиц.

## Создание таблиц

SQL применяется не только для работы с табличными данными, но и для выполнения всех операций с базой данных, включая создание и модификацию таблиц. Большинство СУБД содержат инструменты администрирования, которые можно применять для интерактивного создания таблиц и управления ими. Однако с таблицами также можно работать посредством запросов. Например, для создания таблиц предназначен оператор `CREATE TABLE`, который мы и рассмотрим в этом уроке.

Интерактивный инструментарий, предоставляемый СУБД для работы с таблицами, в действительности реализуется с помощью обычных запросов, которые СУБД сама создает и выполняет незаметно для программиста.

Перед созданием таблицы всегда необходимо заранее определиться с ее именем, именами полей, а также типом данных каждого поля. В качестве примера создадим таблицу `Books`, предназначенную для хранения информации о различных книгах. Она будет включать три следующих поля:
+ `id` — целочисленное поле, содержащее идентификатор книги
+ `title` — строковое поле, содержащее название книги
+ `author` — строковое поле, содержащее данные об авторе книги

Теперь рассмотрим запрос, который создает предложенную таблицу. Он выглядит следующим образом:

```sql
CREATE TABLE Books
(
    id     INT,
    title  VARCHAR(40),
    author VARCHAR(40)
);
```

Как видно из запроса выше, имя таблицы указывается сразу же после оператора `CREATE TABLE`. Далее следует определение таблицы, которое заключается в круглые скобки и содержит определение каждого поля. Определения полей разделяются запятыми. Определение каждого поля начинается с имени поля, а за ним указывается тип данных.

Таблицы и поля всегда следует называть осмысленно и прозрачно. Подробнее с правилами именования можно ознакомиться в руководстве по ссылке.

Во время создания очередной таблицы может оказаться так, что в базе данных содержится таблица, имя которой совпадает с именем создаваемой таблицы. Результатом такой операции будет ошибка.

Результатом приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

CREATE TABLE Books
(
    id     INT,
    title  VARCHAR(40),
    author VARCHAR(40),
    price  INT
);
```

является ошибка:

```
ERROR 1050: Table 'Books' already exists
```

В данном запросе сначала успешно создается таблица `Books`, однако затем выполняется попытка создания таблицы вновь с именем `Books`, что приводит к ошибке, поскольку в базе данных уже имеется таблица с таким именем.

Чтобы перед созданием таблицы выполнить проверку того, что в базе данных нет таблицы с таким же именем, нужно после оператора `CREATE TABLE` указать сочетание ключевых слов `IF NOT EXISTS`. При их использовании создание таблицы произойдет только в том случае, если ее имя в рамках базы данных уникально.

В результате приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

CREATE TABLE IF NOT EXISTS Books
(
    id     INT,
    title  VARCHAR(40),
    author VARCHAR(40),
    price  INT
);
```

будет успешно выполнена первая операция создания таблицы `Books`, в то время как вторая операция создания таблицы с тем же именем будет проигнорирована.

<hr>

[Содержание](#содержание)

## Табличные ограничения

Для обеспечения целостности хранимых в таблице данных используются **ограничения**. Ограничение представляет собой ключевое слово (или связку ключевых слов), которое указывается в определении поля и добавляет этому полю дополнительные свойства.

<hr>

[Содержание](#содержание)

### Непустые значения

Ограничение `NOT NULL` используется для того, чтобы запретить полю хранить значение `NULL`. Если поле имеет ограничение `NOT NULL`, это значит, что при добавлении новой записи или обновлении существующей записи значение этого поля не должно быть равным `NULL`.

В качестве примера расширим определение предложенной в начале урока таблицы Books и применим ограничение `NOT NULL` к ее полю `id`. Тогда запрос, создающий таблицу, будет выглядеть следующим образом:

```sql
​CREATE TABLE Books
(
    id     INT NOT NULL,
    title  VARCHAR(40),
    author VARCHAR(40)
);
```

Теперь при попытке добавить в таблицу `Books` запись, значение поля `id` которой равняется `NULL`, произойдет ошибка.

Результатом приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT NOT NULL,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (id, title, author)
VALUES (NULL, 'Fight Club', 'Chuck Palahniuk');
```

является ошибка:

```
ERROR 1048: Column 'id' cannot be null
```

Аналогичное поведение будет наблюдаться при попытке изменить значение поля `id` уже имеющейся записи на `NULL`.

Результатом приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT NOT NULL,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (id, title, author)
VALUES (1, 'Fight Club', 'Chuck Palahniuk');

UPDATE Books
SET id = NULL;
```

является ошибка:

```
ERROR 1048: Column 'id' cannot be null
```

В данном примере в таблицу успешно добавляется запись, однако операция обновления этой записи приводит к ошибке, поскольку происходит попытка изменить значение ее поля `id` с допустимого (`1`) на недопустимое (`NULL`).

Если ограничение `NOT NULL` не применяется к полю, то оно может хранить значение `NULL`, то есть хранение `NULL` — поведение по умолчанию.

<hr>

[Содержание](#содержание)

### Уникальные значения

Ограничение `UNIQUE` используется для того, чтобы запретить полю хранить повторяющиеся значения. Если поле имеет ограничение `UNIQUE`, это значит, что при добавлении новой записи или обновлении существующей записи значение этого поля должно быть уникальным.

В качестве примера расширим определение предложенной в начале урока таблицы Books и применим ограничение `UNIQUE` к ее полю `id`. Тогда запрос, создающий таблицу, будет выглядеть следующим образом:

```sql
CREATE TABLE Books
(
    id     INT UNIQUE,
    title  VARCHAR(40),
    author VARCHAR(40)
);
```

Теперь при попытке добавить в таблицу `Books` запись, значение поля `id` которой не является уникальным в рамках этого поля, произойдет ошибка.

Результатом приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT UNIQUE,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (id, title, author)
VALUES (1, 'Fight Club', 'Chuck Palahniuk'),
       (1, 'The Green Mile', 'Stephen King');
```

является ошибка:

```
ERROR 1062: Duplicate entry '1' for key 'Books.id'
```

В данном примере в таблицу успешно добавляется первая запись, однако при попытке добавить вторую запись происходит ошибка, поскольку значение ее поля `id` совпадает со значением поля `id` уже имеющейся в таблице записи.

Аналогичное поведение будет наблюдаться при попытке изменить значение поля `id` на значение, которое не является уникальным в рамках этого поля.

Результатом приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT UNIQUE,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (id, title, author)
VALUES (1, 'Fight Club', 'Chuck Palahniuk'),
       (2, 'The Green Mile', 'Stephen King');
    
UPDATE Books
SET id = 1
WHERE id = 2;
```

является ошибка:

```
ERROR 1062: Duplicate entry '1' for key 'Books.id'
```

В данном примере в таблицу успешно добавляются обе записи, однако операция обновления второй записи приводит к ошибке, поскольку происходит попытка изменить значение ее поля `id` с уникального (`2`) на неуникальное (`1`).

<hr>

[Содержание](#содержание)

### Значение по умолчанию

Ограничение `DEFAULT` используется для того, чтобы определить значение по умолчанию, которое примет поле в том случае, если при добавлении записи его значение не будет указано явно.

Если поле имеет значение по умолчанию, тип этого значения должен соответствовать типу самого поля.

В качестве примера расширим определение предложенной в начале урока таблицы `Books` и применим ограничение `DEFAULT` к ее полям `title` и `author`. Тогда запрос, создающий таблицу, будет выглядеть следующим образом:

```sql
CREATE TABLE Books
(
    id     INT,
    title  VARCHAR(40) DEFAULT 'Untitled',
    author VARCHAR(40) DEFAULT 'Unknown'
);
```

Теперь, если при добавлении записи в таблицу Books поля `title` и `author` будут опущены, они автоматически примут строковые значения `Untitled` и `Unknown` соответственно.

Результатом приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT,
    title  VARCHAR(40) DEFAULT 'Untitled',
    author VARCHAR(40) DEFAULT 'Unknown'
);

INSERT INTO Books (id)
VALUES (1);

SELECT *
FROM Books;
```

является:

```
+----+----------+---------+
| id | title    | author  |
+----+----------+---------+
| 1  | Untitled | Unknown |
+----+----------+---------+
```

Значение по умолчанию, указанное после ключевого слова `DEFAULT`, может быть как константой, так и произвольной сложности выражением с использованием функций и арифметических операторов. Если в качестве значения по умолчанию используется выражение, оно должно быть заключено в круглые скобки. Также выражение, используемое в качестве значения по умолчанию, может ссылаться на значения других полей записи, однако только в том случае, если эти значения уже определены.

В качестве примера вновь расширим определение предложенной в начале урока таблицы `Books` и добавим ей дополнительное поле `fulltitle`, которое будет хранить полное название книги с указанием автора. Значение по умолчанию этого поля определим как конкатенацию значений полей `title` и `author`. Тогда запрос, создающий таблицу, будет выглядеть следующим образом:

```sql
CREATE TABLE Books
(
    id        INT,
    title     VARCHAR(40),
    author    VARCHAR(40),
    fulltitle VARCHAR(40) DEFAULT (CONCAT(title, ' by ', author))
);
```

Теперь, если при добавлении записи в таблицу Books поле `fulltitle` будет опущено, его значение все равно будет корректно определено на основе значений полей `title` и `author`.

Результатом приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id        INT,
    title     VARCHAR(40),
    author    VARCHAR(40),
    fulltitle VARCHAR(40) DEFAULT (CONCAT(title, ' by ', author))
);

INSERT INTO Books (id, title, author)
VALUES (1, 'Fight Club', 'Chuck Palahniuk');

SELECT *
FROM Books;
```

является:

```
+----+------------+-----------------+-------------------------------+
| id | title      | author          | fulltitle                     |
+----+------------+-----------------+-------------------------------+
| 1  | Fight Club | Chuck Palahniuk | Fight Club by Chuck Palahniuk |
+----+------------+-----------------+-------------------------------+
```

Использование запросов в качестве значений по умолчанию недопустимо.

<hr>

[Содержание](#содержание)

### Дополнительные проверки

Ограничение `CHECK` используется для того, чтобы запретить полю хранить значения, не удовлетворяющие заданному условию. Если поле имеет ограничение `CHECK`, это значит, что при добавлении новой записи или обновлении существующей записи значение этого поля перед установкой будет проверено на корректность.

Условие, используемое для проверки, представляет собой выражение, заключенное в круглые скобки, которое указывается после ключевого слова `CHECK`. Оно может быть составлено с использованием функций и различных операторов сравнения (`=`, `>`, `LIKE` и так далее), то есть иметь произвольную сложность.

В качестве примера расширим определение предложенной в начале урока таблицы `Books` и применим ограничение `CHECK` к ее полю `id`. Тогда запрос, создающий таблицу, будет выглядеть следующим образом:

```sql
CREATE TABLE Books
(
    id     INT CHECK (id > 0),
    title  VARCHAR(40),
    author VARCHAR(40)
);
```

Теперь при попытке добавить в таблицу Books запись, значение поля id которой не является положительным числом, произойдет ошибка.

Результатом приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT CHECK (id > 0),
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (id, title, author)
VALUES (-3, 'Fight Club', 'Chuck Palahniuk');
```

является ошибка:

```
ERROR 3819: Check constraint 'Books_chk_1' is violated.
```

Аналогичное поведение будет наблюдаться при попытке изменить значение поля `id` уже имеющейся записи на неположительное число.

Результатом приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT CHECK (id > 0),
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (id, title, author)
VALUES (1, 'Fight Club', 'Chuck Palahniuk');
    
UPDATE Books
SET id = 0;
```

является ошибка:

```
ERROR 3819: Check constraint 'Books_chk_1' is violated.
```

Ограничение `CHECK` может ссылаться только на значение того поля, для которого применяется.

<hr>

[Содержание](#содержание)

### Комбинирование ограничений

При использовании ограничений их можно комбинировать. Например, к полю `id` таблицы `Books` мы можем одновременно применить два ограничения `UNIQUE` и `NOT NULL`, чтобы разрешить данному полю хранить лишь непустые уникальные значения.

Запрос, создающий таблицу с подобными ограничениями, выглядит следующим образом:

```sql
​​CREATE TABLE Books
(
    id     INT NOT NULL UNIQUE,
    title  VARCHAR(40),
    author VARCHAR(40)
);
```

Обратите внимание, что перечисление ограничений происходит через пробел, а не через запятую.

<hr>

[Содержание](#содержание)

## Примечания 3

**Примечание 1.** У каждого ограничения `CHECK` имеется свое имя, которое СУБД автоматически определяет следующим образом:

```sql
<название таблицы>_chk_<порядковый нормер ограничения>
```

Например, первое определенное в таблице `Books` ограничение будет иметь имя `Books_chk_1`, второе — `Books_chk_2`, и так далее.

Если во время выполнения запроса какое-либо ограничение `CHECK` приводит к ошибке, то его имя отображается в поясняющем сообщении.

Результатом приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT CHECK (id > 0),
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (id, title, author)
VALUES (-1, 'Fight Club', 'Chuck Palahniuk');
```

является ошибка:

```
ERROR 3819: Check constraint 'Books_chk_1' is violated.
```

Для удобства ограничения `CHECK` можно именовать вручную. Для этого необходимо вынести определение ограничения из определения поля и воспользоваться ключевым словом `CONSTRAINT`.

Результатом приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT,
    title  VARCHAR(40),
    author VARCHAR(40),
    CONSTRAINT positive_id CHECK (id > 0)
);

INSERT INTO Books (id, title, author)
VALUES (-1, 'Fight Club', 'Chuck Palahniuk');
```

является ошибка:

```
ERROR 3819: Check constraint 'positive_id' is violated.
```

В примере выше определяется ограничение `CHECK` с именем `positive_id` для поля `id` , которое проверяет, что значением этого поля является положительное число. Определение ограничения выполняется отдельно от определения поля. Оно начинается с ключевого слова `CONSTRAINT`, после которого следует имя ограничения, затем ключевое слово `CHECK` и непосредственно проверяющее выражение. 

**Примечание 2.** При создании таблицы необходимо определить хотя бы одно поле. Таблица может не иметь ни одной записи, но обязательно должна иметь хотя бы одно поле.

**Примечание 3.** Если поле не имеет явно определенного значения по умолчанию, но поддерживает значение `NULL`, значением по умолчанию такого поля будет `NULL`.

Результатом приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (id, title)
VALUES (1, 'Fight Club');

SELECT *
FROM Books;
```

является:

```
+----+------------+--------+
| id | title      | author |
+----+------------+--------+
| 1  | Fight Club | NULL   |
+----+------------+--------+
```

В данном примере при добавлении записи в таблицу `Books` опускается поле `author`, однако, несмотря на то, что данное поле не имеет значения по умолчанию, запись добавляется без ошибок, а в качестве значения поля `author` используется `NULL`.

<hr>

[Содержание](#содержание)

# 9.2 Создание таблиц. Часть 2

Урок посвящен основным правилам создания таблиц.

## Табличные ограничения 2

В прошлом уроке мы рассмотрели ряд табличных ограничений, с помощью которых можно гарантировать целостность хранимой в таблицах базы данных информации. В этом уроке мы продолжим знакомиться с ограничениями, однако на этот раз они будут связаны с ключами: первичными и внешними.

<hr>

[Содержание](#содержание)

## Первичный ключ

В реляционной модели баз данных первичный ключ играет очень важную роль и является неотъемлемой частью практически любой таблицы. Чтобы поле могло быть первичным ключом, оно должно обладать двумя свойствами:
+ поле не должно содержать значение `NULL`
+ поле не должно содержать повторяющиеся значения

Таким образом, чтобы при создании таблицы определить какое-либо ее поле как первичный ключ, мы можем воспользоваться сочетанием ограничений `NOT NULL` и `UNIQUE`, которые как раз и будут гарантировать, что поле содержит лишь уникальные непустые значения. Однако данный способ не достаточно нагляден, а также не позволяет определить первичный ключ, включающий несколько полей. Поэтому в SQL для определения первичного ключа таблицы существует отдельное ограничение — `PRIMARY KEY`.

В качестве примера использования данного ограничения создадим таблицу `Books`, предназначенную для хранения информации о различных книгах. Она будет включать три следующих поля:
+ `id` — целочисленное поле, содержащее уникальный непустой идентификатор книги
+ `title` — строковое поле, содержащее название книги
+ `author` — строковое поле, содержащее автора книги

Теперь рассмотрим запрос, создающий предложенную таблицу. Он выглядит следующим образом:

```sql
CREATE TABLE Books
(
    id     INT PRIMARY KEY,
    title  VARCHAR(40),
    author VARCHAR(40)
)
```

В таблице `Books` ограничение `PRIMARY KEY` применено к полю `id`, то есть это поле является первичным ключом. Теперь при попытке добавить в данную таблицу запись, значение поля `id` которой равняется `NULL` или не является уникальным в рамках этого поля, произойдет ошибка.

Например, результатом приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT PRIMARY KEY,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (id, title, author)
VALUES (NULL, 'It', 'Stephen King');
```

является ошибка:

```
ERROR 1048: Column 'id' cannot be null
```

Аналогичное поведение будет наблюдаться при попытке изменить значение поля `id` уже имеющейся записи на `NULL` или на значение, которое не является уникальным в рамках этого поля.

Например, результатом приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT PRIMARY KEY,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (id, title, author)
VALUES (1, 'It', 'Stephen King'),
       (2, 'Heart of Darkness', 'Joseph Conrad');

UPDATE Books
SET id = 1
WHERE id = 2;
```

является ошибка:

```
ERROR 1062: Duplicate entry '1' for key 'Books.PRIMARY'
```

<hr>

[Содержание](#содержание)

### Составной первичный ключ

Ограничение `PRIMARY KEY` может быть указано в определении лишь одного поля, поэтому при необходимости задать первичный ключ, включающий два и более полей, нужно использовать несколько иной синтаксис.

Предположим, что мы решили сменить структуру предложенной в начале урока таблицы `Books` и отказаться от поля `id`, а в качестве первичного ключа принять сочетание полей `title` и `author`. Тогда запрос, создающий таблицу, будет выглядеть следующим образом:

```sql
CREATE TABLE Books
(
    title  VARCHAR(40),
    author VARCHAR(40),
    PRIMARY KEY (title, author)
);
```

В примере выше видно, что если первичный ключ является составным, то его определение нужно вынести в отдельное определение поля, в котором следует сначала указать ограничение `PRIMARY KEY`, а затем в скобках перечислить все поля, составляющие первичный ключ.

<hr>

[Содержание](#содержание)

### Автоматическое заполнение

Нередко первичный ключ таблицы представляет собой целочисленное поле, содержащее последовательные значения, начиная с `1`. С первичным ключом подобного формата обычно сочетают ограничение `AUTO_INCREMENT`, которое используется для автоматического заполнения поля рядом натуральных чисел. Другими словами, при добавлении записи в таблицу значение такого поля указывать не обязательно, для первой записи автоматически будет принято число `1`, для второй — `2`, и так далее.

Ограничение `AUTO_INCREMENT` может быть указано в определении лишь одного поля, причем это поле должно быть первичным ключом. Также ограничение `AUTO_INCREMENT` не сочетается с ограничением `DEFAULT`.

В качестве примера расширим определение предложенной в начале урока таблицы `Books` и применим ограничение `AUTO_INCREMENT` к ее полю `id`. Тогда запрос, создающий таблицу, будет выглядеть следующим образом:

```sql
CREATE TABLE Books
(
    id     INT PRIMARY KEY AUTO_INCREMENT,
    title  VARCHAR(40),
    author VARCHAR(40)
);
```

Теперь при добавлении записи в таблицу `Books` значение поля `id` можно не указывать, оно само примет нужное последовательное значение.

После выполнения приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT PRIMARY KEY AUTO_INCREMENT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (title, author)
VALUES ('It', 'Stephen King'),
       ('Heart of Darkness', 'Joseph Conrad'),
       ('War and Peace', 'Leo Tolstoy');
```

таблица Books будет иметь вид:

```
+----+-------------------+---------------+
| id | title             | author        |
+----+-------------------+---------------+
| 1  | It                | Stephen King  |
| 2  | Heart of Darkness | Joseph Conrad |
| 3  | War and Peace     | Leo Tolstoy   |
+----+-------------------+---------------+
```

Важно заметить, что ограничение `AUTO_INCREMENT` определяет значение поля `id`, основываясь лишь на очередности добавления записи. Например, третья по счету добавляемая запись в качестве значения поля `id` примет число `3` даже в том случае, если какие-либо добавленные ранее записи были удалены.

После выполнения приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT PRIMARY KEY AUTO_INCREMENT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (title, author)
VALUES ('It', 'Stephen King'),
       ('Heart of Darkness', 'Joseph Conrad');

DELETE FROM Books;
  
INSERT INTO Books (title, author)
VALUES ('War and Peace', 'Leo Tolstoy');
```

таблица Books будет иметь вид:

```
+----+---------------+-------------+
| id | title         | author      |
+----+---------------+-------------+
| 3  | War and Peace | Leo Tolstoy |
+----+---------------+-------------+
```

В данном примере в таблицу добавляются две записи, которые в качестве значения поля `id` принимают числа `1` и `2` соответственно. Затем обе добавленные записи удаляются и добавляется третья запись, которая в качестве значения поля `id` принимает число `3`, а не `1`, несмотря на то что таблица не содержит ни одной записи.

Исключением является очистка таблицы с помощью оператора `TRUNCATE`. При его использовании счетчик ограничения `AUTO_INCREMENT` сбрасывается до `1`.

После выполнения приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT PRIMARY KEY AUTO_INCREMENT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (title, author)
VALUES ('It', 'Stephen King'),
       ('Heart of Darkness', 'Joseph Conrad');

TRUNCATE Books;
  
INSERT INTO Books (title, author)
VALUES ('War and Peace', 'Leo Tolstoy');
```

таблица Books будет иметь вид:

```
+----+---------------+-------------+
| id | title         | author      |
+----+---------------+-------------+
| 1  | War and Peace | Leo Tolstoy |
+----+---------------+-------------+
```

<hr>

[Содержание](#содержание)

## Внешний ключ

Одним из самых важных ограничений является `FOREIGN KEY`, которое предназначено для определения поля как внешнего ключа. Помимо построения связей между таблицами, оно выполняет постоянную поддержку согласованности этих связей. Если пренебрегать ограничением `FOREIGN KEY`, то в процессе работы с таблицами базы данных можно прийти к ситуации, в которой согласованность связанных данных будет нарушена, что, например, может означать то, что какая-либо таблица будет ссылаться на несуществующие данные.

В качестве примера использования ограничения `FOREIGN KEY` создадим две связанные таблицы. Первой из них будет таблица `Authors`, предназначенная для хранения информации о различных авторах книг. Она будет включать три следующих поля:
+ `id` — целочисленное поле, содержащее уникальный непустой идентификатор автора
+ `name` — строковое поле, содержащее имя автора
+ `surname` — строковое поле, содержащее фамилию автора

Второй таблицей будет предложенная в начале урока таблица `Books`, но с некоторыми изменениями. Она будет включать три следующих поля:
+ `id` — целочисленное поле, содержащее уникальный непустой идентификатор книги
+ `title` — строковое поле, содержащее название книги
+ `author_id` — целочисленное поле, содержащее идентификатор автора

Связь между таблицами строится посредством внешнего ключа `author_id` таблицы `Books`, которое ссылается на поле `id` таблицы `Authors`. Таким образом, таблица `Authors` является родительской, а таблица `Books` — дочерней.

Теперь рассмотрим запрос, создающий предложенные таблицы. Он выглядит следующим образом:

```sql
CREATE TABLE Authors
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(40),
    surname VARCHAR(40)
);

CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author_id INT,
    FOREIGN KEY (author_id) REFERENCES Authors (id)
);
```

Часть запроса, создающая таблицу `Authors`, полностью знакома, поэтому сразу перейдем к той части, в которой происходит создание таблицы `Books`, а точнее определение ее внешнего ключа. Оно начинается с ограничения `FOREIGN KEY`, после которого в скобках указывается поле, являющееся внешним ключом. В нашем случае это поле `author_id`. Затем следует ключевое слово `REFERENCES`, а после него — имя родительской таблицы и вновь в скобках поле этой таблицы, на которое ссылается внешний ключ. В нашем случае внешний ключ ссылается на поле `id` таблицы `Authors`.

Внешний ключ и поле, на которое оно ссылается, должны иметь одинаковые типы данных. Размер и знак типов с фиксированной точностью, таких как `INTEGER` и `DECIMAL`, должны быть одинаковыми.

Поле, являющееся внешним ключом, обладает рядом соответствующих особенностей. Например, внешний ключ не может принимать значения, которых нет в поле, на которое он ссылается.

Результатом приведенного ниже запроса:

```sql
CREATE TABLE Authors
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(40),
    surname VARCHAR(40)
);

CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author_id INT,
    FOREIGN KEY (author_id) REFERENCES Authors (id)
);

INSERT INTO Authors (name, surname)
VALUES ('Stephen', 'King'),
       ('Joseph', 'Conrad');
       
INSERT INTO Books (title, author_id)
VALUES ('War and Peace', 3);
```

является ошибка:

```
ERROR 1452: Cannot add or update a child row: a foreign key constraint fails (`Books`, CONSTRAINT `Books_ibfk_1` FOREIGN KEY (`author_id`) REFERENCES `Authors` (`author_id`))
```

Запрос выше сначала добавляет в таблицу `Authors` две записи:

```
​+----+---------+---------+
| id | name    | surname |
+----+---------+---------+
| 1  | Stephen | King    |
| 2  | Joseph  | Conrad  |
+----+---------+---------+
```

Затем выполняется попытка добавить в таблицу `Books` запись, значение поля `author_id` которой равняется `3`. Но поле `id` таблицы `Authors`, на которое ссылается поле `author_id` таблицы `Books`, не содержит значения 3, поэтому и само поле `author_id` не может содержать данное значение.

<hr>

[Содержание](#содержание)

### Поведение при обновлении и удалении

Когда выполняется попытка изменить запись в родительской таблице (а именно значение ее поля, связанного с внешним ключом), от которой зависят записи в дочерней таблице, происходит ошибка.

Результатом приведенного ниже запроса:

```sql
CREATE TABLE Authors
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(40),
    surname VARCHAR(40)
);

CREATE TABLE Books (
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author_id INT,
    FOREIGN KEY (author_id) REFERENCES Authors (id)
);

INSERT INTO Authors (name, surname)
VALUES ('Stephen', 'King'),
       ('Joseph', 'Conrad');
       
INSERT INTO Books (title, author_id)
VALUES ('It', 1);

UPDATE Authors
SET id = 3
WHERE id = 1;
```

является ошибка:

```
ERROR 1451: Cannot delete or update a parent row: a foreign key constraint fails (`beegeek`.`books`, CONSTRAINT `books_ibfk_1` FOREIGN KEY (`author_id`) REFERENCES `authors` (`id`))
```

В данном запросе сначала в таблицу `Authors` добавляются две записи:

```
+----+---------+---------+
| id | name    | surname |
+----+---------+---------+
| 1  | Stephen | King    |
| 2  | Joseph  | Conrad  |
+----+---------+---------+
```

Затем в таблицу `Books` добавляется одна запись :

```
+----+-------+-----------+
| id | title | author_id |
+----+-------+-----------+
| 1  | It    | 1         |
+----+-------+-----------+
```

Первая запись таблицы `Books` становится зависимой от первой записи таблицы `Authors`, поэтому последующая попытка изменить значение поля `id` первой записи таблицы `Authors` с `1` на `3` приводит к ошибке. Аналогичная ошибка возникнет и в том случае, если произойдет попытка удалить первую запись таблицы `Authors`.

Поведение при обновлении или удалении связанных данных является настраиваемым. Чтобы определить действие, которое должно быть выполнено при обновлении, нужно после определения внешнего ключа указать дополнительный оператор `ON UPDATE`, а чтобы определить действие, которое должно быть выполнено при удалении, — оператор `ON DELETE`.

Само же действие определяется одним из трех ключевых слов: `CASCADE`, `SET NULL` или `RESTRICT`. Оно указывается сразу после оператора `ON UPDATE` (`ON DELETE`) и задает соответствующее поведение при обновлении (удалении) связанных данных.

При использовании ключевого слова `RESTRICT` изменение или удаление связанных данных приводит к ошибке. Другими словами, данное ключевое слово задает поведение по умолчанию.

Если используется ключевое слово `CASCADE`, то при изменении или удалении данных в родительской таблице аналогичные действия будут автоматически применены и к связанным записям в дочерней таблице.

После выполнения приведенного ниже запроса:

```sql
CREATE TABLE Authors
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(40),
    surname VARCHAR(40)
);

CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author_id INT,
    FOREIGN KEY (author_id) REFERENCES Authors (id)
        ON UPDATE CASCADE
        ON DELETE CASCADE
);

INSERT INTO Authors (name, surname)
VALUES ('Stephen', 'King'),
       ('Joseph', 'Conrad');
       
INSERT INTO Books (title, author_id)
VALUES ('It', 1),
       ('Heart of Darkness', 2),
       ('Pet Sematary', 1);

UPDATE Authors
SET id = 3
WHERE id = 1;
```

таблица Books будет иметь вид:

```
+----+-------------------+-----------+
| id | title             | author_id |
+----+-------------------+-----------+
| 1  | It                | 3         |
| 2  | Heart of Darkness | 2         |
| 3  | Pet Sematary      | 3         |
+----+-------------------+-----------+
```

таблица `Authors` будет иметь вид:

```
+----+---------+---------+
| id | name    | surname |
+----+---------+---------+
| 2  | Joseph  | Conrad  |
| 3  | Stephen | King    |
+----+---------+---------+
```

Запрос выше сначала добавляет в таблицу Authors две записи:

```
+----+---------+---------+
| id | name    | surname |
+----+---------+---------+
| 1  | Stephen | King    |
| 2  | Joseph  | Conrad  |
+----+---------+---------+
```

После добавляются три записи в таблицу `Books`:

```
+----+-------------------+-----------+
| id | title             | author_id |
+----+-------------------+-----------+
| 1  | It                | 1         |
| 2  | Heart of Darkness | 2         |
| 3  | Pet Sematary      | 1         |
+----+-------------------+-----------+
```

Первая и третья записи таблицы `Books` зависимы от первой записи таблицы `Authors`, однако последующее изменение значения поля `id` первой записи таблицы `Authors` с `1` на `3` приводит не к ошибке, а к аналогичному изменению значений поля `author_id` первой и третьей записей таблицы `Books`.

После выполнения приведенного ниже запроса:

```sql
CREATE TABLE Authors
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(40),
    surname VARCHAR(40)
);

CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author_id INT,
    FOREIGN KEY (author_id) REFERENCES Authors (id)
        ON UPDATE CASCADE
        ON DELETE CASCADE
);

INSERT INTO Authors (name, surname)
VALUES ('Stephen', 'King'),
       ('Joseph', 'Conrad');
       
INSERT INTO Books (title, author_id)
VALUES ('It', 1),
       ('Heart of Darkness', 2),
       ('Pet Sematary', 1);

DELETE FROM Authors
WHERE id = 1;
```

таблица Books будет иметь вид:

```
+----+-------------------+-----------+
| id | title             | author_id |
+----+-------------------+-----------+
| 2  | Heart of Darkness | 2         |
+----+-------------------+-----------+
```

таблица `Authors` будет иметь вид:

```
+----+--------+---------+
| id | name   | surname |
+----+--------+---------+
| 2  | Joseph | Conrad  |
+----+--------+---------+
```

Данный запрос практически полностью повторяет предыдущий запрос. Разница заключается в том, что здесь запись таблицы `Authors` не изменяется, а удаляется, поэтому и зависимые записи таблицы `Books` также удаляются.

Если используется ключевое слово `SET NULL`, то при изменении или удалении данных в родительской таблице связанные записи в дочерней таблице в качестве значения внешнего ключа примут значение `NULL`.

После выполнения приведенного ниже запроса:

```sql
CREATE TABLE Authors
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(40),
    surname VARCHAR(40)
);

CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author_id INT,
    FOREIGN KEY (author_id) REFERENCES Authors (id)
        ON UPDATE SET NULL
        ON DELETE SET NULL
);

INSERT INTO Authors (name, surname)
VALUES ('Stephen', 'King'),
       ('Joseph', 'Conrad');
       
INSERT INTO Books (title, author_id)
VALUES ('It', 1),
       ('Heart of Darkness', 2),
       ('Pet Sematary', 1);

UPDATE Authors
SET id = 3
WHERE id = 1;
```

как и после выполнения приведенного ниже запроса:

```sql
CREATE TABLE Authors
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(40),
    surname VARCHAR(40)
);

CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author_id INT,
    FOREIGN KEY (author_id) REFERENCES Authors (id)
        ON UPDATE SET NULL
        ON DELETE SET NULL
);

INSERT INTO Authors (name, surname)
VALUES ('Stephen', 'King'),
       ('Joseph', 'Conrad');
       
INSERT INTO Books (title, author_id)
VALUES ('It', 1),
       ('Heart of Darkness', 2),
       ('Pet Sematary', 1);

DELETE FROM Authors
WHERE id = 1;
```

таблица Books будет иметь вид:

```
+----+-------------------+-----------+
| id | title             | author_id |
+----+-------------------+-----------+
| 1  | It                | NULL      |
| 2  | Heart of Darkness | 2         |
| 3  | Pet Sematary      | NULL      |
+----+-------------------+-----------+
```

В этих двух запросах, в отличие от двух примеров выше, используется ключевое слово `SET NULL`, поэтому изменение и удаление записи таблицы `Authors` приводит к тому, что связанные с ней записи таблицы Books в качестве значения внешнего ключа просто принимают значение `NULL`.

Операторы `ON UPDATE` и `ON DELETE` можно использовать как вместе, так и отдельно. Также каждый из операторов может задавать собственное поведение, например, `ON UPDATE — CASCADE`, а `ON DELETE — SET NULL`.

<hr>

[Содержание](#содержание)

## Примечания 2

**Примечание 1.** Если необходимо получить информацию о полях таблицы, можно воспользоваться оператором `DESCRIBE`.

Результатом приведенного ниже запроса:

```sql
CREATE TABLE Authors
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(40),
    surname VARCHAR(40)
);

CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author_id INT,
    FOREIGN KEY (author_id) REFERENCES Authors (id)
);

DESCRIBE Books;
```

является:

```
+-----------+-------------+------+-----+---------+----------------+
| Field     | Type        | Null | Key | Default | Extra          |
+-----------+-------------+------+-----+---------+----------------+
| id        | int         | NO   | PRI | NULL    | auto_increment |
| title     | varchar(40) | YES  |     | NULL    |                |
| author_id | int         | YES  | MUL | NULL    |                |
+-----------+-------------+------+-----+---------+----------------+
```

**Примечание 2.** Внешний ключ может состоять как из одного, так и из нескольких полей. Разница лишь в том, что в первом случае в скобках после ограничения `FOREIGN KEY` и названия родительской таблицы указывается только одно поле, а во втором случае перечисляются несколько полей через запятую.

Таким образом, синтаксис ограничения `FOREIGN KEY` в общем виде имеет следующий вид:

```sql
FOREIGN KEY (<1 поле>, <2 поле>, ...) REFERENCES <имя родительской таблицы> (<1 поле>, <2 поле>, ...)
```

<hr>

[Содержание](#содержание)

# 9.3 Удаление, переименование и обновление таблиц

Урок посвящен удалению, переименованию и обновлению таблиц.

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем `Books`, которая содержит информацию о книгах, размещенных в некоторой электронной библиотеке:

```
+----+------------------------------------------+-----------------+
| id | title                                    | author          |
+----+------------------------------------------+-----------------+
| 1  | Fight Club                               | Chuck Palahniuk |
| 2  | The Green Mile                           | Stephen King    |
| 3  | The Lord of the Rings                    | J.R.R. Tolkien  |
| 4  | It                                       | Stephen King    |
| 5  | Harry Potter and the Prisoner of Azkaban | J.K. Rowling    |
+----+------------------------------------------+-----------------+
```

Первое поле этой таблицы содержит идентификатор книги, второе — название, третье — данные об авторе.

Скрипт для создания таблицы `Books`

```sql
DROP TABLE IF EXISTS Books;
CREATE TABLE Books
(
    id     INT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (id, title, author)
VALUES (1, 'Fight Club', 'Chuck Palahniuk'),
       (2, 'The Green Mile', 'Stephen King'),
       (3, 'The Lord of the Rings', 'J.R.R. Tolkien'),
       (4, 'It', 'Stephen King'),
       (5, 'Harry Potter and the Prisoner of Azkaban', 'J.K. Rowling');
```

<hr>

[Содержание](#содержание)

## Удаление таблицы

Посредством запроса можно удалить не только содержимое таблицы, но и саму таблицу. Удаление таблицы — очень простой процесс, для выполнения которого всего лишь нужно воспользоваться оператором `DROP TABLE`, а затем указать имя удаляемой таблицы.

Например, запрос, который удаляет таблицу `Books`, выглядит следующим образом:

```sql
DROP TABLE Books;
```

Если требуется удалить несколько таблиц одновременно, достаточно после оператора `DROP TABLE` перечислить через запятую их имена.

Оператор `DROP TABLE` удаляет таблицу только в том случае, если она содержится в базе данных, в противном случае оператор завершает операцию удаления с ошибкой. Однако если воспользоваться дополнительным оператором `IF EXISTS`, таблица будет удалена только в том случае, если она существует, в противном случае операция удаления будет проигнорирована.

Например, запрос, который удаляет таблицу `Books` с дополнительной проверкой существования таблицы, выглядит следующим образом:

```sql
DROP TABLE IF EXISTS Books;
```

Во время удаления таблицы необходимо помнить о том, что она может иметь связи с другими таблицами. Если от удаляемой таблицы зависят другие таблицы, то при попытке ее удалить произойдет ошибка.

<hr>

[Содержание](#содержание)

## Переименование таблицы

Переименование таблицы является таким же легким процессом, как и ее удаление. Для его выполнения необходимо воспользоваться оператором `RENAME TABLE`, синтаксис которого имеет следующий вид:

```sql
RENAME TABLE <текущее имя таблицы> TO <новое имя таблицы>
```

Например, запрос, который изменяет имя таблицы `Books` на `OldBooks`, выглядит следующим образом:

```sql
RENAME TABLE Books TO OldBooks;
```

<hr>

[Содержание](#содержание)

## Обновление таблицы

После создания таблицы ее определение можно обновить. Несмотря на то что SQL позволяет достаточно гибко модифицировать структуру уже созданной таблицы, злоупотреблять данной возможностью не рекомендуется. При разработке таблиц следует анализировать будущие потребности, чтобы позже не пришлось существенно менять структуру таблиц. В идеале структура таблицы вообще не должна меняться после того, как в нее были добавлены данные.

Любой запрос, модифицирующий таблицу, начинается с оператора `ALTER TABLE`, после которого указывается имя таблицы, подлежащей модификации. После имени таблицы указывается действие (с использованием соответствующего оператора), которое должно быть применено по отношению к этой таблице.

<hr>

[Содержание](#содержание)

### Удаление поля

Удаление поля таблицы выполняется с помощью оператора `DROP COLUMN`. В качестве примера его использования, напишем запрос, который удаляет из таблицы `Books` поле author.

После выполнения приведенного ниже запроса:

```sql
ALTER TABLE Books
DROP COLUMN author;
```

таблица `Books` будет иметь вид:

```
+----+------------------------------------------+
| id | title                                    |
+----+------------------------------------------+
| 1  | Fight Club                               |
| 2  | The Green Mile                           |
| 3  | The Lord of the Rings                    |
| 4  | It                                       |
| 5  | Harry Potter and the Prisoner of Azkaban |
+----+------------------------------------------+
```

<hr>

[Содержание](#содержание)

### Переименование поля

Переименование поля таблицы синтаксически похоже на переименование самой таблицы и выполняется с помощью оператора `RENAME COLUMN`. В качестве примера его использования напишем запрос, который изменяет название поля author таблицы `Books` на `writer`.

После выполнения приведенного ниже запроса:

```sql
ALTER TABLE Books
RENAME COLUMN author TO writer;
```

таблица Books будет иметь вид:

```
+----+------------------------------------------+-----------------+
| id | title                                    | writer          |
+----+------------------------------------------+-----------------+
| 1  | Fight Club                               | Chuck Palahniuk |
| 2  | The Green Mile                           | Stephen King    |
| 3  | The Lord of the Rings                    | J.R.R. Tolkien  |
| 4  | It                                       | Stephen King    |
| 5  | Harry Potter and the Prisoner of Azkaban | J.K. Rowling    |
+----+------------------------------------------+-----------------+
```

<hr>

[Содержание](#содержание)

### Добавление поля

При желании таблицу можно расширить, добавив ей новое поле. Для этого необходимо воспользоваться оператором `ADD COLUMN`, а затем предоставить определение нового поля таблицы.

В качестве примера использования оператора `ADD COLUMN` напишем запрос, который добавляет в таблицу `Books` целочисленное поле `release_year` — год выпуска книги.

После выполнения приведенного ниже запроса:

```sql
ALTER TABLE Books
ADD COLUMN release_year INT CHECK (release_year > 0);
```

таблица `Books` будет иметь вид:

```
+----+------------------------------------------+-----------------+--------------+
| id | title                                    | author          | release_year |
+----+------------------------------------------+-----------------+--------------+
| 1  | Fight Club                               | Chuck Palahniuk | NULL         |
| 2  | The Green Mile                           | Stephen King    | NULL         |
| 3  | The Lord of the Rings                    | J.R.R. Tolkien  | NULL         |
| 4  | It                                       | Stephen King    | NULL         |
| 5  | Harry Potter and the Prisoner of Azkaban | J.K. Rowling    | NULL         |
+----+------------------------------------------+-----------------+--------------+
```

По умолчанию оператор `ADD COLUMN` добавляет новое поле в конец таблицы, однако это поведение можно изменить. Например, если после определения поля указать ключевое слово `FIRST`, новое поле будет добавлено в начало таблицы.

После выполнения приведенного ниже запроса:

```sql
ALTER TABLE Books
ADD COLUMN release_year INT CHECK (release_year > 0) FIRST;
```

таблица Books будет иметь вид:

```
+--------------+----+------------------------------------------+-----------------+
| release_year | id | title                                    | author          |
+--------------+----+------------------------------------------+-----------------+
| NULL         | 1  | Fight Club                               | Chuck Palahniuk |
| NULL         | 2  | The Green Mile                           | Stephen King    |
| NULL         | 3  | The Lord of the Rings                    | J.R.R. Tolkien  |
| NULL         | 4  | It                                       | Stephen King    |
| NULL         | 5  | Harry Potter and the Prisoner of Azkaban | J.K. Rowling    |
+--------------+----+------------------------------------------+-----------------+
```

Также новое поле можно поместить в конкретную часть таблицы — после заданного поля. Для этого нужно указать ключевое слово `AFTER`, а затем предоставить название поля, после которого должно быть расположено новое поле.

После выполнения приведенного ниже запроса:

```sql
ALTER TABLE Books
ADD COLUMN release_year INT CHECK (release_year > 0) AFTER title;
```

таблица `Books` будет иметь вид:

```
+----+------------------------------------------+--------------+-----------------+
| id | title                                    | release_year | author          |
+----+------------------------------------------+--------------+-----------------+
| 1  | Fight Club                               | NULL         | Chuck Palahniuk |
| 2  | The Green Mile                           | NULL         | Stephen King    |
| 3  | The Lord of the Rings                    | NULL         | J.R.R. Tolkien  |
| 4  | It                                       | NULL         | Stephen King    |
| 5  | Harry Potter and the Prisoner of Azkaban | NULL         | J.K. Rowling    |
+----+------------------------------------------+--------------+-----------------+
```

В примере выше по-прежнему добавляется целочисленное поле `release_year`, однако его положение определяется явно — после поля `title`.

Важно заметить, что если поле, которое использует ограничение `NOT NULL` и не имеет значения по умолчанию, добавляется в непустую таблицу, то для такого поля будет автоматически выбрано значение по умолчанию. Например, для целочисленного типа таким значением является `0`, для строкового — пустая строка.

Результатом приведенного ниже запроса:

```sql
ALTER TABLE Books
ADD COLUMN release_year INT NOT NULL;
```

является:

```
+----+------------------------------------------+-----------------+--------------+
| id | title                                    | author          | release_year |
+----+------------------------------------------+-----------------+--------------+
| 1  | Fight Club                               | Chuck Palahniuk | 0            |
| 2  | The Green Mile                           | Stephen King    | 0            |
| 3  | The Lord of the Rings                    | J.R.R. Tolkien  | 0            |
| 4  | It                                       | Stephen King    | 0            |
| 5  | Harry Potter and the Prisoner of Azkaban | J.K. Rowling    | 0            |
+----+------------------------------------------+-----------------+--------------+
```

В данном примере вновь добавляется целочисленное поле `release_year`, однако уже с использованием ограничения `NOT NULL`. Таблица, в которую добавляется поле, имеет несколько записей, и все они должны что-то принять в качестве значения нового поля. Поскольку новое поле не поддерживает значение `NULL`, а значение по умолчанию не указано явно, все записи в качестве значения поля `release_year` принимают значение по умолчанию, выбранное автоматически, — число `0`.

Если поле, которое использует ограничение `NOT NULL` и не имеет значения по умолчанию, добавляется в пустую таблицу, то значение по умолчанию для такого поля автоматически выбрано не будет.

<hr>

[Содержание](#содержание)

### Обновление поля

Поле существующей таблицы можно не только переименовать, но и полностью переопределить, то есть изменить его тип и набор ограничений. Для этого необходимо воспользоваться оператором `MODIFY COLUMN`, а затем предоставить новое определение желаемого поля.

Например, поле `title` нашей таблицы `Books` определено следующим образом:

```sql
title VARCHAR(40)
```

Предположим, мы хотим изменить тип данного поля, оставив его равным `VARCHAR`, но увеличив количество допустимых символов с `40` до `60`, а также добавить ограничение `CHECK`. Тогда запрос, обновляющий поле `title` таблицы `Books` будет выглядеть следующим образом:

```sql
ALTER TABLE Books
MODIFY COLUMN title VARCHAR(60) CHECK (title != '');
```

Следует уточнить, что оператор `MODIFY COLUMN` не расширяет текущее определение поля, а именно полностью его изменяет. Поэтому, если необходимо сохранить какие-либо имеющиеся свойства поля (например, значение по умолчанию), во время переопределения их нужно указать снова. Исключениями являются ограничения `PRIMARY KEY` и `UNIQUE` — они сохраняются даже в случае переопределения поля.

Изменение типа поля может привести к изменению хранимых в нем данных. К примеру, изменение типа поля с `FLOAT` на `INT` приведет к тому, что числа в этом поле будут округлены до целых значений.

При необходимости задать полю значение по умолчанию переопределять его полностью нет необходимости, поскольку для данной операции предназначена специальная связка операторов `ALTER COLUMN` и `SET DEFAULT`, синтаксис которых имеет следующий вид:

```sql
ALTER COLUMN <название поля> SET DEFAULT <значение по умолчанию>
```

Например, запрос, задающий полю `title` таблицы `Books` в качестве значения по умолчанию строку `Untitled`, выглядит следующим образом:

```sql
ALTER TABLE Books
ALTER COLUMN title SET DEFAULT 'Untitled';
```

Воспользовавшись связкой операторов `ALTER COLUMN` и `DROP DEFAULT`, можно удалить значение по умолчанию, которым обладает поле. Если у поля нет значения по умолчанию, никаких ошибок не произойдет, операция будет просто проигнорирована.

Например, запрос, удаляющий значение по умолчанию поля `title` таблицы `Books`, выглядит следующим образом:

```sql
ALTER TABLE Books
ALTER COLUMN title DROP DEFAULT;
```

<hr>

[Содержание](#содержание)

### Добавление и удаление первичного ключа

Первичный ключ таблицы может быть определен уже после того, как таблица была создана. Для этого необходимо воспользоваться оператором `ADD PRIMARY KEY`, а затем в скобках указать поле, которое должно стать первичным ключом. Если первичный ключ должен состоять из нескольких полей, их нужно перечислить через запятую.

Например, наша таблица `Books` не имеет первичного ключа. Тогда запрос, определяющий поле `id` этой таблицы как первичный ключ, будет выглядеть следующим образом:

```sql
ALTER TABLE Books
ADD PRIMARY KEY (id);
```

Первичный ключ может быть как добавлен, так и удален. Удаление выполняется даже проще, чем добавление, для этого всего лишь необходимо воспользоваться оператором `DROP PRIMARY KEY`.

Например, если после определения поля `id` нашей таблицы `Books` как первичного ключа мы хотим это поле преобразовать из первичного ключа в обычное поле, то выполнить это можно следующим образом:

```sql
ALTER TABLE Books
DROP PRIMARY KEY;
```

Если таблица имеет первичный ключ, то при попытке добавить ей другой первичный ключ произойдет ошибка. Поэтому, если требуется обновить первичный ключ таблицы, сначала следует избавиться от имеющегося.

<hr>

[Содержание](#содержание)

### Добавление и удаление внешнего ключа

После создания таблицы можно определить не только первичный ключ, но и внешний. Для этого необходимо воспользоваться оператором `ADD FOREIGN KEY`, а затем привычным способом определить внешний ключ.

Для рассмотрения примера определения внешнего ключа уже существующей таблицы, добавим в нашу базу данных дополнительную таблицу `Publishers`, которая хранит информацию о книжных издательствах. Она имеет следующий вид:

```
+-----------------------+----------------+-------------------------+
| name                  | country        | website                 |
+-----------------------+----------------+-------------------------+
| Allen & Unwin         | United Kingdom | allenandunwin.com       |
| Bloomsbury Publishing | United Kingdom | bloomsbury.com          |
| New American Library  | United States  | penguin.com             |
| Viking Press          | United States  | penguin.com             |
| W.W.Norton & Company  | United States  | wnorton.com             |
+-----------------------+----------------+-------------------------+
```

Первое поле таблицы `Publishers` содержит название издательства, второе — страну издательства, третье — официальный сайт издательства.

Скрипт для создания таблицы `Publishers`

```sql
DROP TABLE IF EXISTS Publishers;
CREATE TABLE Publishers
(
    name    VARCHAR(40) PRIMARY KEY,
    country VARCHAR(40),
    website VARCHAR(40)
);

INSERT INTO Publishers (name, country, website)
VALUES ('Allen & Unwin', 'United Kingdom', 'allenandunwin.com'),
       ('Bloomsbury Publishing', 'United Kingdom', 'bloomsbury.com'),
       ('New American Library', 'United States', 'penguin.com'),
       ('Viking Press', 'United States', 'penguin.com'),
       ('W.W.Norton & Company', 'United States', 'wnorton.com');
```

Предположим, мы хотим добавить в таблицу `Books` новое поле `publisher`, а затем сделать это поле внешним ключом, которое будет ссылаться на поле name таблицы `Publishers`. Тогда запрос, выполняющий это, будет выглядеть следующим образом:

```sql
ALTER TABLE Books
ADD COLUMN publisher VARCHAR(40);

ALTER TABLE Books
ADD FOREIGN KEY (publisher) REFERENCES Publishers (name);
```

Конечно, определение внешнего ключа можно было выполнить и во время добавления поля в таблицу, однако данный пример используется именно для демонстрации работы оператора `ADD FOREIGN KEY`.

Внешний ключ может быть как добавлен, так и удален. Удаление выполняется даже проще, чем добавление, для этого всего лишь необходимо воспользоваться оператором `DROP FOREIGN KEY`, а затем указать имя внешнего ключа, которое необходимо удалить.

Например, если после добавления в нашу таблицу `Books` поля `publisher` в качестве внешнего ключа мы хотим это поле преобразовать из внешнего ключа в обычное поле, то выполнить это можно следующим образом:

```sql
ALTER TABLE Books
DROP FOREIGN KEY publisher;
```

<hr>

[Содержание](#содержание)

### Добавление и удаление дополнительной проверки

Ограничение `CHECK`, как и значение по умолчанию, может быть добавлено отдельно и не требует полного переопределения поля. Для того чтобы добавить ограничение `CHECK`, нужно воспользоваться оператором `ADD CHECK`, а затем в скобках указать проверяющее выражение.

Например, наша таблица `Books` не имеет ни одного ограничения `CHECK`. Если мы хотим добавить ей одно ограничение `CHECK`, которое проверяет, что значение поля `title` не является пустой строкой, то выполнить это можно следующим образом:

```sql
ALTER TABLE Books
ADD CHECK (title != '');
```

При добавлении ограничения `CHECK` стоит учитывать, что, если в таблице уже содержатся данные, не соответствующие ограничению, операция добавления ограничения приведет к ошибке.

При необходимости добавить в таблицу именованное ограничение `CHECK` можно воспользоваться оператором `ADD CONSTRAINT`, синтаксис которого имеет следующий вид:

```sql
ADD CONSTRAINT <имя ограничения> CHECK (<проверяющее выражение>)
```

Например, мы можем добавить в таблицу `Books` предложенное выше ограничение `CHECK`, но при этом дополнительно назвав его `title_is_not_empty_string`. Запрос, выполняющий это, будет выглядеть следующим образом:

```sql
ALTER TABLE Books
ADD CONSTRAINT title_is_not_empty_string CHECK (title != '');
```

Ограничение `CHECK` может быть как добавлено, так и удалено. Удаление выполняется даже проще, чем добавление, для этого всего лишь необходимо воспользоваться оператором `DROP CONSTRAINT`, а затем указать имя ограничения `CHECK`, которое требуется удалить.

Предположим, наша таблица `Books` имеет ограничение `CHECK` с именем `title_is_not_empty_string` и мы хотим удалить данное ограничение. Тогда запрос, выполняющий это, будет выглядеть следующим образом:

```sql
ALTER TABLE Books
DROP CONSTRAINT title_is_not_empty_string;
```

<hr>

[Содержание](#содержание)

## Примечания 3

**Примечание 1.** Оператор `ALTER TABLE` в своем теле может содержать как одно действие, так и несколько. Во втором случае все действия перечисляются через запятую.

В качестве примера напишем запрос, который добавляет в таблицу `Books` целочисленное поле `release_year` — год выпуска книги, а также строковое поле `publisher` — издателя книги.

После выполнения приведенного ниже запроса:

```sql
ALTER TABLE Books
ADD COLUMN release_year INT,
ADD COLUMN publisher VARCHAR(40);
```

таблица `Books` будет иметь вид:

```
+----+------------------------------------------+-----------------+--------------+-----------+
| id | title                                    | author          | release_year | publisher |
+----+------------------------------------------+-----------------+--------------+-----------+
| 1  | Fight Club                               | Chuck Palahniuk | NULL         | NULL      |
| 2  | The Green Mile                           | Stephen King    | NULL         | NULL      |
| 3  | The Lord of the Rings                    | J.R.R. Tolkien  | NULL         | NULL      |
| 4  | It                                       | Stephen King    | NULL         | NULL      |
| 5  | Harry Potter and the Prisoner of Azkaban | J.K. Rowling    | NULL         | NULL      |
+----+------------------------------------------+-----------------+--------------+-----------+
```

**Примечание 2.** Если необходимо сразу переименовать и переопределить поле, можно воспользоваться оператором `CHANGE COLUMN`, который выполняет эти операции за один раз. Синтаксис данного оператора имеет следующий вид:

```sql
CHANGE COLUMN <текущее имя поля> <новое определение поля, включающее имя, тип и набор ограничений>
```

В качестве примера использования оператора `CHANGE COLUMN` напишем запрос, который полностью обновляет поле `title` таблицы `Books`, изменяя его имя, тип, а также добавляя одно ограничение.

После выполнения приведенного ниже запроса:

```sql
ALTER TABLE Books
CHANGE COLUMN title name VARCHAR(60) CHECK (name != '');
```

таблица `Books` будет иметь вид:

```
+----+------------------------------------------+-----------------+
| id | name                                     | author          |
+----+------------------------------------------+-----------------+
| 1  | Fight Club                               | Chuck Palahniuk |
| 2  | The Green Mile                           | Stephen King    |
| 3  | The Lord of the Rings                    | J.R.R. Tolkien  |
| 4  | It                                       | Stephen King    |
| 5  | Harry Potter and the Prisoner of Azkaban | J.K. Rowling    |
+----+------------------------------------------+-----------------+
```

**Примечание 3.** Изменение типа поля всегда должно выполняться с осторожностью. Например, сокращение количества символов строкового типа может привести к ошибке, если в поле содержатся строки, состоящие из большего количества символов, чем допускает новый тип данных.

**Примечание 4.** Важно помнить, что для удаления таблицы используется именно оператор `DROP TABLE`, а не `DELETE`. Оператор `DELETE` удаляет записи таблицы (все или некоторые), но никогда не удаляет саму таблицу.

**Примечание 5.** Создание, чтение, модификация и удаление — это четыре классические операции, которые в терминологии баз данных часто называют аббревиатурой CRUD (`Create`, `Read`, `Update`, `Delete`). Подробнее об этом можно почитать по [ссылке](https://ru.wikipedia.org/wiki/CRUD).

<hr>

[Содержание](#содержание)

# 9.4 Триггеры

Урок посвящен триггерам и примерам их использования.

##  Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем `Authors`, которая содержит информацию о различных популярных авторах книг:

```
+----+---------+-----------+
| id | name    | surname   |
+----+---------+-----------+
| 1  | Stephen | King      |
| 2  | Chuck   | Palahniuk |
| 3  | Jerome  | Salinger  |
+----+---------+-----------+
```

Первое поле этой таблицы содержит идентификатор автора, второе — имя, третье — фамилию.

Скрипт для создания таблицы `Authors`

```sql
DROP TABLE IF EXISTS Authors;
CREATE TABLE Authors
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    name      VARCHAR(40),
    surname   VARCHAR(40)
);

INSERT INTO Authors (name, surname)
VALUES ('Stephen', 'King'),
       ('Chuck', 'Palahniuk'),
       ('Jerome', 'Salinger');
```

<hr>

[Содержание](#содержание)

## Триггеры

**Триггер** — это запрос, который автоматически выполняется во время применения операций `INSERT`, `DELETE` или `UPDATE` по отношению к определенной таблице. Например, триггер, ассоциированный с оператором `DELETE` по отношению к условной таблице `Table`, будет выполняться всякий раз, когда из этой таблицы будут удаляться записи.

Триггер всегда привязывается к таблице и не может существовать в отрыве от нее. Другими словами, если удалится таблица, будет удален и привязанный к ней триггер.

Триггеры применяются для самых различных задач. К примеру, с их помощью можно автоматически преобразовывать добавляемые в таблицу данные в нужный формат, что позволяет обеспечивать непротиворечивость данных. Также их можно использовать для выполнения действий по отношению к одной таблице на основе изменений, которые были сделаны в другой таблице, что может быть полезно для ведения журнала событий.

<hr>

[Содержание](#содержание)

## Создание триггеров

Процесс создания триггеров не представляет большой сложности, однако имеет ряд важных особенностей, требующих уточнения, поэтому для лучшего его понимания сперва подробнее ознакомимся с синтаксисом.

Общий шаблон для создания триггера имеет следующий вид:

```sql
DELIMITER //
CREATE TRIGGER <имя триггера>
<время срабатывания триггера> <операция, которая вызывает триггер>
ON <имя таблицы>
FOR EACH ROW
BEGIN
    <тело триггера>;
END //
DELIMITER ;
```

Несложно заметить, что шаблон начинается не совсем с создания триггера, а с ключевого слова `DELIMITER`. Оно используется для изменения разделителя, которым по умолчанию является точка с запятой (`;`). Здесь в качестве нового разделителя устанавливается двойной слэш (`//`).

Изменение разделителя перед созданием триггера является важной частью, поскольку запрос в теле триггера должен быть завершен символом `;`. Для разделения фрагментов запроса в теле триггера также используется точка с запятой. Если заранее не переопределить разделитель, СУБД посчитает, что символ `;` в теле триггера завершает не запрос, а создание самого триггера, что приведет к ошибке, поскольку в таком случае создание триггера будет оборвано на половине.

Непосредственно создание триггера начинается с оператора `CREATE TRIGGER`, после которого указывается имя триггера. Затем определяются время срабатывания триггера и операция, которая вызывает триггер. Время срабатывания определяется одним из операторов `BEFORE` и `AFTER`, а операция, вызывающая триггер, — одним из операторов `INSERT`, `DELETE` и `UPDATE`.

Например, сочетание операторов `BEFORE INSERT` создаст триггер, который будет выполняться всякий раз, когда в таблицу добавляется запись, причем триггер будет выполняться перед добавлением записи. С другой стороны, сочетание операторов `AFTER INSERT` создаст триггер, который также будет выполняться всякий раз, когда в таблицу добавляется запись, однако этот триггер уже будет выполняться после добавления записи.

Оператор `BEFORE` используется в том случае, если нужно, чтобы триггер выполнялся перед вызывающей его операцией. При необходимости выполнения триггера после вызывающей его операции используется оператор `AFTER`.

После операции, вызывающей триггер, указывается ключевое слово `ON` и название таблицы, для которой создается триггер. Затем следует набор ключевых слов `FOR EACH ROW`. Внутрь последующего блока `BEGIN END` помещается запрос, который и будет выполняться каждый раз при срабатывании триггера. Завершается создание триггера обновленным разделителем `//` и возвратом к стандартному разделителю в виде символа `;`.

<hr>

[Содержание](#содержание)

### Доступ к значениям записи

Операция, вызывающая триггер, всегда связана с какой-либо записью таблицы, и триггер имеет доступ к значениям этой записи. Уровень доступа определяется типом триггера:
+ `BEFORE INSERT` — имеет доступ к значениям добавляемой записи; может изменять значения добавляемой записи
+ `AFTER INSERT` — имеет доступ к значениям добавленной записи
+ `BEFORE UPDATE` — имеет доступ к старым и новым значениям обновляемой записи; может изменять новые значения обновляемой записи
+ `AFTER UPDATE` — имеет доступ к старым и новым значениям обновленной записи
+ `BEFORE DELETE` — имеет доступ к значениям удаляемой записи
+ `AFTER DELETE` — имеет доступ к значениям удаленной записи

Рассмотрим подробнее, к примеру, триггер типа `BEFORE UPDATE`, который выполняется до изменения какой-либо записи. Изменение записи всегда сопровождается старыми и новыми значениями, и триггер типа `BEFORE UPDATE` может обратиться и к тем, и к другим.

Для обращения к старым значениям записи используется переменная `OLD`, к новым — `NEW`. Например, если необходимо обратиться к старому значению условного поля `field`, то сделать это можно с помощью `OLD.field`.

Также триггер типа `BEFORE UPDATE` может не только обратиться к новым значениям записи, но и изменить их. Выполняется это с помощью оператора `SET`, после которого указывается имя поля, а затем знак равенства и новое значение. Например, если необходимо изменить новое значение условного поля `field`, скажем, на число `1`, то сделать это можно следующим образом:

```sql
SET NEW.field = 1
```

<hr>

[Содержание](#содержание)

## Примеры использования триггеров

**Пример 1.** Создадим триггер `name_and_surname_formatting`, который перед добавлением строкового значения в поле `name` или `surname` таблицы `Authors` переводит ее первый символ в верхний регистр, а остальные — в нижний.

Результатом приведенного ниже запроса:

```sql
DELIMITER //
CREATE TRIGGER name_and_surname_formatting
BEFORE INSERT
ON Authors
FOR EACH ROW
BEGIN
    SET NEW.name = CONCAT(UPPER(LEFT(NEW.name, 1)), LOWER(SUBSTRING(NEW.name, 2)));
    SET NEW.surname= CONCAT(UPPER(LEFT(NEW.surname, 1)), LOWER(SUBSTRING(NEW.surname, 2)));
END //
DELIMITER ;

INSERT INTO Authors (name, surname) 
VALUES ('LEO', 'TOLSTOY'),
       ('william', 'shakespeare'),
       ('fYODOr', 'dOSTOYEVSKy');
       
SELECT id, name, surname
FROM Authors;
```

является:

```
+----+---------+-------------+
| id | name    | surname     |
+----+---------+-------------+
| 1  | Stephen | King        |
| 2  | Chuck   | Palahniuk   |
| 3  | Jerome  | Salinger    |
| 4  | Leo     | Tolstoy     |
| 5  | William | Shakespeare |
| 6  | Fyodor  | Dostoyevsky |
+----+---------+-------------+
```

**Пример 2.** Создадим триггер `name_and_surname_logging`, который фиксирует каждое изменение имени и фамилии автора в таблице `Authors`. Подробная информация об изменениях будет записываться в дополнительную таблицу `AuthorsNameHistory`, которая имеет следующую структуру:

```
+--------+-----------+----------+-------------+----------+-------------+
| log_id | author_id | old_name | old_surname | new_name | new_surname |
+--------+-----------+----------+-------------+----------+-------------+
| ...    | ...       | ...      | ...         | ...      | ...         |
+--------+-----------+----------+-------------+----------+-------------+
```

Первое поле этой таблицы содержит идентификатор изменения, второе — идентификатор автора, данные которого были изменены, третье — старое имя, четвертое — старую фамилию, пятое — новое имя, шестое — новую фамилию.

Результатом приведенного ниже запроса:

```sql
DELIMITER //
CREATE TRIGGER name_and_surname_logging
AFTER UPDATE
ON Authors
FOR EACH ROW
BEGIN
    INSERT INTO AuthorsNameHistory (author_id, old_name, old_surname, new_name, new_surname)
    VALUES (OLD.id, OLD.name, OLD.surname, NEW.name, NEW.surname);
END //
DELIMITER ;

UPDATE Authors
SET name = 'Richard',
    surname = 'Bachman'
WHERE name = 'Stephen' AND surname = 'King';
       
SELECT author_id, old_name, old_surname, new_name, new_surname
FROM AuthorsNameHistory;
```

является:

```
+-----------+----------+-------------+----------+-------------+
| author_id | old_name | old_surname | new_name | new_surname |
+-----------+----------+-------------+----------+-------------+
| 1         | Stephen  | King        | Richard  | Bachman     |
+-----------+----------+-------------+----------+-------------+
```

<hr>

[Содержание](#содержание)

# Удаление триггеров

Триггеры, как и многие другие объекты базы данных, могут быть удалены. Для этого необходимо воспользоваться оператором `DROP TRIGGER`, а затем указать имя удаляемого триггера.

Предположим, в нашей базе содержится триггер с именем `name_and_surname_formatting` и мы хотим его удалить. Тогда запрос, выполняющий это, будет выглядеть следующим образом:

```sql
DROP TRIGGER name_and_surname_formatting;
```

<hr>

[Содержание](#содержание)

## Примечания 4

**Примечание 1.** Часть `FOR EACH ROW` при создании триггера говорит о том, что триггер вызывается для каждой затрагиваемой операцией `INSERT`, `UPDATE` или `DELETE` записи. Например, если в таблицу добавляются три записи, триггер также будет выполнен три раза — отдельно для каждой добавляемой записи.

**Примечание 2.** Триггеры могут поддерживать целостность связей между таблицами, как это делает ограничение `FOREIGN KEY`, или добавлять дополнительные правила для хранимых данных, как это делает ограничение `CHECK`. Как правило, ограничения обрабатываются быстрее, чем триггеры, поэтому по возможности рекомендуется использовать именно ограничения.

**Примечание 3.** Если тело триггера представляет собой одиночный запрос, то можно воспользоваться упрощенным синтаксисом создания триггера:

```sql
CREATE TRIGGER <имя триггера>
<время срабатывания триггера> <операция, которая вызывает триггер>
ON <имя таблицы>
FOR EACH ROW
<тело триггера>
При использовании упрощенного синтаксиса не нужно помещать тело триггера в блок BEGIN END, а также изменять стандартный разделитель.
```

<hr>

[Содержание](#содержание)

# 9.5 Представления

Урок посвящен представлениям и примерам их использования.

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из двух таблиц и содержит информацию о книгах, размещенных в некоторой электронной библиотеке.

Первая таблица. Информация об авторах книг располагается в таблице `Authors`, которая имеет следующий вид:

```
+----+---------+-----------+
| id | name    | surname   |
+----+---------+-----------+
| 1  | Stephen | King      |
| 2  | Chuck   | Palahniuk |
| 3  | Jerome  | Salinger  |
| 4  | Leo     | Tolstoy   |
+----+---------+-----------+
```

Первое поле этой таблицы содержит идентификатор автора, второе — имя, третье — фамилию.

Вторая таблица. Информация о размещенных в библиотеке книгах располагается в таблице `Books`, которая имеет следующий вид:

```
+----+------------------------+--------------+-----------+
| id | title                  | release_year | author_id |
+----+------------------------+--------------+-----------+
| 1  | The Shining            | 1977         | 1         |
| 2  | Fight Club             | 1996         | 2         |
| 3  | The Catcher in the Rye | 1951         | 3         |
| 4  | The Green Mile         | 1996         | 1         |
| 5  | Haunted                | 2005         | 2         |
| 6  | The Outsider           | 2018         | 1         |
| 7  | Lullaby                | 2002         | 2         |
| 8  | Franny and Zooey       | 1961         | 3         |
| 9  | Invisible Monsters     | 1999         | 2         |
| 10 | Dolores Claiborne      | 1993         | 1         |
+----+------------------------+--------------+-----------+
```

Первое поле этой таблицы содержит идентификатор книги, второе — название, третье — год выпуска, четвертое — идентификатор автора.

Схема базы данных

![09](/SQL_for_beginners/img/09_01.svg)

Скрипт для создания таблиц `Authors` и `Books`

```sql
DROP TABLE IF EXISTS Books;
DROP TABLE IF EXISTS Authors;

-- Создание таблицы Authors
CREATE TABLE Authors
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(40),
    surname VARCHAR(40)
);

INSERT INTO Authors (name, surname)
VALUES ('Stephen', 'King'),
       ('Chuck', 'Palahniuk'),
       ('Jerome', 'Salinger'),
       ('Leo', 'Tolstoy');

-- Создание таблицы Books
CREATE TABLE Books
(
    id           INT PRIMARY KEY AUTO_INCREMENT,
    title        VARCHAR(40),
    release_year INT,
    author_id    INT
);

INSERT INTO Books (title, release_year, author_id)
VALUES ('The Shining', 1977, 1),
       ('Fight Club', 1996, 2),
       ('The Catcher in the Rye', 1951, 3),
       ('The Green Mile', 1996, 1),
       ('Haunted', 2005, 2),
       ('The Outsider', 2018, 1),
       ('Lullaby', 2002, 2),
       ('Franny and Zooey', 1961, 3),
       ('Invisible Monsters', 1999, 2),
       ('Dolores Claiborne', 1993, 1);
```

<hr>

[Содержание](#содержание)

## Представления

**Представление** — это виртуальная таблица. В отличие от обычных таблиц, содержащих данные, представление содержит запрос, который динамически извлекает данные тогда, когда это необходимо. Представления можно использовать точно так же, как и обычные таблицы:
+ извлекать данные из них,
+ фильтровать и сортировать,
+ объединять с другими таблицами или представлениями.

Представления не содержат фактических данных, они извлекают их из других таблиц. Поэтому, если данные этих таблиц изменятся, изменится и содержимое связанных с ними представлений.

<hr>

[Содержание](#содержание)

## Создание представлений

Для создания представлений используется оператор `CREATE VIEW`, синтаксис которого имеет следующий вид:

```sql
CREATE VIEW <имя представления> AS
<извлекающий запрос>
```

Несложно заметить, что создание представления выполняется достаточно просто. Фактически от нас требуется лишь написать запрос, который определенным образом извлекает из таблиц базы данных нужную информацию, а также дать этому запросу имя.

Представления, как и таблицы, должны иметь уникальные имена. Они не могут быть названы так же, как другие таблицы или представления.

В качестве примера напишем запрос, создающий представление `FirstBooks`, которое включает информацию о первых трех книгах.

Результатом приведенного ниже запроса:

```sql
CREATE VIEW FirstBooks AS
SELECT *
FROM Books
LIMIT 3;

SELECT *
FROM FirstBooks;
```

является:

```
+----+------------------------+--------------+-----------+
| id | title                  | release_year | author_id |
+----+------------------------+--------------+-----------+
| 1  | The Shining            | 1977         | 1         |
| 2  | Fight Club             | 1996         | 2         |
| 3  | The Catcher in the Rye | 1951         | 3         |
+----+------------------------+--------------+-----------+
```

Запрос выше начинается с создания представления, которому дается имя `FirstBooks`, затем указывается содержимое этого представления — три первые записи таблицы `Books`. Завершается запрос извлечением всей информации, находящейся в представлении `FirstBooks`.

Несмотря на то, что представление в контексте запроса ведет себя как обычная таблица, оно на самом деле таковым не является. Каждое обращение к представлению приводит к выполнению соответствующего запроса.

Если в базе данных содержится некоторое представление, то при попытке создать представление с таким же именем произойдет ошибка. Чтобы ее избежать, можно воспользоваться расширенным оператором `CREATE OR REPLACE VIEW`. Данный оператор создаст представление только в том случае, если оно еще не существует. Если же представление с создаваемым именем существует, оно будет заменено новым.

Результатом приведенного ниже запроса:

```sql
CREATE VIEW FirstBooks AS
SELECT *
FROM Books
LIMIT 3;

CREATE OR REPLACE VIEW FirstBooks AS
SELECT *
FROM Books
LIMIT 5;

SELECT *
FROM FirstBooks;
```

является:

```
+----+------------------------+--------------+-----------+
| id | title                  | release_year | author_id |
+----+------------------------+--------------+-----------+
| 1  | The Shining            | 1977         | 1         |
| 2  | Fight Club             | 1996         | 2         |
| 3  | The Catcher in the Rye | 1951         | 3         |
| 4  | The Green Mile         | 1996         | 1         |
| 5  | Haunted                | 2005         | 2         |
+----+------------------------+--------------+-----------+
```

В данном примере сначала создается представление `FirstBooks`, которое включает три первые записи таблицы `Books`. Затем создается представление с тем же именем, которое включает пять первых записей таблицы `Books`. Второе создание представления `FirstBooks` выполняется с помощью оператора `CREATE OR REPLACE VIEW`, поэтому оно приводит не к ошибке, а к тому, что новое представление заменяет старое.

При определении представления нельзя использовать подзапрос в блоке оператора `FROM`.

<hr>

[Содержание](#содержание)

### Представления для упрощения запросов

Представления удобно использовать в том случае, когда из базы данных постоянно нужно извлекать одни и те же данные. Предположим, нам чаще всего приходится работать с информацией о книгах автора `Stephen King`. Это может быть получение названия самой поздней книги писателя или названий всех его книг в порядке их выпуска.

Очевидно, что все такие запросы будут иметь один общий фрагмент, в котором из таблицы Books извлекаются данные о книгах автора `Stephen King`:

```sql
SELECT title, release_year
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id
WHERE Authors.name = 'Stephen' and Authors.surname = 'King';
```

С помощью оператора `CREATE VIEW` мы можем преобразовать его в представление, скажем, с именем `StephenKingBooks`, чтобы в дальнейшем, вместо этого не самого маленького запроса, использовать одно говорящее имя.

Результатом приведенного ниже запроса:

```sql
CREATE VIEW StephenKingBooks AS
SELECT title, release_year
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id
WHERE Authors.name = 'Stephen' and surname = 'King';

SELECT *
FROM StephenKingBooks
ORDER BY release_year;
```

является:

```
+-------------------+--------------+
| title             | release_year |
+-------------------+--------------+
| The Shining       | 1977         |
| Dolores Claiborne | 1993         |
| The Green Mile    | 1996         |
| The Outsider      | 2018         |
+-------------------+--------------+
```

В примере выше извлекается информация о всех книгах автора `Stephen King` с дополнительной сортировкой по дате выхода, однако не напрямую из таблицы `Books`, а из представления `StephenKingBooks`, которое как раз и содержит все необходимые данные.

Результатом приведенного ниже запроса:

```sql
CREATE VIEW StephenKingBooks AS
SELECT title, release_year
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id
WHERE Authors.name = 'Stephen' and Authors.surname = 'King';

SELECT *
FROM StephenKingBooks
ORDER BY release_year DESC
LIMIT 1;
```

является:

```
+--------------+--------------+
| title        | release_year |
+--------------+--------------+
| The Outsider | 2018         |
+--------------+--------------+
```

Здесь из представления `StephenKingBooks` извлекается название самой поздней книги, написанной автором `Stephen King`.

<hr>

[Содержание](#содержание)

### Представления для форматирования данных

Представления могут быть полезны при частой необходимости извлекать данные в определенном формате. Например, в таблице `Books` информация об авторах книг не хранится в явном виде — указываются лишь их идентификаторы. Однако нам нередко может требоваться таблица, которая содержит как названия книг, так и их авторов. Для этого мы можем создать соответствующее представление и пользоваться им при необходимости получить данные в требуемом формате.

Результатом приведенного ниже запроса:

```sql
CREATE VIEW BooksInfo AS
SELECT title,
       CONCAT(Authors.name, ' ', Authors.surname) AS author
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;

SELECT *
FROM BooksInfo;
```

является:

```
+------------------------+-----------------+
| title                  | author          |
+------------------------+-----------------+
| The Shining            | Stephen King    |
| Fight Club             | Chuck Palahniuk |
| The Catcher in the Rye | Jerome Salinger |
| The Green Mile         | Stephen King    |
| Haunted                | Chuck Palahniuk |
| The Outsider           | Stephen King    |
| Lullaby                | Chuck Palahniuk |
| Franny and Zooey       | Jerome Salinger |
| Invisible Monsters     | Chuck Palahniuk |
| Dolores Claiborne      | Stephen King    |
+------------------------+-----------------+
```

Запрос выше создает представление `BooksInfo`, которое объединяет содержимое таблиц `Books` и `Authors`, беря из первой таблицы название книги, а из второй — информацию об авторе этой книги.

<hr>

[Содержание](#содержание)

## Изменение представлений

Запрос, который используется в представлении, может быть изменен. Для этого используется оператор `ALTER VIEW`, синтаксис которого имеет следующий вид:

```sql
ALTER VIEW <имя представления> AS
<новый извлекающий запрос>
```

В качестве примера использования данного оператора напишем запрос, создающий представление `FirstBooks`, которое включает три первые записи таблицы `Books`, а затем изменяющий созданное представление таким образом, чтобы оно включало пять первых записей.

Результатом приведенного ниже запроса:

```sql
CREATE VIEW FirstBooks AS
SELECT *
FROM Books
LIMIT 3;

ALTER VIEW FirstBooks AS
SELECT *
FROM Books
LIMIT 5;

SELECT *
FROM FirstBooks;
```

является: 

```
+----+------------------------+--------------+-----------+
| id | title                  | release_year | author_id |
+----+------------------------+--------------+-----------+
| 1  | The Shining            | 1977         | 1         |
| 2  | Fight Club             | 1996         | 2         |
| 3  | The Catcher in the Rye | 1951         | 3         |
| 4  | The Green Mile         | 1996         | 1         |
| 5  | Haunted                | 2005         | 2         |
+----+------------------------+--------------+-----------+
```

<hr>

[Содержание](#содержание)

## Удаление представлений

Представление может быть удалено. Для этого используется оператор `DROP VIEW`, синтаксис которого имеет следующий вид:

```sql
DROP VIEW <имя представления>
```

Предположим, в нашей базе данных содержится представление `FirstBooks` и мы хотим его удалить. Тогда запрос, выполняющий такую операцию, будет выглядеть следующим образом:

```sql
DROP VIEW FirstBooks;
```

При попытке удалить несуществующее представление произойдет ошибка. Если после оператора `DROP VIEW` указать ключевые слова `IF EXISTS`, удаление будет выполнено только в том случае, если представление существует.

<hr>

[Содержание](#содержание)

## Примечания 5

**Примечание 1.** Определить названия полей виртуальной таблицы можно не только в самом запросе с помощью псевдонимов, но и путем указания этих имен в скобках через запятую после названия представления.

Результатом приведенного ниже запроса:

```sql
CREATE VIEW BooksInfo (bookname, writer) AS
SELECT title,
       CONCAT(Authors.name, ' ', Authors.surname)
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;

SELECT *
FROM BooksInfo;
```

является:

```
+------------------------+-----------------+
| bookname               | writer          |
+------------------------+-----------------+
| The Shining            | Stephen King    |
| Fight Club             | Chuck Palahniuk |
| The Catcher in the Rye | Jerome Salinger |
| The Green Mile         | Stephen King    |
| Haunted                | Chuck Palahniuk |
| The Outsider           | Stephen King    |
| Lullaby                | Chuck Palahniuk |
| Franny and Zooey       | Jerome Salinger |
| Invisible Monsters     | Chuck Palahniuk |
| Dolores Claiborne      | Stephen King    |
+------------------------+-----------------+
```

**Примечание 2.** Представления могут быть вложенными. Это означает, что представление может быть создано посредством запроса, который извлекает данные из другого представления.

**Примечание 3.** Представления предназначены для извлечения данных, а не изменения, поэтому в большинстве случаев они являются неизменяемыми, и при попытке применить к представлениям операторы `INSERT`, `UPDATE` или `DELETE` произойдет ошибка. Однако если представление извлекает данные из единственной таблицы, причем извлекает их полностью, то такое представление изменить можно. Но важно понимать, что само представление не содержит никаких данных, поэтому все изменения будут применены к той таблице, с которой связано представление.

**Примечание 4.** С помощью представлений можно ограничивать доступ к данным, предоставляя пользователю или приложению права не на таблицу, а на представление. Также представления могут использоваться для обеспечения интерфейса обратной совместимости: если структура таблицы, с которой работало приложение, изменилась, с помощью представления можно смоделировать ее прежний вид.

**Примечание 5.** Несмотря на то, что операторы `ALTER VIEW` и `CREATE OR REPLACE VIEW` похожи, между ними есть важное отличие. Оператор `ALTER VIEW` изменяет существующее представление и завершается с ошибкой, если оно **не** существует. Оператор `CREATE OR REPLACE VIEW` создает новое представление, удаляя старое, если оно существует.

<hr>

[Содержание](#содержание)

# 9.6 Обобщенные табличные выражения. Часть 1

Урок посвящен обобщенным табличным выражениям и примерам их использования.

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из двух таблиц и содержит информацию о книгах, размещенных в некоторой электронной библиотеке.

Первая таблица. Информация об авторах книг располагается в таблице `Authors`, которая имеет следующий вид:

```
+----+---------+-----------+
| id | name    | surname   |
+----+---------+-----------+
| 1  | Stephen | King      |
| 2  | Chuck   | Palahniuk |
| 3  | Jerome  | Salinger  |
| 4  | Leo     | Tolstoy   |
+----+---------+-----------+
```

Первое поле этой таблицы содержит идентификатор автора, второе — имя, третье — фамилию.

Вторая таблица. Информация о размещенных в библиотеке книгах располагается в таблице `Books`, которая имеет следующий вид:

```
+----+------------------------+--------------+-----------+
| id | title                  | release_year | author_id |
+----+------------------------+--------------+-----------+
| 1  | The Shining            | 1977         | 1         |
| 2  | Fight Club             | 1996         | 2         |
| 3  | The Catcher in the Rye | 1951         | 3         |
| 4  | The Green Mile         | 1996         | 1         |
| 5  | Haunted                | 2005         | 2         |
| 6  | The Outsider           | 2018         | 1         |
| 7  | Lullaby                | 2002         | 2         |
| 8  | Franny and Zooey       | 1961         | 3         |
| 9  | Invisible Monsters     | 1999         | 2         |
| 10 | Dolores Claiborne      | 1993         | 1         |
+----+------------------------+--------------+-----------+
```

Первое поле этой таблицы содержит идентификатор книги, второе — название, третье — год выпуска, четвертое — идентификатор автора.

Схема базы данных

![09](/SQL_for_beginners/img/09_02.svg)

Скрипт для создания таблиц `Authors` и `Books`

```sql
DROP TABLE IF EXISTS Books;
DROP TABLE IF EXISTS Authors;

-- Создание таблицы Authors
CREATE TABLE Authors
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(40),
    surname VARCHAR(40)
);

INSERT INTO Authors (name, surname)
VALUES ('Stephen', 'King'),
       ('Chuck', 'Palahniuk'),
       ('Jerome', 'Salinger'),
       ('Leo', 'Tolstoy');

-- Создание таблицы Books
CREATE TABLE Books
(
    id           INT PRIMARY KEY AUTO_INCREMENT,
    title        VARCHAR(40),
    release_year YEAR,
    author_id    INT,
    FOREIGN KEY (author_id) REFERENCES Authors (id)
);

INSERT INTO Books (title, release_year, author_id)
VALUES ('The Shining', 1977, 1),
       ('Fight Club', 1996, 2),
       ('The Catcher in the Rye', 1951, 3),
       ('The Green Mile', 1996, 1),
       ('Haunted', 2005, 2),
       ('The Outsider', 2018, 1),
       ('Lullaby', 2002, 2),
       ('Franny and Zooey', 1961, 3),
       ('Invisible Monsters', 1999, 2),
       ('Dolores Claiborne', 1993, 1);
```

<hr>

[Содержание](#содержание)

## Обобщенные табличные выражения

Обобщенное табличное выражение или `CTE` (`Common Table Expressions`) — это временная таблица, к которой можно обращаться в рамках одного запроса. Для простоты `CTE` можно считать именованным подзапросом, который определен отдельно от основного запроса. Использование `CTE` позволяет писать сложные запросы в более читаемой форме путем их разбиения на небольшие логические шаги.

Для написания запросов с использованием `CTE` предназначен оператор `WITH`, синтаксис которого имеет следующий вид:

```sql
WITH <имя CTE> AS 
(
    <извлекающий запрос, определяющий содержимое CTE>
)

<основной запрос, который может обращаться к CTE>
```

Как видно из шаблона выше, для того чтобы воспользоваться `CTE`, ему необходимо дать имя, по которому к нему можно будет обращаться, а затем определить его содержимое. Обратите внимание, что определение `CTE` не отделяется от основного запроса точкой с запятой, поскольку вся конструкция (определение `CTE` и основной запрос) воспринимается как одно целое.

В качестве примера использования `CTE` напишем запрос, который среди всех книг за авторством `Stephen King` определяет ту, что была написана позже всех остальных.

Результатом приведенного ниже запроса:

```sql
WITH StephenKingBooks AS (
    SELECT title, release_year
    FROM Books INNER JOIN Authors ON Books.author_id = Authors.id
    WHERE Authors.name = 'Stephen' and Authors.surname = 'King' 
)

SELECT title
FROM StephenKingBooks
WHERE release_year = (SELECT MAX(release_year)
                      FROM StephenKingBooks);
```

является:

```
+--------------+
| title        |
+--------------+
| The Outsider |
+--------------+
```

Запрос выше начинается с определения `CTE` с именем `StephenKingBooks`, которое извлекает из таблицы Books информацию обо всех книгах за авторством `Stephen King`:

```
+-------------------+--------------+
| title             | release_year |
+-------------------+--------------+
| The Shining       | 1977         |
| The Green Mile    | 1996         |
| The Outsider      | 2018         |
| Dolores Claiborne | 1993         |
+-------------------+--------------+
```

Затем основной запрос извлекает из временной таблицы `StephenKingBooks` название той книги, которая имеет самый поздний год выхода, предварительно определяя этот год с помощью подзапроса. В данном примере `CTE` удобно тем, что позволяет вынести громоздкую операцию соединения таблиц из основного запроса, тем самым упростив его.

`CTE` является физической таблицей, которая перед выполнением основного запроса явно создается и помещается в оперативную память системы, пусть и на довольно небольшой промежуток времени.

В качестве дополнительного примера использования `CTE` напишем запрос, который среди всех книг за авторством `Stephen King` определяет ту, что была написана раньше всех остальных, а также ту, что была написана позже всех остальных.

Результатом приведенного ниже запроса:

```sql
WITH StephenKingBooks AS (
    SELECT title, release_year
    FROM Books INNER JOIN Authors ON Books.author_id = Authors.id
    WHERE Authors.name = 'Stephen' and Authors.surname = 'King' 
)

SELECT (SELECT title
        FROM StephenKingBooks
        WHERE release_year = (SELECT MIN(release_year)
                              FROM StephenKingBooks)) AS first_book,
       (SELECT title
        FROM StephenKingBooks
        WHERE release_year = (SELECT MAX(release_year)
                              FROM StephenKingBooks)) AS last_book;
```

является:

```
+-------------+--------------+
| first_book  | last_book    |
+-------------+--------------+
| The Shining | The Outsider |
+-------------+--------------+
```

В данном примере снова используется предложенное ранее `CTE` `StephenKingBooks`. Сперва основной запрос извлекает из `CTE` название самой ранней книги, затем — самой поздней, при этом в обоих случаях для определения нужной книги используется подзапрос.

Одним из основных способов использования `CTE` является создание подзапросов, которые используются в рамках основного запроса несколько раз, что позволяет избежать повторного написания одних и тех же подзапросов.

После оператора `WITH` допустимо определить не только одно `CTE`, но и несколько, для этого достаточно перечислить их определения через запятую.

Результатом приведенного ниже запроса:

```sql
WITH StephenKingBooks AS (
    SELECT title, release_year
    FROM Books INNER JOIN Authors ON Books.author_id = Authors.id
    WHERE Authors.name = 'Stephen' and Authors.surname = 'King' 
),
JeromeSalingerBooks AS (
    SELECT title, release_year
    FROM Books INNER JOIN Authors ON Books.author_id = Authors.id
    WHERE Authors.name = 'Jerome' and Authors.surname = 'Salinger' 
)

SELECT *
FROM StephenKingBooks

UNION 

SELECT *
FROM JeromeSalingerBooks;
```

является:

```
+------------------------+--------------+
| title                  | release_year |
+------------------------+--------------+
| The Shining            | 1977         |
| The Green Mile         | 1996         |
| The Outsider           | 2018         |
| Dolores Claiborne      | 1993         |
| The Catcher in the Rye | 1951         |
| Franny and Zooey       | 1961         |
+------------------------+--------------+
```

Здесь в блоке оператора `WITH` определяются два `CTE`, первое из которых содержит данные о книгах за авторством `Stephen King`, второе — за авторством `Jerome Salinger`. После основной запрос извлекает и объединяет содержимое обоих `CTE`.

Если блок `WITH` включает определение нескольких `CTE`, то их создание выполняется последовательно: сначала создается первое `CTE`, затем второе, и так далее. Таким образом, во время определения очередного `CTE`, все определенные ранее `CTE` уже являются созданными, поэтому каждое следующее определенное `CTE` может ссылаться на любое предыдущее.

Результатом приведенного ниже запроса:

```sql
WITH StephenKingBooks AS (
    SELECT title, release_year
    FROM Books INNER JOIN Authors ON Books.author_id = Authors.id
    WHERE Authors.name = 'Stephen' and Authors.surname = 'King'
),
StephenKingBooksReleasedIn1996 AS (
    SELECT title, release_year
    FROM StephenKingBooks
    WHERE release_year = 1996
)

SELECT *
FROM StephenKingBooksReleasedIn1996;
```

является:

```
+----------------+--------------+
| title          | release_year |
+----------------+--------------+
| The Green Mile | 1996         |
+----------------+--------------+
```

Здесь происходит создание двух `CTE`, причем второе извлекает данные из первого.

`CTE` является обычной таблицей, поэтому с ней допустимо выполнять любые необходимые операции: извлекать данные, фильтровать и сортировать, объединять с другими таблицами, представлениями или `CTE`.

<hr>

[Содержание](#содержание)

### Представления и CTE

Несмотря на сходство представлений и `CTE`, между ними есть важное различие. Представление является реальным объектом базы данных — виртуальной таблицей, которая определяется единожды, а затем повсеместно используется при необходимости. `CTE`, в свою очередь, является временной таблицей, которая привязывается к одному конкретному запросу и существует лишь в рамках этого запроса.

Представление является составляющей базы данных, `CTE` — составляющей одного запроса.

Также представление от `CTE` отличает то, что каждое обращение к представлению приводит к выполнению запроса, указанного при его определении. В случае с `CTE` такого не происходит, поскольку определение `CTE` влечет создание соответствующей таблицы, и все последующие операции с `CTE` выполняются как с обычной существующей таблицей.

<hr>

[Содержание](#содержание)

## Примечания 6

**Примечание 1.** Важно помнить, что `CTE` существует только в рамках того запроса, в котором он определен.

Во время выполнения приведенного ниже запроса:

```sql
WITH StephenKingBooks AS (
    SELECT title, release_year
    FROM Books INNER JOIN Authors ON Books.author_id = Authors.id
    WHERE Authors.name = 'Stephen' and Authors.surname = 'King'
)

SELECT *
FROM StephenKingBooks
LIMIT 1;

SELECT *
FROM StephenKingBooks
LIMIT 2;
```

второй извлекающий запрос завершится с ошибкой:

```
ERROR 1146: Table 'StephenKingBooks' doesn't exist
```

**Примечание 2.** Определить названия полей `CTE` можно не только в самом запросе с помощью псевдонимов, но и путем указания этих имен в скобках через запятую после названия `CTE`.

Результатом приведенного ниже запроса:

```sql
WITH FirstBooks (bookname, year) AS (
    SELECT title, release_year
    FROM Books
    LIMIT 3
)

SELECT *
FROM FirstBooks;
```

является:

```
+------------------------+------+
| bookname               | year |
+------------------------+------+
| The Shining            | 1977 |
| Fight Club             | 1996 |
| The Catcher in the Rye | 1951 |
+------------------------+------+
```

<hr>

[Содержание](#содержание)

# 9.7 Обобщенные табличные выражения. Часть 2

Урок посвящен рекурсивным обобщенным табличным выражениям и примерам их использования.

## Рекурсивные `CTE`

Рекурсивное обобщенное табличное выражение или рекурсивное `CTE` — это `CTE`, содержимое которого последовательно формируется на основе самого себя. Тело рекурсивного `CTE`, в отличие от обычного `CTE`, включает два извлекающих запроса. Первый запрос используется для однозначного определения содержимого первой записи `CTE`, второй — для определения правила формирования всех остальных записей.

Запрос, определяющий первую запись `CTE`, обычно называют нерекурсивным, а запрос, описывающий процесс получения всех остальных записей, — рекурсивным.

Содержимое каждой записи рекурсивного `CTE`, кроме первой, зависит только от содержимого предыдущей записи. Так, содержимое второй записи определяется на основе первой записи, содержимое третьей — на основе второй, и так далее. Например, если первая запись `CTE` включает число 1, а правило, определяющее оставшиеся записи `CTE`, имеет вид <значение предыдущей записи> + 1, то вторая запись будет включать число 2, третья — 3, и так далее.

Синтаксис создания рекурсивного `CTE` практически повторяет синтаксис создания обычного `CTE` и имеет следующий вид:

```sql
WITH RECURSIVE <имя CTE> AS (
    <извлекающий запрос, определяющий первую запись CTE>
    <пара ключевых слов UNION ALL или UNION DISTINCT>
    <извлекающий запрос, определяющий правило формирования очередной записи CTE (второй, третьей, и так далее)>
)

<основной запрос, который может обращаться к рекурсивному CTE>
```

Как видно из шаблона, для создания рекурсивного `CTE` перед его именем необходимо указать ключевое слово `RECURSIVE`, а затем предоставить два извлекающих запроса, связав их либо парой ключевых слов `UNION ALL`, либо `UNION DISTINCT`. При использовании связки ключевых слов `UNION ALL` `CTE` будет включать повторяющиеся записи, если при формировании такие возникнут. При использовании `UNION DISTINCT` все повторяющиеся записи будут удалены.

<hr>

[Содержание](#содержание)

## Примеры использования рекурсивных `CTE`

**Пример 1.** Напишем запрос, который генерирует последовательность из целых чисел от 1 до 10 включительно.

Результатом приведенного ниже запроса:

```sql
WITH RECURSIVE NaturalNumbers AS (
    SELECT 1 AS number                         -- нерекурсивный запрос
    UNION ALL
    SELECT number + 1                          -- рекурсивный  запрос
    FROM NaturalNumbers
    WHERE number < 10
)

SELECT *
FROM NaturalNumbers;
```

является:

```
+--------+
| number |
+--------+
| 1      |
| 2      |
| 3      |
| 4      |
| 5      |
| 6      |
| 7      |
| 8      |
| 9      |
| 10     |
+--------+
```

В примере выше генерация последовательности выполняется при помощи рекурсивного `CTE NaturalNumbers`, тело которого включает два запроса: нерекурсивный и рекурсивный. Нерекурсивный запрос определяет содержимое первой записи `CTE`. Рекурсивный запрос описывает правило формирования второй, третьей и всех последующих записей `CTE`. Поскольку содержимое `CTE` формируется на основе самого себя, извлечение в рекурсивном запросе выполняется из самого `CTE`.

Для понимания того, каким образом происходит выполнение рекурсивного запроса, рассмотрим формирование содержимого `CTE` пошагово. Сначала выполняется нерекурсивный запрос, который определяет начальное содержимое `CTE`:

```
+--------+
| number |
+--------+
| 1      |
+--------+
```

Затем выполняется рекурсивный запрос. Работая с результатом выполнения нерекурсивного запроса, он извлекает таблицу следующего вида:

```
+--------+
| number |
+--------+
| 2      |
+--------+
```

Данная таблица дополняет начальное содержимое `CTE`, после чего оно принимает следующий вид:

```
+--------+
| number |
+--------+
| 1      |
| 2      |
+--------+
```

Следом рекурсивный запрос выполняется снова, однако в этот раз он работает с той таблицей, которую извлек при предыдущем выполнении:

```
+--------+
| number |
+--------+
| 2      |
+--------+
```

Работая со своим предыдущим результатом, рекурсивный запрос извлекает таблицу следующего вида:

```
+--------+
| number |
+--------+
| 3      |
+--------+
```

Данная таблица дополняет текущее содержимое `CTE`, после чего оно принимает следующий вид:

```
+--------+
| number |
+--------+
| 1      |
| 2      |
| 3      |
+--------+
```

Аналогичным образом рекурсивный запрос будет дополнять содержимое `CTE` до тех пор, пока не вернет пустой результат. Поскольку рекурсивный запрос содержит условие `WHERE number < 10`, формирование содержимого `CTE` завершится в тот момент, когда второй запрос попытается сгенерировать запись с числом `11`.

Нерекурсивный и рекурсивный запросы в рекурсивном `CTE` должны извлекать таблицы с равным количеством полей.

**Пример 2.** Напишем запрос, который генерирует последовательность из первых десяти нечетных целых чисел.

Результатом приведенного ниже запроса:

```sql
WITH RECURSIVE OddNumbers AS (
    SELECT 1 AS number
    UNION ALL
    SELECT number + 2
    FROM OddNumbers
    LIMIT 10
)

SELECT *
FROM OddNumbers;  
```

является:

```
+--------+
| number |
+--------+
| 1      |
| 3      |
| 5      |
| 7      |
| 9      |
| 11     |
| 13     |
| 15     |
| 17     |
| 19     |
+--------+
```
Пример выше демонстрирует альтернативный способ завершения формирования содержимого `CTE` — с помощью ключевого слова `LIMIT`. При использовании данного ключевого слова рекурсивный запрос не обязан возвращать пустой результат, формирование содержимого `CTE` автоматически завершится в тот момент, когда сгенерированное количество записей станет равным числу, указанному после `LIMIT`. 

**Пример 3.** Напишем запрос, который генерирует последовательность из первых десяти степеней числа 2.

Результатом приведенного ниже запроса:

```sql
WITH RECURSIVE PowersOfTwo AS (
    SELECT 1 AS degree,                        -- показатель степени
           2 AS power                          -- значение в соответствующей степени
    UNION ALL
    SELECT degree + 1,                         -- увеличиваем показатель степени на единицу
           power * 2                           -- возводим число в следующую степень
    FROM PowersOfTwo
    LIMIT 10
)

SELECT *
FROM PowersOfTwo;
```

является:

```
+--------+-------+
| degree | power |
+--------+-------+
| 1      | 2     |
| 2      | 4     |
| 3      | 8     |
| 4      | 16    |
| 5      | 32    |
| 6      | 64    |
| 7      | 128   |
| 8      | 256   |
| 9      | 512   |
| 10     | 1024  |
+--------+-------+
```

**Пример 4.** Напишем запрос, который генерирует последовательность из первых десяти чисел Фибоначчи.

Результатом приведенного ниже запроса:

```sql
WITH RECURSIVE Fibonacci AS (
    SELECT 1 AS fib_prev,                      -- предыдущее число Фибоначии
           1 AS fib_cur                        -- текущее число Фибоначии
    UNION ALL  
    SELECT fib_cur,                            -- заменяем предыдущее число текущим
           fib_cur + fib_prev                  -- прибавляем к текущему числу предыдущее
    FROM Fibonacci
    LIMIT 10
)

SELECT fib_prev AS number
FROM Fibonacci;
```

является:

```
+--------+
| number |
+--------+
| 1      |
| 1      |
| 2      |
| 3      |
| 5      |
| 8      |
| 13     |
| 21     |
| 34     |
| 55     |
+--------+
```

<hr>

[Содержание](#содержание)

## Примечания 7

**Примечание 1.** Если при определении рекурсивного `CTE` пропустить ключевое слово `RECURSIVE`, произойдет ошибка.

Результатом приведенного ниже запроса:

```sql
WITH NaturalNumbers AS (                       -- ключевое слово RECURSIVE не указано
    SELECT 1 AS number
    UNION ALL
    SELECT number + 1                          
    FROM NaturalNumbers
    WHERE number < 10
)

SELECT *
FROM NaturalNumbers;
```

является ошибка:

```
ERROR 1146: Table 'NaturalNumbers' doesn't exist
```

Если при определении нерекурсивного `CTE` указать ключевое слово `RECURSIVE`, ошибки не будет.

Результатом приведенного ниже запроса:

```sql
WITH RECURSIVE NaturalNumbers AS (             -- ключевое слово RECURSIVE указано
    SELECT 1 AS number
    UNION ALL
    SELECT 2                          
)

SELECT *
FROM NaturalNumbers;
```

является:

```
+--------+
| number |
+--------+
| 1      |
| 2      |
+--------+
```

**Примечание 2.** В рекурсивном запросе рекурсивного `CTE` не могут использоваться агрегатные функции, а также операторы `GROUP BY`, `ORDER BY` и `DISTINCT`.

**Примечание 3.** Определить названия полей рекурсивного `CTE` можно не только в самом запросе с помощью псевдонимов, но и путем указания этих имен в скобках через запятую после названия `CTE`.

Результатом приведенного ниже запроса:

```sql
WITH RECURSIVE PowersOfTwo(degree, power) AS (
    SELECT 1,                                  -- поле degree
           2                                   -- поле power
    UNION ALL
    SELECT degree + 1,
           power * 2
    FROM PowersOfTwo
    LIMIT 10
)

SELECT *
FROM PowersOfTwo;
```

является:

```
+--------+-------+
| degree | power |
+--------+-------+
| 1      | 2     |
| 2      | 4     |
| 3      | 8     |
| 4      | 16    |
| 5      | 32    |
| 6      | 64    |
| 7      | 128   |
| 8      | 256   |
| 9      | 512   |
| 10     | 1024  |
+--------+-------+
```

**Примечание 4.** Типы данных полей рекурсивного `CTE` определяются в нерекурсивном запросе. Об этом полезно помнить в том случае, когда `CTE` имеет строковое поле, поскольку в рекурсивном запросе могут происходить попытки добавить в поле строки, длина которых превышает поддерживаемые полем значения.

Результатом приведенного ниже запроса:

```sql
WITH RECURSIVE Beegeek AS (
    SELECT 'bee' AS field                      -- трехсимвольное строковое поле
    UNION ALL
    SELECT CONCAT(field, field)
    FROM Beegeek
    LIMIT 5
)

SELECT *
FROM Beegeek;
```

является ошибка:

```
ERROR 1406: Data too long for column 'field' at row 1
```

В примере выше тип данных поля `field` рекурсивного `CTE Beegeek` определяется как строковое и трехсимвольное, потому что значение именно такого формата добавляется в поле первым. Последующие попытки добавить в поле `field` новые строки приводят к ошибке, поскольку их длина больше трех.

Для решения данной проблемы перед добавлением значения в поле `field` можно сконвертировать его в более широкий тип, например, с помощью функции `CONVERT()`.

Результатом приведенного ниже запроса:

```sql
WITH RECURSIVE Beegeek AS (
    SELECT CONVERT('bee', CHAR(50)) AS field   -- пятидесяти символьное строковое поле
    UNION ALL
    SELECT CONCAT(field, field)
    FROM Beegeek
    LIMIT 5
)

SELECT *
FROM Beegeek;
```

является:

```
+--------------------------------------------------+
| field                                            |
+--------------------------------------------------+
| bee                                              |
| beebee                                           |
| beebeebeebee                                     |
| beebeebeebeebeebeebeebee                         |
| beebeebeebeebeebeebeebeebeebeebeebeebeebeebeebee |
+--------------------------------------------------+
```

**Примечание 5.** По умолчанию рекурсивный запрос в рекурсивном `CTE` может выполнить не более 1000 итераций.

Результатом приведенного ниже запроса:

```sql
WITH RECURSIVE NaturalNumbers AS (
    SELECT 1 AS number
    UNION ALL
    SELECT number + 1
    FROM NaturalNumbers
    LIMIT 2000                                 -- ограничение в 2000 записей
)

SELECT *
FROM NaturalNumbers;
```

является ошибка:

```
ERROR 3636: Recursive query aborted after 1001 iterations. Try increasing @@cte_max_recursion_depth to a larger value.
```

Увеличив значение системной переменной `cte_max_recursion_depth`, отвечающей за максимально допустимое количество итераций рекурсивного запроса, данное ограничение можно обойти.

Результатом приведенного ниже запроса:

```sql
SET @@cte_max_recursion_depth := 10000;

WITH RECURSIVE NaturalNumbers AS (
    SELECT 1 AS number
    UNION ALL
    SELECT number + 1
    FROM NaturalNumbers
    LIMIT 2000
)

SELECT *
FROM NaturalNumbers;
```

является (результат обрезан):

```
+--------+
| number |
+--------+
| 1      |
| 2      |
| 3      |
| 4      |
| 5      |
| ...    |
| 1996   |
| 1997   |
| 1998   |
| 1999   |
| 2000   |
+--------+
```

**Примечание 6.** Доступ к полям в рекурсивном запросе рекурсивного `CTE` осуществляется по имени, а не по положению.

Результатом приведенного ниже запроса:

```sql
WITH RECURSIVE Numbers AS (
    SELECT 1 AS a,                             -- начальное значение первого поля
           -1 AS b                             -- начальное значение второго поля
    UNION ALL
    SELECT b * 2,                              -- значение первого поля берется из второго поля и умножается на 2
           a * 2                               -- значение второго поля берется из первого поля и умножается на 2
    FROM Numbers
    LIMIT 5
)

SELECT *
FROM Numbers;
```

является:

```
+----+-----+
| a  | b   |
+----+-----+
| 1  | -1  |
| -2 | 2   |
| 4  | -4  |
| -8 | 8   |
| 16 | -16 |
+----+-----+
```

**Примечание 7.** Нерекурсивный запрос в рекурсивном `CTE` может извлекать не только одну запись, но и несколько. В таком случае формирование содержимого `CTE` будет выполняться блоками по несколько записей.

Результатом приведенного ниже запроса:

```sql
WITH RECURSIVE Numbers AS (
    SELECT 1 AS number
    UNION
    SELECT 2
    
    UNION ALL
    
    SELECT number + 1
    FROM Numbers
    LIMIT 10
)

SELECT *
FROM Numbers;
```

является:

```
+--------+
| number |
+--------+
| 1      |
| 2      |
| 2      |
| 3      |
| 3      |
| 4      |
| 4      |
| 5      |
| 5      |
| 6      |
+--------+
```

Здесь нерекурсивный запрос определяет начальное содержимое `CTE` следующим образом:

```
+--------+
| number |
+--------+
| 1      |
| 2      |
+--------+
```

Затем рекурсивный запрос, работая с результатом выполнения нерекурсивного запроса, извлекает таблицу следующего вида:

```
+--------+
| number |
+--------+
| 2      |
| 3      |
+--------+
```

Данная таблица дополняет начальное содержимое `CTE`, после чего оно принимает следующий вид:

```
+--------+
| number |
+--------+
| 1      |
| 2      |
| 2      |
| 3      |
+--------+
```

Аналогичным образом рекурсивный запрос дополняет содержимое `CTE` до тех пор, пока количество записей в нем не станет равным 10.

<hr>

[Содержание](#содержание)

# 9.8 Обобщенные табличные выражения. Часть 3

Урок посвящен примерам использования рекурсивных CTE для обработки иерархических данных.

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем Employees, которая содержит информацию о сотрудниках некоторой компании:

```
+----+----------+--------------+------------+
| id | name     | job          | manager_id |
+----+----------+--------------+------------+
| 1  | Matthew  | CEO          | NULL       |
| 2  | Caroline | CFO          | 1          |
| 3  | Tom      | CTO          | 1          |
| 4  | Sam      | Treasurer    | 2          |
| 5  | Ann      | Controller   | 2          |
| 6  | Anthony  | Dev Director | 3          |
| 7  | Lousie   | Sys Admin    | 3          |
| 8  | Travis   | Senior DBA   | 3          |
| 9  | John     | Developer    | 6          |
| 10 | Jennifer | Developer    | 6          |
| 11 | Maria    | Junior DBA   | 8          |
+----+----------+--------------+------------+
```

Первое поле этой таблицы содержит идентификатор сотрудника, второе — имя, третье -- должность, четвертое — идентификатор руководителя (также является сотрудником). Если у сотрудника нет руководителя, значением поля `manager_id` является `NULL`.

Скрипт для создания таблицы `Employees`

```sql
DROP TABLE IF EXISTS Employees;
CREATE TABLE Employees
(
    id INT PRIMARY KEY,
    name VARCHAR(20),
    job VARCHAR(20),
    manager_id INT
);

INSERT INTO Employees
VALUES (1, 'Matthew', 'CEO', NULL),
       (2, 'Caroline', 'CFO', 1),
       (3, 'Tom', 'CTO', 1),
       (4, 'Sam', 'Treasurer', 2),
       (5, 'Ann', 'Controller', 2),
       (6, 'Anthony', 'Dev Director', 3),
       (7, 'Lousie', 'Sys Admin', 3),
       (8, 'Travis', 'Senior DBA', 3),
       (9, 'John', 'Developer', 6),
       (10 ,'Jennifer', 'Developer', 6),
       (11 ,'Maria', 'Junior DBA', 8);
```

<hr>

[Содержание](#содержание)

## Обработка иерархических данных

Данные в таблицах базы данных могут иметь совершенно произвольную структуру, и нередко — иерархическую. Примером таблицы с подобной организацией данных является таблица `Employees`, иерархия в которой выстраивается путем установления отношений руководитель-подчиненный между представленными в таблице сотрудниками.

Наиболее наглядно предложенная иерархия продемонстрирована на картинке ниже:

![09](/SQL_for_beginners/img/09_03.webp)

Как видно из картинки, любой сотрудник может иметь ряд подчиненных, которые, в свою очередь, могут иметь своих подчиненных. Например, сотрудница по имени `Caroline` имеет в подчинении двух сотрудников: `Sam` и `Ann`. Более того, `Caroline` сама является подчиненной сотрудника по имени `Matthew`.

Во время работы с подобного вида иерархическими данными достаточно удобными оказываются рекурсивные `CTE`. В качестве примера их использования напишем запрос, который определяет, на какой иерархической ступени располагается каждый сотрудник. Будем считать, что сотрудник, находящийся на вершине иерархии, занимает первую ступень, его подчиненные — вторую, и так далее.

Результатом приведенного ниже запроса:

```sql
WITH RECURSIVE EmployeeHierarchy AS (
    SELECT id, name, 1 AS level
    FROM Employees
    WHERE manager_id IS NULL

    UNION ALL

    SELECT Employees.id, Employees.name, EmployeeHierarchy.level + 1
    FROM EmployeeHierarchy INNER JOIN Employees ON EmployeeHierarchy.id = Employees.manager_id
)

SELECT *
FROM EmployeeHierarchy;
```

является:

```
+----+----------+-------+
| id | name     | level |
+----+----------+-------+
| 1  | Matthew  | 1     |
| 2  | Caroline | 2     |
| 3  | Tom      | 2     |
| 4  | Sam      | 3     |
| 5  | Ann      | 3     |
| 6  | Anthony  | 3     |
| 7  | Lousie   | 3     |
| 8  | Travis   | 3     |
| 9  | John     | 4     |
| 10 | Jennifer | 4     |
| 11 | Maria    | 4     |
+----+----------+-------+
```

Проводя аналогию результата запроса с приведенной ранее картинкой, хорошо видно, что сотрудник по имени `Matthew` находится на первой иерархической ступени, его подчиненные `Caroline` и `Tom` — на второй, сотрудники `Sam`, `Ann`, `Anthony`, `Lousie` и `Travis`, являющиеся подчиненными `Caroline` или `Tom`, — на третьей, а `John`, `Jennifer` и `Maria` — на четвертой.

Теперь подробнее рассмотрим то, как именно получается данный результат. Тело используемого в примере рекурсивного `CTE` начинается с нерекурсивного запроса, который определяет сотрудника, находящегося на первой иерархической ступени. Таким сотрудником считается сотрудник, располагающийся на вершине иерархии и не имеющий руководителя. Затем следует рекурсивный запрос, с помощью которого определяется иерархическая принадлежность всех оставшихся сотрудников.

Для понимания того, каким образом происходит выполнение рекурсивного запроса, рассмотрим формирование содержимого `CTE` пошагово. Сначала выполняется нерекурсивный запрос, который определяет начальное содержимое `CTE`:

```
+----+----------+-------+
| id | name     | level |
+----+----------+-------+
| 1  | Matthew  | 1     |
+----+----------+-------+
```

Затем выполняется рекурсивный запрос. В нем происходит внутреннее соединение результата выполнения нерекурсивного запроса и таблицы `Employees` с условием равенства полей `id` и `manager_id`, итогом которого является следующая таблица:

```
+----+---------+-------+----+----------+-----+------------+
| id | name    | level | id | name     | job | manager_id |
+----+---------+-------+----+----------+-----+------------+
| 1  | Matthew | 1     | 2  | Caroline | CFO | 1          |
| 1  | Matthew | 1     | 3  | Tom      | CTO | 1          |
+----+---------+-------+----+----------+-----+------------+
```

Задача этого соединения заключается в том, чтобы отобрать из таблицы `Employees` сотрудников, являющихся подчиненными сотрудника, находящего на первой ступени иерархии: отобранные сотрудники будут считаться сотрудниками второй ступени.

Далее рекурсивный запрос, работая с результатом соединения, извлекает таблицу следующего вида:

```
+----+----------+-------+
| id | name     | level |
+----+----------+-------+
| 2  | Caroline | 2     |
| 3  | Tom      | 2     |
+----+----------+-------+
```

Данная таблица дополняет текущее содержимое `CTE`, после чего оно принимает следующий вид:

```
+----+----------+-------+
| id | name     | level |
+----+----------+-------+
| 1  | Matthew  | 1     |
| 2  | Caroline | 2     |
| 3  | Tom      | 2     |
+----+----------+-------+
```

Следом рекурсивный запрос выполняется снова, однако в этот раз он работает с той таблицей, которую извлек при предыдущем выполнении:

```
+----+----------+-------+
| id | name     | level |
+----+----------+-------+
| 2  | Caroline | 2     |
| 3  | Tom      | 2     |
+----+----------+-------+
```

В рекурсивном запросе происходит внутреннее соединение данной таблицы с таблицей `Employees` с тем же условием равенства полей `id` и `manager_id`, итогом которого является следующая таблица:

```
+----+----------+-------+----+---------+--------------+------------+
| id | name     | level | id | name    | job          | manager_id |
+----+----------+-------+----+---------+--------------+------------+
| 2  | Caroline | 2     | 4  | Sam     | Treasurer    | 2          |
| 2  | Caroline | 2     | 5  | Ann     | Controller   | 2          |
| 3  | Tom      | 2     | 6  | Anthony | Dev Director | 3          |
| 3  | Tom      | 2     | 7  | Lousie  | Sys Admin    | 3          |
| 3  | Tom      | 2     | 8  | Travis  | Senior DBA   | 3          |
+----+----------+-------+----+---------+--------------+------------+
```

Задача этого соединения заключается в том, чтобы отобрать из таблицы `Employees` сотрудников, являющихся подчиненными сотрудников, находящихся на второй ступени иерархии: отобранные сотрудники будут считаться сотрудниками третьей ступени.

Далее рекурсивный запрос, работая с результатом соединения, извлекает таблицу следующего вида:

```
+----+---------+-------+
| id | name    | level |
+----+---------+-------+
| 4  | Sam     | 3     |
| 5  | Ann     | 3     |
| 6  | Anthony | 3     |
| 7  | Lousie  | 3     |
| 8  | Travis  | 3     |
+----+---------+-------+
```

Данная таблица дополняет текущее содержимое `CTE`, после чего оно принимает следующий вид:

```
+----+----------+-------+
| id | name     | level |
+----+----------+-------+
| 1  | Matthew  | 1     |
| 2  | Caroline | 2     |
| 3  | Tom      | 2     |
| 4  | Sam      | 3     |
| 5  | Ann      | 3     |
| 6  | Anthony  | 3     |
| 7  | Lousie   | 3     |
| 8  | Travis   | 3     |
+----+----------+-------+
```

Аналогичным образом рекурсивный запрос будет дополнять содержимое `CTE` до тех пор, пока не вернет пустой результат. Поскольку рекурсивный запрос на каждом этапе выполняет соединение таблиц для поиска подчиненных определенных сотрудников, формирование содержимого `CTE` завершится в тот момент, когда рекурсивный запрос попытается найти подчиненных у тех сотрудников, у которых их нет.

Помните, что в рекурсивном `CTE` рекурсивный запрос при втором и последующих вызовах работает с результатом, который был получен им же при предыдущем вызове.

В качестве следующего примера напишем запрос, который определяет иерархический путь до каждого сотрудника.

Результатом приведенного ниже запроса:

```sql
WITH RECURSIVE EmployeeHierarchy AS (
    SELECT id, name,
           CONVERT(name, CHAR(100)) AS path
    FROM Employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    SELECT Employees.id, Employees.name,
           CONCAT(EmployeeHierarchy.path , ' -> ', Employees.name)
    FROM EmployeeHierarchy INNER JOIN Employees ON EmployeeHierarchy.id = Employees.manager_id
)
    
SELECT *
FROM EmployeeHierarchy;
```

является:

```
+----+----------+---------------------------------------+
| id | name     | path                                  |
+----+----------+---------------------------------------+
| 1  | Matthew  | Matthew                               |
| 2  | Caroline | Matthew -> Caroline                   |
| 3  | Tom      | Matthew -> Tom                        |
| 4  | Sam      | Matthew -> Caroline -> Sam            |
| 5  | Ann      | Matthew -> Caroline -> Ann            |
| 6  | Anthony  | Matthew -> Tom -> Anthony             |
| 7  | Lousie   | Matthew -> Tom -> Lousie              |
| 8  | Travis   | Matthew -> Tom -> Travis              |
| 9  | John     | Matthew -> Tom -> Anthony -> John     |
| 10 | Jennifer | Matthew -> Tom -> Anthony -> Jennifer |
| 11 | Maria    | Matthew -> Tom -> Travis -> Maria     |
+----+----------+---------------------------------------+
```

Используемое в данном примере рекурсивное `CTE` практически повторяет предыдущее, разница заключается лишь в третьем поле `path`. Для каждого сотрудника в этом поле указывается его имя, а также имена всех руководителей в его иерархической цепи.

Не забывайте, что типы данных полей рекурсивного `CTE` определяются в нерекурсивном запросе.

<hr>

[Содержание](#содержание)