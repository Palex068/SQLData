# 11. Оконные функции

## Содержание

+ [11.1 Ранжирующие функции. Часть 1](#111-ранжирующие-функции-часть-1)
    + [Результирующий набор](#результирующий-набор)
    + [Оконные функции и окна](#оконные-функции-и-окна)
    + [Ранжирующие функции](#ранжирующие-функции)
    + [Функция `ROW_NUMBER()`](#функция-row_number)
+ [11.2 Ранжирующие функции. Часть 2](#112-ранжирующие-функции-часть-2)
    + [Функции `DENSE_RANK()` и `RANK()`](#функции-dense_rank-и-rank)
    + [Функция `NTILE()`](#функция-ntile)
+ [11.3 Агрегатные функции](#113-агрегатные-функции)
    + [Агрегатные функции](#агрегатные-функции)
    + [Функции `AVG()` и `SUM()`](#функции-avg-и-sum)
    + [Функция `COUNT()`](#функция-count)
    + [Функции `MIN()` и `MAX()`](#функции-min-и-max)
+ [11.4 Границы окон](#114-границы-окон)
    + [Определение границ окна](#определение-границ-окна)
    + [Оператор `ROWS`](#оператор-rows)
        + [Примеры определения границ окна с помощью оператора `ROWS`](#примеры-определения-границ-окна-с-помощью-оператора-rows)
        + [Примеры использования оператора `ROWS`](#примеры-использования-оператора-rows)
    + [Оператор `RANGE`](#оператор-range)
+ [11.5 Функции смещения](#115-функции-смещения)
    + [Функция `FIRST_VALUE()`](#функция-first_value)
    + [Функция `LAST_VALUE()`](#функция-last_value)
    + [Функция `NTH_VALUE()`](#функция-nth_value)
    + [Функция `LAG()`](#функция-lag)
    + [Функция `LEAD()`](#функция-lead)
+ [11.6 Решение задач](#116-решение-задач)
    + [Третьи поездки в такси](#третьи-поездки-в-такси)

[Оглавление](/SQL_for_beginners/README.MD)

# 11.1 Ранжирующие функции. Часть 1

Урок посвящен ранжирующим оконным функциям.

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем `Employees`, которая содержит информацию о сотрудниках некоторой компании:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 1  | Sergey Brin     | Engineering | 10000  |
| 2  | John Doerr      | Sales       | 10000  |
| 3  | Larry Page      | Engineering | 7000   |
| 4  | Eric Schmidt    | Marketing   | 8000   |
| 5  | Sundar Pichai   | Sales       | 11000  |
| 6  | Marissa Mayer   | Marketing   | 9000   |
| 7  | Susan Wojcicki  | Engineering | 8000   |
| 8  | John Smith      | Engineering | 7000   |
| 9  | Sheryl Sandberg | Marketing   | 9000   |
| 10 | Alice Johnson   | Engineering | 10000  |
+----+-----------------+-------------+--------+
```

Первое поле этой таблицы содержит идентификатор сотрудника, второе — полное имя (имя и фамилия), третье — название отдела, в котором работает сотрудник, четвертое — зарплату в неизвестной валюте.

Скрипт для создания таблицы `Employees`

```sql
DROP TABLE IF EXISTS Employees;
CREATE TABLE Employees (
    id INT PRIMARY KEY,
    full_name VARCHAR(255),
    department VARCHAR(50),
    salary INT
);

INSERT INTO Employees (id, full_name, department, salary)
VALUES (1, 'Sergey Brin', 'Engineering', 10000),
       (2, 'John Doerr', 'Sales', 10000),
       (3, 'Larry Page', 'Engineering', 7000),
       (4, 'Eric Schmidt', 'Marketing', 8000),
       (5, 'Sundar Pichai', 'Sales', 11000),
       (6, 'Marissa Mayer', 'Marketing', 9000),
       (7, 'Susan Wojcicki', 'Engineering', 8000),
       (8, 'John Smith', 'Engineering', 7000),
       (9, 'Sheryl Sandberg', 'Marketing', 9000),
       (10, 'Alice Johnson', 'Engineering', 10000);
```

<hr>

[Содержание](#содержание)

## Результирующий набор

Важным термином в изучении оконных функций является **результирующий набор**. Он представляет собой таблицу, которая формируется извлекающим запросом в результате выполнения следующих операций (некоторые являются опциональными):
+ соединение (`JOIN`),
+ извлечение (`FROM`),
+ фильтрация (`WHERE`),
+ группировка (`GROUP BY`) и
+ фильтрация групп (`HAVING`).

Например, результирующим набором приведенного ниже запроса:

```sql
SELECT full_name AS engineer
FROM Employees
WHERE department = 'Engineering'
LIMIT 3;
```

является:

```
+----+----------------+-------------+--------+
| id | full_name      | department  | salary |
+----+----------------+-------------+--------+
| 1  | Sergey Brin    | Engineering | 10000  |
| 3  | Larry Page     | Engineering | 7000   |
| 7  | Susan Wojcicki | Engineering | 8000   |
| 8  | John Smith     | Engineering | 7000   |
| 10 | Alice Johnson  | Engineering | 10000  |
+----+----------------+-------------+--------+
```

Обратите внимание, что результирующий набор и результат запроса — это не одно и то же. Результат запроса формируется на основе результирующего набора в результате выполнения следующих операций (некоторые являются опциональными): выборка (`SELECT`), присвоение псевдонимов (`AS`), сортировка (`ORDER BY`) и ограничение количества записей (`LIMIT`).

Записи в результирующем наборе могут располагаться в **произвольном порядке**.

<hr>

[Содержание](#содержание)

## Оконные функции и окна

**Оконная функция** — это функция, которая выполняет вычисления на основе определенного набора записей и возвращает одиночное значение. Набор записей, с которым работает оконная функция, называют **окном**. По умолчанию содержимое окна полностью совпадает с результирующим набором запроса, в рамках которого определено окно.

Определение окна выполняется с помощью оператора `WINDOW`, синтаксис использования которого имеет следующий вид:

```sql
WINDOW <название окна> AS (<спецификация окна>)
```

Определение окна в рамках запроса выполняется после группировки (или фильтрации групп) и до сортировки, поэтому оператор `WINDOW` в запросе располагается после оператора `GROUP BY` (или `HAVING`) и до оператора `ORDER BY`.

Спецификация окна, заключаемая в круглые скобки, может включать три базовых элемента:
+ секционирование (разбиение на секции),
+ упорядочивание и
+ определение границ окна. 

Подробнее элементы спецификации мы рассмотрим позже, а пока лишь отметим, что если ни один из них не указан, то содержимое окна будет сформировано по умолчанию.

Например, в рамках приведенного ниже запроса:

```sql
SELECT full_name AS engineer
FROM Employees
WHERE department = 'Engineering'
WINDOW all_rows AS ()
LIMIT 3;
```

определяется окно с именем `all_rows`, содержимое которого имеет следующий вид:

```
+----+----------------+-------------+--------+
| id | full_name      | department  | salary |
+----+----------------+-------------+--------+
| 1  | Sergey Brin    | Engineering | 10000  |
| 3  | Larry Page     | Engineering | 7000   |
| 7  | Susan Wojcicki | Engineering | 8000   |
| 8  | John Smith     | Engineering | 7000   |
| 10 | Alice Johnson  | Engineering | 10000  |
+----+----------------+-------------+--------+
```

Окно существует независимо от результирующего набора и всего лишь определяет свое содержимое на его основе.

<hr>

[Содержание](#содержание)

## Ранжирующие функции

Оконные функции обычно подразделяют на три основные группы:
+ **ранжирующие функции**,
+ **агрегатные функции** и
+ **функции смещения**. 

В этом и следующем уроках мы рассмотрим функции первой группы, основное назначение которых заключается в присвоении порядковых номеров и составлении всевозможных рейтингов.

<hr>

[Содержание](#содержание)

## Функция 'ROW_NUMBER()'

Функция `ROW_NUMBER()` вычисляет порядковый номер записи в рамках указанного окна (начиная с 1). В качестве примера ее использования напишем запрос, который извлекает полные имена всех сотрудников, а также дополнительно их пронумеровывает.

Результатом приведенного ниже запроса:

```sql
SELECT full_name,
       ROW_NUMBER() OVER all_rows AS row_num
FROM Employees
WINDOW all_rows AS ();
```

является:

```
+-----------------+---------+
| full_name       | row_num |
+-----------------+---------+
| Sergey Brin     | 1       |
| John Doerr      | 2       |
| Larry Page      | 3       |
| Eric Schmidt    | 4       |
| Sundar Pichai   | 5       |
| Marissa Mayer   | 6       |
| Susan Wojcicki  | 7       |
| John Smith      | 8       |
| Sheryl Sandberg | 9       |
| Alice Johnson   | 10      |
+-----------------+---------+
```
`
Итак, запрос выше включает определение окна с именем `all_rows`. Данное окно имеет пустую спецификацию, поэтому его содержимое полностью совпадает с результирующим набором:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 1  | Sergey Brin     | Engineering | 10000  |
| 2  | John Doerr      | Sales       | 10000  |
| 3  | Larry Page      | Engineering | 7000   |
| 4  | Eric Schmidt    | Marketing   | 8000   |
| 5  | Sundar Pichai   | Sales       | 11000  |
| 6  | Marissa Mayer   | Marketing   | 9000   |
| 7  | Susan Wojcicki  | Engineering | 8000   |
| 8  | John Smith      | Engineering | 7000   |
| 9  | Sheryl Sandberg | Marketing   | 9000   |
| 10 | Alice Johnson   | Engineering | 10000  |
+----+-----------------+-------------+--------+
```

Записи в окне `all_rows`, как и в результирующем наборе, могут располагаться в произвольном порядке, однако в данном случае они располагаются в том же порядке, что и в таблице `Employees`.

Запись `ROW_NUMBER() OVER all_rows` означает применение функции `ROW_NUMBER()` к окну `all_rows`. Запись состоит из вызова оконной функции, ключевого слова `OVER` и имени окна, к которому должна быть применена функция.

Для каждой рассматриваемой извлекающим запросом записи функция `ROW_NUMBER()` определяет ее порядковый номер в рамках окна `all_rows` и возвращает полученный результат, который затем указывается в поле `row_num`. Например, если извлекающий запрос рассматривает первую запись таблицы `Employees` (`id = 1`), то для такой записи вызов функции `ROW_NUMBER()` по отношению к окну `all_rows` вернет значение `1`, поскольку в окне `all_rows` эта запись располагается на первом месте.

Определение порядкового номера записи в рамках окна, в котором не определен строгий порядок, не имеет большого смысла. Поэтому воспользуемся одним из элементов спецификации окна — упорядочиванием, и напишем запрос, который извлекает полные имена и зарплаты всех сотрудников, а также дополнительно пронумеровывает их в порядке уменьшения зарплаты.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, salary,
       ROW_NUMBER() OVER salary_desc AS row_num
FROM Employees
WINDOW salary_desc AS (ORDER BY salary DESC);
```

является:

```
+-----------------+--------+---------+
| full_name       | salary | row_num |
+-----------------+--------+---------+
| Sundar Pichai   | 11000  | 1       |
| Sergey Brin     | 10000  | 2       |
| John Doerr      | 10000  | 3       |
| Alice Johnson   | 10000  | 4       |
| Marissa Mayer   | 9000   | 5       |
| Sheryl Sandberg | 9000   | 6       |
| Eric Schmidt    | 8000   | 7       |
| Susan Wojcicki  | 8000   | 8       |
| Larry Page      | 7000   | 9       |
| John Smith      | 7000   | 10      |
+-----------------+--------+---------+
```

Несложно заметить, что упорядочивание окна выполняется достаточно просто, поскольку использует уже знакомый синтаксис оператора `ORDER BY`. Так, в примере выше определяется окно с именем `salary_desc`, содержимое которого состоит из всех записей результирующего набора, расположенных в порядке убывания значения поля `salary`:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 5  | Sundar Pichai   | Sales       | 11000  |
| 1  | Sergey Brin     | Engineering | 10000  |
| 2  | John Doerr      | Sales       | 10000  |
| 10 | Alice Johnson   | Engineering | 10000  |
| 6  | Marissa Mayer   | Marketing   | 9000   |
| 9  | Sheryl Sandberg | Marketing   | 9000   |
| 4  | Eric Schmidt    | Marketing   | 8000   |
| 7  | Susan Wojcicki  | Engineering | 8000   |
| 3  | Larry Page      | Engineering | 7000   |
| 8  | John Smith      | Engineering | 7000   |
+----+-----------------+-------------+--------+
```

Функция `ROW_NUMBER()`, применяемая к окну `salary_desc`, для каждой рассматриваемой извлекающим запросом записи определяет ее порядковый номер в рамках окна и возвращает полученный результат, который затем указывается в поле `row_num`. Например, если извлекающий запрос рассматривает пятую запись таблицы `Employees` (`id = 5`), то для такой записи вызов функции `ROW_NUMBER()` по отношению к окну `salary_desc` вернет значение `1`, поскольку в окне `salary_desc` эта запись располагается на первом месте.

Оператор `ORDER BY` в спецификации окна определяет порядок записей лишь внутри окна. Порядок в результате запроса может совпадать с порядком, определенным в спецификации окна, однако полагаться на это не нужно.

Рассмотрим еще один элемент спецификации окна — секционирование. Оно используется для разбиения окна на секции по определенному полю (или нескольким полям). Две записи окна попадают в одну секцию, если их значения по выбранному полю (или нескольким полям) совпадают. Важность секционирования заключается в том, что если окно разбито на секции, то применяемая к этому окну функция будет работать не со всем его содержимым, а лишь с определенной секцией.

В качестве примера использования секционирования напишем запрос, который извлекает полные имена и названия отделов всех сотрудников, а также дополнительно пронумеровывает их в рамках своего отдела.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, department,
       ROW_NUMBER() OVER part_by_department AS row_num
FROM Employees
WINDOW part_by_department AS (PARTITION BY department);
```

является:

```
+-----------------+-------------+---------+
| full_name       | department  | row_num |
+-----------------+-------------+---------+
| Sergey Brin     | Engineering | 1       |
| Larry Page      | Engineering | 2       |
| Susan Wojcicki  | Engineering | 3       |
| John Smith      | Engineering | 4       |
| Alice Johnson   | Engineering | 5       |
| Eric Schmidt    | Marketing   | 1       |
| Marissa Mayer   | Marketing   | 2       |
| Sheryl Sandberg | Marketing   | 3       |
| John Doerr      | Sales       | 1       |
| Sundar Pichai   | Sales       | 2       |
+-----------------+-------------+---------+
```

Как видно, секционирование выполняется с помощью оператора `PARTITION BY`, после которого перечисляются все поля, по которым должно быть произведено разбиение на секции. Здесь содержимое окна `part_by_department` разбивается на секции по одному полю `department`:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 1  | Sergey Brin     | Engineering | 10000  | ┐
| 3  | Larry Page      | Engineering | 7000   | │
| 7  | Susan Wojcicki  | Engineering | 8000   | │
| 8  | John Smith      | Engineering | 7000   | │
| 10 | Alice Johnson   | Engineering | 10000  | ┘
| 4  | Eric Schmidt    | Marketing   | 8000   | ┐
| 6  | Marissa Mayer   | Marketing   | 9000   | │
| 9  | Sheryl Sandberg | Marketing   | 9000   | ┘
| 2  | John Doerr      | Sales       | 10000  | ┐
| 5  | Sundar Pichai   | Sales       | 11000  | ┘
+----+-----------------+-------------+--------+
```

Функция `ROW_NUMBER()`, применяемая к окну `part_by_department`, для каждой рассматриваемой извлекающим запросом записи определяет ее порядковый номер в рамках определенной секции окна и возвращает полученный результат, который затем указывается в поле `row_num`. Выбор секции зависит от того, какое значение рассматриваемая запись содержит в поле, которое было использовано при секционировании. В нашем случае это поле `department`.

Например, если извлекаемый запрос рассматривает шестую запись таблицы `Employees` (`id = 6`), то для такой записи вызов функции `ROW_NUMBER()` по отношению к окну `part_by_department` вернет значение `2`, поскольку в соответствующей секции окна `part_by_department` эта запись располагается на втором месте.

Формально окно всегда считается разбитым на секции, просто если секционирование не выполняется явно, то секцией является все окно целиком.

Определяемое окно можно секционировать и упорядочивать одновременно, однако в данном случае оператор `ORDER BY` будет определять порядок следования записей в рамках секции, а не всего окна. В качестве такого примера напишем запрос, который извлекает полные имена и названия отделов всех сотрудников, а также дополнительно пронумеровывает их в рамках отдела в порядке уменьшения зарплаты.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, department, salary,
       ROW_NUMBER() OVER salary_desc_part_by_department AS row_num
FROM Employees
WINDOW salary_desc_part_by_department AS (PARTITION BY department ORDER BY salary DESC);
```

является:

```
+-----------------+-------------+--------+---------+
| full_name       | department  | salary | row_num |
+-----------------+-------------+--------+---------+
| Sergey Brin     | Engineering | 10000  | 1       |
| Alice Johnson   | Engineering | 10000  | 2       |
| Susan Wojcicki  | Engineering | 8000   | 3       |
| Larry Page      | Engineering | 7000   | 4       |
| John Smith      | Engineering | 7000   | 5       |
| Marissa Mayer   | Marketing   | 9000   | 1       |
| Sheryl Sandberg | Marketing   | 9000   | 2       |
| Eric Schmidt    | Marketing   | 8000   | 3       |
| Sundar Pichai   | Sales       | 11000  | 1       |
| John Doerr      | Sales       | 10000  | 2       |
+-----------------+-------------+--------+---------+
```

Если определение окна включает как секционирование, так и упорядочивание, то оператор `PARTITION BY` должен располагаться до оператора `ORDER BY`.

<hr>

[Содержание](#содержание)

## Примечания 1

**Примечание 1.** Определить окно можно без использования оператора `WINDOW`. Для этого достаточно предоставить спецификацию окна, заключенную в круглые скобки, сразу после ключевого слова `OVER`.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, salary,
       ROW_NUMBER() OVER (ORDER BY salary DESC) AS row_num
FROM Employees;
```

является:

```
+-----------------+--------+---------+
| full_name       | salary | row_num |
+-----------------+--------+---------+
| Sundar Pichai   | 11000  | 1       |
| Sergey Brin     | 10000  | 2       |
| John Doerr      | 10000  | 3       |
| Alice Johnson   | 10000  | 4       |
| Marissa Mayer   | 9000   | 5       |
| Sheryl Sandberg | 9000   | 6       |
| Eric Schmidt    | 8000   | 7       |
| Susan Wojcicki  | 8000   | 8       |
| Larry Page      | 7000   | 9       |
| John Smith      | 7000   | 10      |
+-----------------+--------+---------+
```

**Примечание 2.** Как было упомянуто ранее, сортировка записей внутри окна не влияет на их расположение в результирующем наборе. Поэтому при необходимости гарантировать некий порядок записей в результате запроса, его необходимо определить явно в рамках самого запроса.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, salary,
       ROW_NUMBER() OVER salary_desc AS row_num 
FROM Employees
WINDOW salary_desc AS (ORDER BY salary DESC)       -- определяем порядок записей в окне
ORDER BY salary, row_num DESC;                     -- определяем порядок записей в результате запроса
```

является:

```
+-----------------+--------+---------+
| full_name       | salary | row_num |
+-----------------+--------+---------+
| John Smith      | 7000   | 10      |
| Larry Page      | 7000   | 9       |
| Susan Wojcicki  | 8000   | 8       |
| Eric Schmidt    | 8000   | 7       |
| Sheryl Sandberg | 9000   | 6       |
| Marissa Mayer   | 9000   | 5       |
| Alice Johnson   | 10000  | 4       |
| John Doerr      | 10000  | 3       |
| Sergey Brin     | 10000  | 2       |
| Sundar Pichai   | 11000  | 1       |
+-----------------+--------+---------+
```

**Примечание 3.** Разбиение окна на секции с помощью оператора `PARTITION BY` выполняется без учета регистра. Например, если условное поле `field`, по которому происходит секционирование, содержит строковые значения `Value` и `value`, то записи с такими значениями попадут в одну секцию. Стоит заметить, что группировка с помощью оператора `GROUP BY` также является регистронезависимой.

**Примечание 4.** Всегда необходимо помнить, в какой именно момент происходит определение окна:
+ после выполнения операций соединения (`JOIN`),
+ извлечения (`FROM`),
+ фильтрации (`WHERE`),
+ группировки (`GROUP BY`) и
+ фильтрации групп (`HAVING`).

Результатом приведенного ниже запроса:

```sql
SELECT salary,
       ROW_NUMBER() OVER () AS row_num             -- используемое окно определяется после выполнения группировки
FROM Employees
GROUP BY salary;
```

является:

```
+--------+---------+
| salary | row_num |
+--------+---------+
| 10000  | 1       |
| 7000   | 2       |
| 8000   | 3       |
| 11000  | 4       |
| 9000   | 5       |
+--------+---------+
```

**Примечание 5.** С помощью оператора `WINDOW` можно определить как одно окно, так и несколько. Во втором случае достаточно перечислить определения всех окон через запятую.

Например, в рамках приведенного ниже запроса:

```sql
SELECT full_name, salary
FROM Employees
WHERE department = 'Engineering'
WINDOW salary_asc AS (ORDER BY salary),
       salary_desc AS (ORDER BY salary DESC)
```

определяется окно с именем `salary_asc`, содержимое которого имеет следующий вид:

```
+----+----------------+-------------+--------+
| id | full_name      | department  | salary |
+----+----------------+-------------+--------+
| 3  | Larry Page     | Engineering | 7000   |
| 8  | John Smith     | Engineering | 7000   |
| 7  | Susan Wojcicki | Engineering | 8000   |
| 1  | Sergey Brin    | Engineering | 10000  |
| 10 | Alice Johnson  | Engineering | 10000  |
+----+----------------+-------------+--------+
```

а также окно с именем `salary_desc`, содержимое которого имеет следующий вид:

```
+----+----------------+-------------+--------+
| id | full_name      | department  | salary |
+----+----------------+-------------+--------+
| 1  | Sergey Brin    | Engineering | 10000  |
| 10 | Alice Johnson  | Engineering | 10000  |
| 7  | Susan Wojcicki | Engineering | 8000   |
| 3  | Larry Page     | Engineering | 7000   |
| 8  | John Smith     | Engineering | 7000   |
+----+----------------+-------------+--------+
```

<hr>

[Содержание](#содержание)

# 11.2 Ранжирующие функции. Часть 2

Урок посвящен ранжирующим оконным функциям.

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем `Employees`, которая содержит информацию о сотрудниках некоторой компании:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 1  | Sergey Brin     | Engineering | 10000  |
| 2  | John Doerr      | Sales       | 10000  |
| 3  | Larry Page      | Engineering | 7000   |
| 4  | Eric Schmidt    | Marketing   | 8000   |
| 5  | Sundar Pichai   | Sales       | 11000  |
| 6  | Marissa Mayer   | Marketing   | 9000   |
| 7  | Susan Wojcicki  | Engineering | 8000   |
| 8  | John Smith      | Engineering | 7000   |
| 9  | Sheryl Sandberg | Marketing   | 9000   |
| 10 | Alice Johnson   | Engineering | 10000  |
+----+-----------------+-------------+--------+
```

Первое поле этой таблицы содержит идентификатор сотрудника, второе — полное имя (имя и фамилия), третье — название отдела, в котором работает сотрудник, четвертое — зарплату в неизвестной валюте.

Скрипт для создания таблицы `Employees`

```sql
DROP TABLE IF EXISTS Employees;
CREATE TABLE Employees (
    id INT PRIMARY KEY,
    full_name VARCHAR(255),
    department VARCHAR(50),
    salary INT
);

INSERT INTO Employees (id, full_name, department, salary)
VALUES (1, 'Sergey Brin', 'Engineering', 10000),
       (2, 'John Doerr', 'Sales', 10000),
       (3, 'Larry Page', 'Engineering', 7000),
       (4, 'Eric Schmidt', 'Marketing', 8000),
       (5, 'Sundar Pichai', 'Sales', 11000),
       (6, 'Marissa Mayer', 'Marketing', 9000),
       (7, 'Susan Wojcicki', 'Engineering', 8000),
       (8, 'John Smith', 'Engineering', 7000),
       (9, 'Sheryl Sandberg', 'Marketing', 9000),
       (10, 'Alice Johnson', 'Engineering', 10000);
```

<hr>

[Содержание](#содержание)

## Функции `DENSE_RANK()` и `RANK()`

Функция `DENSE_RANK()` вычисляет ранг записи в рамках указанного окна. Функция требует, чтобы окно, к которому она применяется, было упорядочено, поскольку значение поля (или нескольких полей), по которому было выполнено упорядочивание, будет использоваться для вычисления ранга записи.

Непосредственно вычисление ранга выполняется следующим образом: функция `DENSE_RANK()` присваивает первой записи окна ранг, равный 1, и увеличивает его каждый раз, когда очередная запись в поле (или полях) упорядочивания содержит значение, отличное от значения предыдущей записи в том же поле.

В качестве примера использования функции `DENSE_RANK()` напишем запрос, который составляет рейтинг сотрудников на основе их зарплаты, располагая сотрудников с равными зарплатами на равных позициях в рейтинге.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, salary,
       DENSE_RANK() OVER (ORDER BY salary DESC) AS place
FROM Employees;
```

является:

```
+-----------------+--------+-------+
| full_name       | salary | place |
+-----------------+--------+-------+
| Sundar Pichai   | 11000  | 1     |
| Sergey Brin     | 10000  | 2     |
| John Doerr      | 10000  | 2     |
| Alice Johnson   | 10000  | 2     |
| Marissa Mayer   | 9000   | 3     |
| Sheryl Sandberg | 9000   | 3     |
| Eric Schmidt    | 8000   | 4     |
| Susan Wojcicki  | 8000   | 4     |
| Larry Page      | 7000   | 5     |
| John Smith      | 7000   | 5     |
+-----------------+--------+-------+
```

Здесь функция `DENSE_RANK()` выполняет ранжирование на основе поля `salary`: если значение записи в этом поле изменяется, то ранг увеличивается, в противном случае ранг сохраняет текущее значение.

Аналогичный рейтинг можно составить не среди всех сотрудников, а лишь в рамках определенного отдела. Для этого достаточно разбить используемое окно на соответствующие секции.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, department, salary,
       DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS place
FROM Employees;
```

является:

```
+-----------------+-------------+--------+-------+
| full_name       | department  | salary | place |
+-----------------+-------------+--------+-------+
| Sergey Brin     | Engineering | 10000  | 1     |
| Alice Johnson   | Engineering | 10000  | 1     |
| Susan Wojcicki  | Engineering | 8000   | 2     |
| Larry Page      | Engineering | 7000   | 3     |
| John Smith      | Engineering | 7000   | 3     |
| Marissa Mayer   | Marketing   | 9000   | 1     |
| Sheryl Sandberg | Marketing   | 9000   | 1     |
| Eric Schmidt    | Marketing   | 8000   | 2     |
| Sundar Pichai   | Sales       | 11000  | 1     |
| John Doerr      | Sales       | 10000  | 2     |
+-----------------+-------------+--------+-------+
```

Поведение функции `RANK()` похоже на поведение функции `DENSE_RANK()`, поэтому разницу между ними проще всего показать на сравнительном примере.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, salary,
       DENSE_RANK() OVER salary_desc AS row_dense_rank,
       RANK() OVER salary_desc AS row_rank
FROM Employees
WINDOW salary_desc AS (ORDER BY salary DESC);
```

является:

```
+-----------------+--------+----------------+----------+
| full_name       | salary | row_dense_rank | row_rank |
+-----------------+--------+----------------+----------+
| Sundar Pichai   | 11000  | 1              | 1        |
| Sergey Brin     | 10000  | 2              | 2        |
| John Doerr      | 10000  | 2              | 2        |
| Alice Johnson   | 10000  | 2              | 2        |
| Marissa Mayer   | 9000   | 3              | 5        |
| Sheryl Sandberg | 9000   | 3              | 5        |
| Eric Schmidt    | 8000   | 4              | 7        |
| Susan Wojcicki  | 8000   | 4              | 7        |
| Larry Page      | 7000   | 5              | 9        |
| John Smith      | 7000   | 5              | 9        |
+-----------------+--------+----------------+----------+
```

Здесь функции DENSE_RANK() и RANK() применяются к одному и тому же окну `salary_desc`. Видно, что функция `DENSE_RANK()` выполняет ранжирование без пропусков, в то время как функция `RANK()` при повторении рангов следующий ранг отбрасывает.

<hr>

[Содержание](#содержание)

## Функция `NTILE()`

Функция `NTILE()` используется для разбиения окна на заданное количество групп. Она принимает в качестве аргумента целое число `k`, разбивает окно на `k` групп и определяет номер группы, к которой относится запись.

В качестве примера использования функции `NTILE()` напишем запрос, который распределяет всех сотрудников по пяти группам, образуя пары из первого и второго сотрудника, третьего и четвертого, и так далее.

Результатом приведенного ниже запроса:

```sql
SELECT id, full_name,
       NTILE(5) OVER (ORDER BY id) AS group_number
FROM Employees;
```

является:

```
+----+-----------------+--------------+
| id | full_name       | group_number |
+----+-----------------+--------------+
| 1  | Sergey Brin     | 1            |
| 2  | John Doerr      | 1            |
| 3  | Larry Page      | 2            |
| 4  | Eric Schmidt    | 2            |
| 5  | Sundar Pichai   | 3            |
| 6  | Marissa Mayer   | 3            |
| 7  | Susan Wojcicki  | 4            |
| 8  | John Smith      | 4            |
| 9  | Sheryl Sandberg | 5            |
| 10 | Alice Johnson   | 5            |
+----+-----------------+--------------+
```

Функция `NTILE()` всегда пытается разбить окно на группы равного размера, однако если окно из `n` записей делится на `k` групп, причем окно невозможно поделить на равные группы (`n` не делится на `k` нацело), то первые `n % k` (остаток от деления `n` на `k`) групп будут содержать ровно на `1` запись больше, чем остальные группы.

Например, если окно из `10` записей делится на `3` группы, то первая группа будет содержать `4` записи, а две остальные — по `3`.

Результатом приведенного ниже запроса:

```sql
SELECT id, full_name,
       NTILE(3) OVER (ORDER BY id) AS group_number
FROM Employees;
```

является:

```
+----+-----------------+--------------+
| id | full_name       | group_number |
+----+-----------------+--------------+
| 1  | Sergey Brin     | 1            |
| 2  | John Doerr      | 1            |
| 3  | Larry Page      | 1            |
| 4  | Eric Schmidt    | 1            |
| 5  | Sundar Pichai   | 2            |
| 6  | Marissa Mayer   | 2            |
| 7  | Susan Wojcicki  | 2            |
| 8  | John Smith      | 3            |
| 9  | Sheryl Sandberg | 3            |
| 10 | Alice Johnson   | 3            |
+----+-----------------+--------------+
```

<hr>

[Содержание](#содержание)

## Примечания 2

**Примечание 1.** Ранжирующие функции практически всегда используются только с упорядоченными окнами. Более того, в некоторых СУБД ни одну из ранжирующих функций нельзя применить к окну, если оно не упорядочено.

**Примечание 2.** Оконные функции допустимо использовать для сортировки в блоке оператора `ORDER BY`.

Результатом приведенного ниже запроса:

```sql
SELECT id, full_name, salary
FROM Employees
ORDER BY NTILE(5) OVER (ORDER BY id), salary;
```

является:

```
+----+-----------------+--------+
| id | full_name       | salary |
+----+-----------------+--------+
| 1  | Sergey Brin     | 10000  |
| 2  | John Doerr      | 10000  |
| 3  | Larry Page      | 7000   |
| 4  | Eric Schmidt    | 8000   |
| 6  | Marissa Mayer   | 9000   |
| 5  | Sundar Pichai   | 11000  |
| 8  | John Smith      | 7000   |
| 7  | Susan Wojcicki  | 8000   |
| 9  | Sheryl Sandberg | 9000   |
| 10 | Alice Johnson   | 10000  |
+----+-----------------+--------+
```

Так, запрос выше располагает сотрудников парами (первый-второй, третий-четвертый, и так далее), при этом в рамках пары ставя первым того сотрудника, чья зарплата меньше.

**Примечание 3.** Оконные функции применимы только в блоках операторов `SELECT` и `ORDER BY`. Причина этого ограничения состоит в том, чтобы избежать двусмысленности при работе с почти окончательным набором данных в качестве источника для произведения оконных вычислений. Если бы оконные функции могли появляться в более ранних блоках (`WHERE`, `GROUP BY`), то их входные окна могли бы отличаться от итоговых, что привело бы к большим затруднениям при получении правильных результатов.

<hr>

[Содержание](#содержание)

# 11.3 Агрегатные функции

Урок посвящен агрегатным оконным функциям.

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем Employees, которая содержит информацию о сотрудниках некоторой компании:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 1  | Sergey Brin     | Engineering | 10000  |
| 2  | John Doerr      | Sales       | 10000  |
| 3  | Larry Page      | Engineering | NULL   |
| 4  | Eric Schmidt    | Marketing   | 8000   |
| 5  | Sundar Pichai   | Sales       | 11000  |
| 6  | Marissa Mayer   | Marketing   | 9000   |
| 7  | Susan Wojcicki  | Engineering | 8000   |
| 8  | John Smith      | Engineering | 7000   |
| 9  | Sheryl Sandberg | Marketing   | NULL   |
| 10 | Alice Johnson   | Engineering | 10000  |
+----+-----------------+-------------+--------+
```

Первое поле этой таблицы содержит идентификатор сотрудника, второе — полное имя (имя и фамилия), третье — название отдела, в котором работает сотрудник, четвертое — зарплату в неизвестной валюте.

Скрипт для создания таблицы `Employees`

```sql
DROP TABLE IF EXISTS Employees;
CREATE TABLE Employees (
    id INT PRIMARY KEY,
    full_name VARCHAR(255),
    department VARCHAR(50),
    salary INT
);

INSERT INTO Employees (id, full_name, department, salary)
VALUES (1, 'Sergey Brin', 'Engineering', 10000),
       (2, 'John Doerr', 'Sales', 10000),
       (3, 'Larry Page', 'Engineering', NULL),
       (4, 'Eric Schmidt', 'Marketing', 8000),
       (5, 'Sundar Pichai', 'Sales', 11000),
       (6, 'Marissa Mayer', 'Marketing', 9000),
       (7, 'Susan Wojcicki', 'Engineering', 8000),
       (8, 'John Smith', 'Engineering', 7000),
       (9, 'Sheryl Sandberg', 'Marketing', NULL),
       (10, 'Alice Johnson', 'Engineering', 10000);
```

<hr>

[Содержание](#содержание)

## Агрегатные функции

Агрегатные оконные функции представляют собой те же самые агрегатные функции группировки, но применяемые не к группам, а к окнам. Использование агрегатных функций в контексте окон выгодно тем, что позволяет выполнять агрегатные вычисления на основе набора записей и при этом не терять какую-либо информацию о каждой записи из набора.

<hr>

[Содержание](#содержание)

## Функции `AVG()` и `SUM()`

Функция `AVG()` вычисляет среднее арифметическое числовых значений, хранящихся в определенном поле окна. В качестве примера ее использования напишем запрос, который зарплате каждого сотрудника ставит в соответствие среднюю зарплату среди всех сотрудников.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, salary,
       AVG(salary) OVER () AS avg_salary
FROM Employees;
```

является:

```
+-----------------+--------+------------+
| full_name       | salary | avg_salary |
+-----------------+--------+------------+
| Sergey Brin     | 10000  | 9125.0000  |
| John Doerr      | 10000  | 9125.0000  |
| Larry Page      | NULL   | 9125.0000  |
| Eric Schmidt    | 8000   | 9125.0000  |
| Sundar Pichai   | 11000  | 9125.0000  |
| Marissa Mayer   | 9000   | 9125.0000  |
| Susan Wojcicki  | 8000   | 9125.0000  |
| John Smith      | 7000   | 9125.0000  |
| Sheryl Sandberg | NULL   | 9125.0000  |
| Alice Johnson   | 10000  | 9125.0000  |
+-----------------+--------+------------+
```

В данном примере поле `salary` содержит зарплату сотрудника, а поле `avg_salary` — среднюю зарплату среди всех сотрудников. Используя данные значения, мы можем определить, насколько зарплата каждого сотрудника отличается от средней.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, salary,
       AVG(salary) OVER () AS avg_salary,
       ABS(salary - AVG(salary) OVER ()) AS salary_difference
FROM Employees;
```

является:

```
+-----------------+--------+------------+-------------------+
| full_name       | salary | avg_salary | salary_difference |
+-----------------+--------+------------+-------------------+
| Sergey Brin     | 10000  | 9125.0000  | 875.0000          |
| John Doerr      | 10000  | 9125.0000  | 875.0000          |
| Larry Page      | NULL   | 9125.0000  | NULL              |
| Eric Schmidt    | 8000   | 9125.0000  | 1125.0000         |
| Sundar Pichai   | 11000  | 9125.0000  | 1875.0000         |
| Marissa Mayer   | 9000   | 9125.0000  | 125.0000          |
| Susan Wojcicki  | 8000   | 9125.0000  | 1125.0000         |
| John Smith      | 7000   | 9125.0000  | 2125.0000         |
| Sheryl Sandberg | NULL   | 9125.0000  | NULL              |
| Alice Johnson   | 10000  | 9125.0000  | 875.0000          |
+-----------------+--------+------------+-------------------+
```

Используя разбиение окна на секции, можно определить среднюю зарплату лишь в рамках определенного отдела.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, department, salary,
       AVG(salary) OVER (PARTITION BY department) AS department_avg_salary
FROM Employees;
```

является:

```
+-----------------+-------------+--------+-----------------------+
| full_name       | department  | salary | department_avg_salary |
+-----------------+-------------+--------+-----------------------+
| Sergey Brin     | Engineering | 10000  | 8750.0000             |
| Larry Page      | Engineering | NULL   | 8750.0000             |
| Susan Wojcicki  | Engineering | 8000   | 8750.0000             |
| John Smith      | Engineering | 7000   | 8750.0000             |
| Alice Johnson   | Engineering | 10000  | 8750.0000             |
| Eric Schmidt    | Marketing   | 8000   | 8500.0000             |
| Marissa Mayer   | Marketing   | 9000   | 8500.0000             |
| Sheryl Sandberg | Marketing   | NULL   | 8500.0000             |
| John Doerr      | Sales       | 10000  | 10500.0000            |
| Sundar Pichai   | Sales       | 11000  | 10500.0000            |
+-----------------+-------------+--------+-----------------------+
```

При использовании агрегатных оконных функций порядок записей в окне не имеет значения.

Функция `SUM()` вычисляет сумму числовых значений, хранящихся в определенном поле окна. С помощью данной функции мы можем зарплате каждого сотрудника поставить в соответствие суммарную зарплату среди всех сотрудников, а также суммарную зарплату среди сотрудников его отдела.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, department, salary,
       SUM(salary) OVER () AS sum_salary,
       SUM(salary) OVER (PARTITION BY department) AS department_sum_salary
FROM Employees;
```

является:

```
+-----------------+-------------+--------+------------+-----------------------+
| full_name       | department  | salary | sum_salary | department_sum_salary |
+-----------------+-------------+--------+------------+-----------------------+
| Sergey Brin     | Engineering | 10000  | 73000      | 35000                 |
| Larry Page      | Engineering | NULL   | 73000      | 35000                 |
| Susan Wojcicki  | Engineering | 8000   | 73000      | 35000                 |
| John Smith      | Engineering | 7000   | 73000      | 35000                 |
| Alice Johnson   | Engineering | 10000  | 73000      | 35000                 |
| Eric Schmidt    | Marketing   | 8000   | 73000      | 17000                 |
| Marissa Mayer   | Marketing   | 9000   | 73000      | 17000                 |
| Sheryl Sandberg | Marketing   | NULL   | 73000      | 17000                 |
| John Doerr      | Sales       | 10000  | 73000      | 21000                 |
| Sundar Pichai   | Sales       | 11000  | 73000      | 21000                 |
+-----------------+-------------+--------+------------+-----------------------+
```

Запрос выше в поле `salary` указывает зарплату сотрудника, в поле `sum_salary` — суммарную зарплату среди всех сотрудников, в поле `department_sum_salary` — суммарную зарплату в рамках того отдела, в котором работает сотрудник.

Функции `AVG()` и `SUM()` игнорируют значения `NULL` при вычислении среднего арифметического и суммы соответственно.

<hr>

[Содержание](#содержание)

## Функция `COUNT()`

Функция `COUNT()`, используемая для подсчета записей или непустых значений в поле, в контексте окон ведет себя ровно так же:
+ если ее аргументом является звездочка (`*`), функция вычисляет количество записей в окне,
+ если название поля — количество непустых значений в этом поле окна.

В качестве примера использования функции `COUNT()` напишем запрос, который для каждого сотрудника указывает количество людей, работающих в его отделе.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, department,
       COUNT(*) OVER (PARTITION BY department) AS employess_in_department
FROM Employees;
```

является:

```
+-----------------+-------------+-------------------------+
| full_name       | department  | employess_in_department |
+-----------------+-------------+-------------------------+
| Sergey Brin     | Engineering | 5                       |
| Larry Page      | Engineering | 5                       |
| Susan Wojcicki  | Engineering | 5                       |
| John Smith      | Engineering | 5                       |
| Alice Johnson   | Engineering | 5                       |
| Eric Schmidt    | Marketing   | 3                       |
| Marissa Mayer   | Marketing   | 3                       |
| Sheryl Sandberg | Marketing   | 3                       |
| John Doerr      | Sales       | 2                       |
| Sundar Pichai   | Sales       | 2                       |
+-----------------+-------------+-------------------------+
```

Также с помощью функции `COUNT()` мы можем определить не только количество сотрудников, работающих в отделе, но и количество тех, чья зарплата известна. Для этого в качестве аргумента функции необходимо указать название соответствующего поля.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, department,
       COUNT(salary) OVER (PARTITION BY department) AS employess_in_department_with_salary
FROM Employees;
```

является:

```
+-----------------+-------------+-------------------------------------+
| full_name       | department  | employess_in_department_with_salary |
+-----------------+-------------+-------------------------------------+
| Sergey Brin     | Engineering | 4                                   |
| Larry Page      | Engineering | 4                                   |
| Susan Wojcicki  | Engineering | 4                                   |
| John Smith      | Engineering | 4                                   |
| Alice Johnson   | Engineering | 4                                   |
| Eric Schmidt    | Marketing   | 2                                   |
| Marissa Mayer   | Marketing   | 2                                   |
| Sheryl Sandberg | Marketing   | 2                                   |
| John Doerr      | Sales       | 2                                   |
| Sundar Pichai   | Sales       | 2                                   |
+-----------------+-------------+-------------------------------------+
```

<hr>

[Содержание](#содержание)

## Функции `MIN()` и `MAX()`
Функция `MIN()` вычисляет минимальное значение, хранящиеся в определенном поле окна, функция `MAX()` — максимальное. В качестве примера использования данных функций напишем запрос, который зарплате каждого сотрудника ставит в соответствие наименьшую и наибольшую зарплату среди сотрудников его отдела.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, department,
       MIN(salary) OVER (PARTITION BY department) AS department_min_salary,
       MAX(salary) OVER (PARTITION BY department) AS department_max_salary
FROM Employees;
```

является:

```
+-----------------+-------------+-----------------------+-----------------------+
| full_name       | department  | department_min_salary | department_max_salary |
+-----------------+-------------+-----------------------+-----------------------+
| Sergey Brin     | Engineering | 7000                  | 10000                 |
| Larry Page      | Engineering | 7000                  | 10000                 |
| Susan Wojcicki  | Engineering | 7000                  | 10000                 |
| John Smith      | Engineering | 7000                  | 10000                 |
| Alice Johnson   | Engineering | 7000                  | 10000                 |
| Eric Schmidt    | Marketing   | 8000                  | 9000                  |
| Marissa Mayer   | Marketing   | 8000                  | 9000                  |
| Sheryl Sandberg | Marketing   | 8000                  | 9000                  |
| John Doerr      | Sales       | 10000                 | 11000                 |
| Sundar Pichai   | Sales       | 10000                 | 11000                 |
+-----------------+-------------+-----------------------+-----------------------+
```

Функции `MIN()` и `MAX()` игнорируют значения `NULL` при вычислении минимального и максимального значений

<hr>

[Содержание](#содержание)

## Примечания

**Примечание 1.** Несмотря на то что функции `MIN()` и `MAX()` обычно применяются к полям, содержащим числовые значения или даты, они могут применяться и к строковым полям. При работе со строками функция `MIN()` считает минимальной ту строку, которая была бы первой, если бы эти строки были отсортированы в лексикографическом порядке. Функция `MAX()`, напротив, считает максимальной ту строку, которая была бы последней, если бы строки были отсортированы в лексикографическом порядке.

**Примечание 2.** Функции `AVG()` и `SUM()` возвращают значение `0.0`, если применяются к нечисловым полям.

Результатом приведенного ниже запроса:

```sql
SELECT full_name,
       AVG(full_name) OVER () AS avg_full_name,
       SUM(full_name) OVER () AS sum_full_name
FROM Employees;
```

является:

```
+-----------------+---------------+---------------+
| full_name       | avg_full_name | sum_full_name |
+-----------------+---------------+---------------+
| Sergey Brin     | 0.0           | 0.0           |
| John Doerr      | 0.0           | 0.0           |
| Larry Page      | 0.0           | 0.0           |
| Eric Schmidt    | 0.0           | 0.0           |
| Sundar Pichai   | 0.0           | 0.0           |
| Marissa Mayer   | 0.0           | 0.0           |
| Susan Wojcicki  | 0.0           | 0.0           |
| John Smith      | 0.0           | 0.0           |
| Sheryl Sandberg | 0.0           | 0.0           |
| Alice Johnson   | 0.0           | 0.0           |
+-----------------+---------------+---------------+
```

**Примечание 3.** Если все значения поля, переданного в качестве аргумента в агрегатную оконную функцию, имеют значение `NULL`, возвращаемым значением функции также будет значение `NULL`.

<hr>

[Содержание](#содержание)

# 11.4 Границы окон

Урок посвящен определению оконных границ и примерам их использования.

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем `Employees`, которая содержит информацию о сотрудниках некоторой компании:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 1  | Sergey Brin     | Engineering | 10000  |
| 2  | John Doerr      | Sales       | 10000  |
| 3  | Larry Page      | Engineering | 7000   |
| 4  | Eric Schmidt    | Marketing   | 8000   |
| 5  | Sundar Pichai   | Sales       | 11000  |
| 6  | Marissa Mayer   | Marketing   | 9000   |
| 7  | Susan Wojcicki  | Engineering | 8000   |
| 8  | John Smith      | Engineering | 7000   |
| 9  | Sheryl Sandberg | Marketing   | 9000   |
| 10 | Alice Johnson   | Engineering | 10000  |
+----+-----------------+-------------+--------+
```

Первое поле этой таблицы содержит идентификатор сотрудника, второе — полное имя (имя и фамилия), третье — название отдела, в котором работает сотрудник, четвертое — зарплату в неизвестной валюте.

Скрипт для создания таблицы `Employees`

```sql
DROP TABLE IF EXISTS Employees;
CREATE TABLE Employees
(
    id INT PRIMARY KEY,
    full_name VARCHAR(255),
    department VARCHAR(50),
    salary INT
);

INSERT INTO Employees (id, full_name, department, salary)
VALUES (1, 'Sergey Brin', 'Engineering', 10000),
       (2, 'John Doerr', 'Sales', 10000),
       (3, 'Larry Page', 'Engineering', 7000),
       (4, 'Eric Schmidt', 'Marketing', 8000),
       (5, 'Sundar Pichai', 'Sales', 11000),
       (6, 'Marissa Mayer', 'Marketing', 9000),
       (7, 'Susan Wojcicki', 'Engineering', 8000),
       (8, 'John Smith', 'Engineering', 7000),
       (9, 'Sheryl Sandberg', 'Marketing', 9000),
       (10, 'Alice Johnson', 'Engineering', 10000);
```

<hr>

[Содержание](#содержание)

## Определение границ окна

Ранее нами было упомянуто, что, помимо секционирования и упорядочивания, окно может обладать еще одной спецификацией — **определением границ**. С помощью данной спецификации можно детально обозначить, с какими именно записями окна должна взаимодействовать оконная функция.

Определение границ окна выполняется путем указания двух граничных точек: начальной и конечной. При указанных границах оконная функция будет работать только с теми записями окна (или секции окна, если было применено секционирование), которые заключены между граничными, включая сами границы.

Границы всегда определяются относительно той записи, с которой на данный момент взаимодействует оконная функция. Поэтому, например, начальной границей может являться предыдущая запись относительно текущей, а конечной — следующая. Таким образом, для каждой записи, с которой взаимодействует оконная функция, границы определяются индивидуально.

Предположим, мы работаем с окном (не разбитым на секции), которое имеет следующий вид:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 1  | Sergey Brin     | Engineering | 10000  |
| 2  | John Doerr      | Sales       | 10000  |
| 3  | Larry Page      | Engineering | 7000   |
| 4  | Eric Schmidt    | Marketing   | 8000   |
| 5  | Sundar Pichai   | Sales       | 11000  |
+----+-----------------+-------------+--------+
```

Также допустим, что у нашего окна определены границы, причем в качестве начальной граничной точки указана предыдущая запись, а в качестве конечной — следующая. Тогда применяемая к окну оконная функция во время работы, например, со второй записью (`id = 2`) будет выполнять вычисления лишь в рамках следующей части окна:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 1  | Sergey Brin     | Engineering | 10000  | ┐   <-- предыдущая запись
| 2  | John Doerr      | Sales       | 10000  | │   <-- текущая запись 
| 3  | Larry Page      | Engineering | 7000   | ┘   <-- следующая запись
| 4  | Eric Schmidt    | Marketing   | 8000   |
| 5  | Sundar Pichai   | Sales       | 11000  |
+----+-----------------+-------------+--------+
```

во время работы с третьей записью (`id = 3`) — в рамках следующей части окна:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 1  | Sergey Brin     | Engineering | 10000  |
| 2  | John Doerr      | Sales       | 10000  | ┐    <-- предыдущая запись
| 3  | Larry Page      | Engineering | 7000   | │    <-- текущая запись
| 4  | Eric Schmidt    | Marketing   | 8000   | ┘    <-- следующая запись
| 5  | Sundar Pichai   | Sales       | 11000  |
+----+-----------------+-------------+--------+
```

Часть окна, получаемая в результате применения установленных границ, никогда не выходит за пределы окна, а если сталкивается с ними, то обрезается. Поэтому если оконная функция, применяемая к окну выше, будет работать, например, с первой записью (`id = 1`), то все ее вычисления будут выполняться в рамках следующей части окна:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 1  | Sergey Brin     | Engineering | 10000  | ┐    <-- текущая запись
| 2  | John Doerr      | Sales       | 10000  | ┘    <-- следующая запись
| 3  | Larry Page      | Engineering | 7000   |
| 4  | Eric Schmidt    | Marketing   | 8000   |
| 5  | Sundar Pichai   | Sales       | 11000  |
+----+-----------------+-------------+--------+
```

если с пятой (`id = 5`) — в рамках следующей части окна:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 1  | Sergey Brin     | Engineering | 10000  |
| 2  | John Doerr      | Sales       | 10000  |
| 3  | Larry Page      | Engineering | 7000   |
| 4  | Eric Schmidt    | Marketing   | 8000   | ┐    <-- предыдущая запись
| 5  | Sundar Pichai   | Sales       | 11000  | ┘    <-- текущая запись
+----+-----------------+-------------+--------+
```

Часть окна, получаемая в результате применения установленных границ, называется **фреймом**.

<hr>

[Содержание](#содержание)

## Оператор `ROWS`

Определить границы окна можно с помощью оператора `ROWS`, синтаксис использования которого имеет следующий вид:

```sql
ROWS BETWEEN <начальная граничная точка> AND <конечная граничная точка>
```

Начальная граничная точка может быть представлена одним из следующих значений:
+ `CURRENT ROW` — текущая запись
+ `n PRECEDING` — n-ая запись перед текущей
+ `n FOLLOWING` — n-ая запись после текущей
+ `UNBOUNDED PRECEDING` — самая первая запись окна (или секции окна, если было применено секционирование)

Конечная граничная точка может быть представлена одним из следующих значений:
+ `CURRENT ROW` — текущая запись
+ `n PRECEDING` — n-ая запись перед текущей
+ `n FOLLOWING` — n-ая запись после текущей
+ `UNBOUNDED FOLLOWING` — самая последняя запись окна (или секции окна, если было применено секционирование)

Оператор `ROWS` в определении окна должен располагаться после операторов `PARTITION BY` и `ORDER BY`.

<hr>

[Содержание](#содержание)

### Примеры определения границ окна с помощью оператора `ROWS`

Для большего понимания рассмотрим несколько примеров определения оконных границ. Все границы будем определять относительно окна (не разбитого на секции), которое имеет следующий вид:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 1  | Sergey Brin     | Engineering | 10000  |
| 2  | John Doerr      | Sales       | 10000  |
| 3  | Larry Page      | Engineering | 7000   |
| 4  | Eric Schmidt    | Marketing   | 8000   |
| 5  | Sundar Pichai   | Sales       | 11000  |
+----+-----------------+-------------+--------+
```

**Пример 1.** Определим границы окна, взяв в качестве начальной граничной точки предыдущую запись, а в качестве конечной — следующую:

```sql
​ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
```

**Пример 2.** Определим границы окна, взяв в качестве начальной граничной точки самую первую запись окна, а в качестве конечной — текущую:

```sql
​ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
```

Тогда применяемая к окну оконная функция во время работы, например, с третьей записью (`id = 3`) будет выполнять вычисления лишь в рамках следующей части окна:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 1  | Sergey Brin     | Engineering | 10000  | ┐
| 2  | John Doerr      | Sales       | 10000  | │
| 3  | Larry Page      | Engineering | 7000   | ┘    <-- текущая запись
| 4  | Eric Schmidt    | Marketing   | 8000   |
| 5  | Sundar Pichai   | Sales       | 11000  |
+----+-----------------+-------------+--------+
```

если с четвертой (`id = 4`) — в рамках следующей части окна:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 1  | Sergey Brin     | Engineering | 10000  | ┐
| 2  | John Doerr      | Sales       | 10000  | │
| 3  | Larry Page      | Engineering | 7000   | │
| 4  | Eric Schmidt    | Marketing   | 8000   | ┘   <-- текущая запись
| 5  | Sundar Pichai   | Sales       | 11000  |
+----+-----------------+-------------+--------+
```

**Пример 3.** Определим границы окна, взяв в качестве начальной граничной точки следующую запись, а в качестве конечной — следующую за следующей:

```sql
​ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING
```

Тогда применяемая к окну оконная функция во время работы, например, со второй записью (`id = 2`) будет выполнять вычисления лишь в рамках следующей части окна:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 1  | Sergey Brin     | Engineering | 10000  |
| 2  | John Doerr      | Sales       | 10000  |      <-- текущая запись
| 3  | Larry Page      | Engineering | 7000   | ┐    <-- следующая запись
| 4  | Eric Schmidt    | Marketing   | 8000   | ┘    <-- запись, следующая за следующей
| 5  | Sundar Pichai   | Sales       | 11000  |
+----+-----------------+-------------+--------+
```

если с третьей (`id = 3`) — в рамках следующей части окна:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 1  | Sergey Brin     | Engineering | 10000  |
| 2  | John Doerr      | Sales       | 10000  |
| 3  | Larry Page      | Engineering | 7000   |      <-- текущая запись 
| 4  | Eric Schmidt    | Marketing   | 8000   | ┐    <-- следующая запись
| 5  | Sundar Pichai   | Sales       | 11000  | ┘    <-- запись, следующая за следующей
+----+-----------------+-------------+--------+
```

<hr>

[Содержание](#содержание)

### Примеры использования оператора `ROWS`

В качестве примера использования оконных границ, определенных с помощью оператора `ROWS`, напишем запрос, который вычисляет среднюю зарплату каждого сотрудника, учитывая только зарплату самого сотрудника, а также зарплаты сотрудников с меньшим идентификатором.

Результатом приведенного ниже запроса:

```sql
SELECT id, full_name, salary,
       AVG(salary) OVER (ORDER BY id ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS avg_salary
FROM Employees;
```

является:

```
+----+-----------------+--------+------------+
| id | full_name       | salary | avg_salary |
+----+-----------------+--------+------------+
| 1  | Sergey Brin     | 10000  | 10000.0000 |
| 2  | John Doerr      | 10000  | 10000.0000 |
| 3  | Larry Page      | 7000   | 9000.0000  |
| 4  | Eric Schmidt    | 8000   | 8750.0000  |
| 5  | Sundar Pichai   | 11000  | 9200.0000  |
| 6  | Marissa Mayer   | 9000   | 9166.6667  |
| 7  | Susan Wojcicki  | 8000   | 9000.0000  |
| 8  | John Smith      | 7000   | 8750.0000  |
| 9  | Sheryl Sandberg | 9000   | 8777.7778  |
| 10 | Alice Johnson   | 10000  | 8900.0000  |
+----+-----------------+--------+------------+
```

В примере выше определено окно, записи в котором расположены в порядке возрастания значения поля `id`. Более того, у окна указаны границы: начальной граничной точкой является самая первая запись окна, конечной — текущая.

Таким образом, применяемая к окну оконная функция `AVG()` при вычислении среднего значения поля `salary` для очередной записи использует значение текущей записи, а также всех предыдущих. Например, для второй записи среднее значение вычисляется как (10000 + 10000) / 2, для третьей — (10000 + 10000 + 7000) / 3, для четвертой — (10000 + 10000 + 7000 + 8000) / 4, и так далее.

Во время использования оконных границ важно, чтобы окно было упорядочено, поскольку для точного результата все предыдущие и следующие записи относительно текущей должны определяться однозначно.

В качестве дополнительного примера напишем запрос, который вычисляет среднюю зарплату каждого сотрудника, учитывая только зарплату самого сотрудника, а также зарплаты его коллег по отделу с меньшим идентификатором.

Результатом приведенного ниже запроса:

```sql
SELECT id, full_name, department, salary,
       AVG(salary) OVER (PARTITION BY department
                         ORDER BY id
                         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS avg_salary
FROM Employees;
```

является:

```
+----+-----------------+-------------+--------+------------+
| id | full_name       | department  | salary | avg_salary |
+----+-----------------+-------------+--------+------------+
| 1  | Sergey Brin     | Engineering | 10000  | 10000.0000 |
| 3  | Larry Page      | Engineering | 7000   | 8500.0000  |
| 7  | Susan Wojcicki  | Engineering | 8000   | 8333.3333  |
| 8  | John Smith      | Engineering | 7000   | 8000.0000  |
| 10 | Alice Johnson   | Engineering | 10000  | 8400.0000  |
| 4  | Eric Schmidt    | Marketing   | 8000   | 8000.0000  |
| 6  | Marissa Mayer   | Marketing   | 9000   | 8500.0000  |
| 9  | Sheryl Sandberg | Marketing   | 9000   | 8666.6667  |
| 2  | John Doerr      | Sales       | 10000  | 10000.0000 |
| 5  | Sundar Pichai   | Sales       | 11000  | 10500.0000 |
+----+-----------------+-------------+--------+------------+
```

<hr>

[Содержание](#содержание)

## Примечания 4

**Примечание 1.** Определенные в окне границы учитывают только агрегатные функции, а также некоторые функции смещения (будут рассмотрены позже). Все остальные функции установленные границы игнорируют и выполняют свои вычисления в рамках всего окна (или секции окна, если было применено секционирование).

Результатом приведенного ниже запроса:

```sql
SELECT id, full_name, salary,
       ROW_NUMBER() OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND CURRENT ROW) AS row_num
FROM Employees;
```

является:

```
+----+-----------------+--------+---------+
| id | full_name       | salary | row_num |
+----+-----------------+--------+---------+
| 1  | Sergey Brin     | 10000  | 1       |
| 2  | John Doerr      | 10000  | 2       |
| 3  | Larry Page      | 7000   | 3       |
| 4  | Eric Schmidt    | 8000   | 4       |
| 5  | Sundar Pichai   | 11000  | 5       |
| 6  | Marissa Mayer   | 9000   | 6       |
| 7  | Susan Wojcicki  | 8000   | 7       |
| 8  | John Smith      | 7000   | 8       |
| 9  | Sheryl Sandberg | 9000   | 9       |
| 10 | Alice Johnson   | 10000  | 10      |
+----+-----------------+--------+---------+
```

В примере выше границы окна определены как "от текущей записи до текущей записи", однако применяемая к окну функция `ROW_NUMBER()` данные ограничения игнорирует.

**Примечание 2.** Если часть окна, полученная в результате применения установленных границ, не содержит ни одной записи, то результатом вызова оконной функции относительно данной части окна будет значение `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, salary,
       AVG(salary) OVER (ROWS BETWEEN 100 FOLLOWING AND 200 FOLLOWING) AS avg_salary
FROM Employees;
```

является:

```
+-----------------+--------+------------+
| full_name       | salary | avg_salary |
+-----------------+--------+------------+
| Sergey Brin     | 10000  | NULL       |
| John Doerr      | 10000  | NULL       |
| Larry Page      | 7000   | NULL       |
| Eric Schmidt    | 8000   | NULL       |
| Sundar Pichai   | 11000  | NULL       |
| Marissa Mayer   | 9000   | NULL       |
| Susan Wojcicki  | 8000   | NULL       |
| John Smith      | 7000   | NULL       |
| Sheryl Sandberg | 9000   | NULL       |
| Alice Johnson   | 10000  | NULL       |
+-----------------+--------+------------+
```

<hr>

[Содержание](#содержание)

## Оператор `RANGE`

Определить границы окна также можно с помощью оператора `RANGE`, синтаксис использования которого имеет следующий вид:

```sql
RANGE BETWEEN <начальная граничная точка> AND <конечная граничная точка>
```

Как можно заметить, применяется оператор `RANGE` практически так же, как и оператор `ROWS`. Более того, для указания граничных точек используются те же ключевые слова `CURRENT ROW`, `PRECEDING` и `FOLLOWING`.

Несмотря на схожесть синтаксисов, принципы работы операторов `RANGE` и `ROWS` значительно отличаются. Оператор `RANGE`, в отличие от `ROWS`, ориентируется не на расположение записей (например, предыдущая или следующая), а на их значение в том поле, по которому было упорядочено окно.

Предположим, мы работаем с окном (не разбитым на секции), которое имеет следующий вид:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 3  | Larry Page      | Engineering | 7000   |
| 4  | Eric Schmidt    | Marketing   | 8000   |
| 1  | Sergey Brin     | Engineering | 10000  |
| 2  | John Doerr      | Sales       | 10000  |
| 5  | Sundar Pichai   | Sales       | 11000  |
+----+-----------------+-------------+--------+
```

Также допустим, что записи в данном окне упорядочены по полю `salary`, а границы определены с помощью оператора `RANGE` следующим образом:

```sql
RANGE BETWEEN 2000 PRECEDING AND 2000 FOLLOWING
```

Тогда применяемая к окну оконная функция во время работы, например, со второй записью (`id = 4`) будет выполнять вычисления лишь в рамках следующей части окна:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 3  | Larry Page      | Engineering | 7000   | ┐  <-- значение поля salary отличается от 8000 на 1000
| 4  | Eric Schmidt    | Marketing   | 8000   | │  <-- текущая запись
| 1  | Sergey Brin     | Engineering | 10000  | │  <-- значение поля salary отличается от 8000 на 2000
| 2  | John Doerr      | Sales       | 10000  | ┘  <-- значение поля salary отличается от 8000 на 2000
| 5  | Sundar Pichai   | Sales       | 11000  |    <-- значение поля salary отличается от 8000 на 3000
+----+-----------------+-------------+--------+
```

То есть часть `2000 PRECEDING` в данном контексте говорит о том, что в ограниченную часть окна должны попасть те записи, которые располагаются в окне до текущей записи и содержат в поле `salary` значение, отличающееся от `8000` (значение текущей записи в поле `salary`) не более чем на `2000`. Часть `2000 FOLLOWING`, в свою очередь, сообщает то, что в ограниченную часть окна должны попасть те записи, которые располагаются в окне после текущей записи и также содержат в поле `salary` значение, отличающееся от `8000` не более чем на `2000`.

Таким образом, оператор `RANGE` совместно с ключевыми словами `PRECEDING` и `FOLLOWING` позволяет определять не столько границы, сколько диапазоны. Если некоторое окно упорядочено по условному полю `field`, а текущая запись в поле `field` содержит значение `x`, тогда определение границ следующим образом:

```
RANGE BETWEEN a PRECEDING AND b FOLLOWING
```

будет говорить о том, что в ограниченную часть окна должны быть включены те записи, которые в поле `field` содержат значение, входящее в диапазон `[x - a; x + b]`.

<hr>

[Содержание](#содержание)

## Примечания 4.1

**Примечание 1.** При использовании оператора `RANGE` связка ключевых слов `CURRENT ROW` обозначает не текущую запись, а набор записей, которые в поле упорядочивания содержат то же значение, что и текущая запись. Другими словами, `CURRENT ROW` в контексте оператора `RANGE` можно трактовать как `0 PRECEDING` или `0 FOLLOWING`.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, salary,
       COUNT(*) OVER (ORDER BY salary RANGE BETWEEN CURRENT ROW AND CURRENT ROW) AS result
FROM Employees
```

является:

```
+-----------------+--------+--------+
| full_name       | salary | result |
+-----------------+--------+--------+
| Larry Page      | 7000   | 2      |
| John Smith      | 7000   | 2      |
| Eric Schmidt    | 8000   | 2      |
| Susan Wojcicki  | 8000   | 2      |
| Marissa Mayer   | 9000   | 2      |
| Sheryl Sandberg | 9000   | 2      |
| Sergey Brin     | 10000  | 3      |
| John Doerr      | 10000  | 3      |
| Alice Johnson   | 10000  | 3      |
| Sundar Pichai   | 11000  | 1      |
+-----------------+--------+--------+
```

**Примечание 2.** Окно, границы которого определяются с помощью оператора `RANGE`, должно быть упорядочено только по одному полю.

**Примечание 3.** Поле, которое используется оператором `RANGE` для определения границ, должно содержать только числа, даты, временные значения или значения даты и времени.

**Примечание 4.** Окно всегда имеет границы, определенные по умолчанию, которые зависят от того, упорядочено окно или нет. Если окно не упорядочено, границы определяются следующим образом:

```sql
RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
```

если упорядочено — следующим образом:

```sql
RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
```

Результатом приведенного ниже запроса:

```sql
SELECT id, full_name, salary,
       AVG(salary) OVER () AS not_sorted,
       AVG(salary) OVER (ORDER BY salary) AS sorted,
       AVG(salary) OVER (ORDER BY salary RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS sorted_and_limited
FROM Employees;
```

является:

```
+----+-----------------+--------+------------+-----------+--------------------+
| id | full_name       | salary | not_sorted | sorted    | sorted_and_limited |
+----+-----------------+--------+------------+-----------+--------------------+
| 3  | Larry Page      | 7000   | 8900.0000  | 7000.0000 | 7000.0000          |
| 8  | John Smith      | 7000   | 8900.0000  | 7000.0000 | 7000.0000          |
| 4  | Eric Schmidt    | 8000   | 8900.0000  | 7500.0000 | 7500.0000          |
| 7  | Susan Wojcicki  | 8000   | 8900.0000  | 7500.0000 | 7500.0000          |
| 6  | Marissa Mayer   | 9000   | 8900.0000  | 8000.0000 | 8000.0000          |
| 9  | Sheryl Sandberg | 9000   | 8900.0000  | 8000.0000 | 8000.0000          |
| 1  | Sergey Brin     | 10000  | 8900.0000  | 8666.6667 | 8666.6667          |
| 2  | John Doerr      | 10000  | 8900.0000  | 8666.6667 | 8666.6667          |
| 10 | Alice Johnson   | 10000  | 8900.0000  | 8666.6667 | 8666.6667          |
| 5  | Sundar Pichai   | 11000  | 8900.0000  | 8900.0000 | 8900.0000          |
+----+-----------------+--------+------------+-----------+--------------------+
```

<hr>

[Содержание](#содержание)

# 11.5 Функции смещения

Урок посвящен оконным функциям смещения.

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем `Employees`, которая содержит информацию о сотрудниках некоторой компании:

```
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 1  | Sergey Brin     | Engineering | 10000  |
| 2  | John Doerr      | Sales       | 10000  |
| 3  | Larry Page      | Engineering | 7000   |
| 4  | Eric Schmidt    | Marketing   | 8000   |
| 5  | Sundar Pichai   | Sales       | 11000  |
| 6  | Marissa Mayer   | Marketing   | 9000   |
| 7  | Susan Wojcicki  | Engineering | 8000   |
| 8  | John Smith      | Engineering | 7000   |
| 9  | Sheryl Sandberg | Marketing   | 9000   |
| 10 | Alice Johnson   | Engineering | 12000  |
+----+-----------------+-------------+--------+
```

Первое поле этой таблицы содержит идентификатор сотрудника, второе — полное имя (имя и фамилия), третье — название отдела, в котором работает сотрудник, четвертое — зарплату в неизвестной валюте.

Скрипт для создания таблицы `Employees`

```sql
DROP TABLE IF EXISTS Employees;
CREATE TABLE Employees
(
    id INT PRIMARY KEY,
    full_name VARCHAR(255),
    department VARCHAR(50),
    salary INT
);

INSERT INTO Employees (id, full_name, department, salary)
VALUES (1, 'Sergey Brin', 'Engineering', 10000),
       (2, 'John Doerr', 'Sales', 10000),
       (3, 'Larry Page', 'Engineering', 7000),
       (4, 'Eric Schmidt', 'Marketing', 8000),
       (5, 'Sundar Pichai', 'Sales', 11000),
       (6, 'Marissa Mayer', 'Marketing', 9000),
       (7, 'Susan Wojcicki', 'Engineering', 8000),
       (8, 'John Smith', 'Engineering', 7000),
       (9, 'Sheryl Sandberg', 'Marketing', 9000),
       (10, 'Alice Johnson', 'Engineering', 12000);
```

<hr>

[Содержание](#содержание)

## Функция `FIRST_VALUE()`

Функция `FIRST_VALUE()` используется для получения значения, которое содержится в определенном поле первой записи окна. В качестве примера ее использования напишем запрос, который зарплате каждого сотрудника ставит в соответствие зарплату самого первого сотрудника (сотрудника с наименьшим идентификатором).

Результатом приведенного ниже запроса:

```sql
SELECT id, full_name, salary,
       FIRST_VALUE(salary) OVER (ORDER BY id) AS first_employee_salary
FROM Employees;
```

является:

```
+----+-----------------+--------+-----------------------+
| id | full_name       | salary | first_employee_salary |
+----+-----------------+--------+-----------------------+
| 1  | Sergey Brin     | 10000  | 10000                 |
| 2  | John Doerr      | 10000  | 10000                 |
| 3  | Larry Page      | 7000   | 10000                 |
| 4  | Eric Schmidt    | 8000   | 10000                 |
| 5  | Sundar Pichai   | 11000  | 10000                 |
| 6  | Marissa Mayer   | 9000   | 10000                 |
| 7  | Susan Wojcicki  | 8000   | 10000                 |
| 8  | John Smith      | 7000   | 10000                 |
| 9  | Sheryl Sandberg | 9000   | 10000                 |
| 10 | Alice Johnson   | 12000  | 10000                 |
+----+-----------------+--------+-----------------------+
```

В примере выше функция `FIRST_VALUE()` применяется к окну, упорядоченному по полю `id`, и для каждой записи оконная функция возвращает значение, которое хранится в поле `salary` первой записи окна, — `10000`.

Дополнив запрос выше разбиением окна на секции, можно поставить в соответствие зарплату самого первого сотрудника не среди всех сотрудников, а лишь в рамках определенного отдела.

Результатом приведенного ниже запроса:

```sql
SELECT id, full_name, department, salary,
       FIRST_VALUE(salary) OVER (PARTITION BY department ORDER BY id) AS first_employee_salary_in_department
FROM Employees;
```

является:

```
+----+-----------------+-------------+--------+-------------------------------------+
| id | full_name       | department  | salary | first_employee_salary_in_department |
+----+-----------------+-------------+--------+-------------------------------------+
| 1  | Sergey Brin     | Engineering | 10000  | 10000                               |
| 3  | Larry Page      | Engineering | 7000   | 10000                               |
| 7  | Susan Wojcicki  | Engineering | 8000   | 10000                               |
| 8  | John Smith      | Engineering | 7000   | 10000                               |
| 10 | Alice Johnson   | Engineering | 12000  | 10000                               |
| 4  | Eric Schmidt    | Marketing   | 8000   | 8000                                |
| 6  | Marissa Mayer   | Marketing   | 9000   | 8000                                |
| 9  | Sheryl Sandberg | Marketing   | 9000   | 8000                                |
| 2  | John Doerr      | Sales       | 10000  | 10000                               |
| 5  | Sundar Pichai   | Sales       | 11000  | 10000                               |
+----+-----------------+-------------+--------+-------------------------------------+
```

<hr>

[Содержание](#содержание)

## Функция `LAST_VALUE()`

Функция `LAST_VALUE()` используется для получения значения, которое содержится в определенном поле последней записи окна. В качестве примера ее использования напишем запрос, который зарплате каждого сотрудника ставит в соответствие зарплату самого последнего сотрудника (сотрудника с наибольшим идентификатором).

Результатом приведенного ниже запроса:

```sql
SELECT id, full_name, salary,
       LAST_VALUE(salary) OVER (ORDER BY id
                                ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_employee_salary
FROM Employees;
```

является:

```
+----+-----------------+--------+----------------------+
| id | full_name       | salary | last_employee_salary |
+----+-----------------+--------+----------------------+
| 1  | Sergey Brin     | 10000  | 12000                |
| 2  | John Doerr      | 10000  | 12000                |
| 3  | Larry Page      | 7000   | 12000                |
| 4  | Eric Schmidt    | 8000   | 12000                |
| 5  | Sundar Pichai   | 11000  | 12000                |
| 6  | Marissa Mayer   | 9000   | 12000                |
| 7  | Susan Wojcicki  | 8000   | 12000                |
| 8  | John Smith      | 7000   | 12000                |
| 9  | Sheryl Sandberg | 9000   | 12000                |
| 10 | Alice Johnson   | 12000  | 12000                |
+----+-----------------+--------+----------------------+
```

Обратите внимание, что в данном примере дополнительно определяются границы окна: от самой первой записи до самой последней. Во время использования функции `LAST_VALUE()` этот шаг является очень важным, поскольку если границы будут определены по умолчанию, оконная функция может выполнять не то, что требуется.

Результатом приведенного ниже запроса:

```sql
SELECT id, full_name, salary,
       LAST_VALUE(salary) OVER (ORDER BY id) AS last_employee_salary
FROM Employees;
```

является:

```
+----+-----------------+--------+----------------------+
| id | full_name       | salary | last_employee_salary |
+----+-----------------+--------+----------------------+
| 1  | Sergey Brin     | 10000  | 10000                |
| 2  | John Doerr      | 10000  | 10000                |
| 3  | Larry Page      | 7000   | 7000                 |
| 4  | Eric Schmidt    | 8000   | 8000                 |
| 5  | Sundar Pichai   | 11000  | 11000                |
| 6  | Marissa Mayer   | 9000   | 9000                 |
| 7  | Susan Wojcicki  | 8000   | 8000                 |
| 8  | John Smith      | 7000   | 7000                 |
| 9  | Sheryl Sandberg | 9000   | 9000                 |
| 10 | Alice Johnson   | 12000  | 12000                |
+----+-----------------+--------+----------------------+
```

В данном случае функция `LAST_VALUE()` применяется к окну, упорядоченному по полю `id`, границы которого определены по умолчанию: от самой первой записи до текущей. Таким образом, для каждой записи оконная функция возвращает значение поля `salary` самой же записи, поскольку в тех рамках окна, в которых выполняется функция, текущая запись является последней.

<hr>

[Содержание](#содержание)

## Функция `NTH_VALUE()`

Функция `NTH_VALUE()` используется для получения значения, которое содержится в определенном поле n-ой записи окна (начиная с 1). В качестве примера ее использования напишем запрос, который зарплате каждого сотрудника ставит в соответствие зарплаты второго и третьего сотрудников.

Результатом приведенного ниже запроса:

```sql
SELECT id, full_name, salary,
       NTH_VALUE(salary, 2) OVER id_asc AS second_employee_salary,
       NTH_VALUE(salary, 3) OVER id_asc AS third_employee_salary
FROM Employees
WINDOW id_asc AS (ORDER BY id ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING);
```

является:

```
+----+-----------------+--------+------------------------+-----------------------+
| id | full_name       | salary | second_employee_salary | third_employee_salary |
+----+-----------------+--------+------------------------+-----------------------+
| 1  | Sergey Brin     | 10000  | 10000                  | 7000                  |
| 2  | John Doerr      | 10000  | 10000                  | 7000                  |
| 3  | Larry Page      | 7000   | 10000                  | 7000                  |
| 4  | Eric Schmidt    | 8000   | 10000                  | 7000                  |
| 5  | Sundar Pichai   | 11000  | 10000                  | 7000                  |
| 6  | Marissa Mayer   | 9000   | 10000                  | 7000                  |
| 7  | Susan Wojcicki  | 8000   | 10000                  | 7000                  |
| 8  | John Smith      | 7000   | 10000                  | 7000                  |
| 9  | Sheryl Sandberg | 9000   | 10000                  | 7000                  |
| 10 | Alice Johnson   | 10000  | 10000                  | 7000                  |
+----+-----------------+--------+------------------------+-----------------------+
```

Здесь оба вызова функции `NTH_VALUE()` выполняются относительно окна, упорядоченного по полю `id`, границы которого определены следующим образом: от самой первой записи до самой последней. Для каждой записи вызов оконной функции с аргументом `2` возвращает значение, которое хранится в поле `salary` второй по счету записи окна — `10000`, а вызов с аргументом `3` — значение, которое хранится в поле `salary` третьей по счету записи окна — `7000`.

Во время использования функции `NTH_VALUE()`, как и в случае с функцией `LAST_VALUE()`, важно следить за тем, как определены границы окна, в противном случае оконная функция может не дать нужного результата. 

<hr>

[Содержание](#содержание)

## Примечания 5.1

**Примечание 1.** Функции `FIRST_VALUE()`, `LAST_VALUE()` и `NTH_VALUE()`, называемые функциями смещения, практически всегда используются только с упорядоченными окнами.

**Примечание 2.** Функция `NTH_VALUE()` возвращает значение `NULL`, если пытается получить значение записи, выходящей за рамки окна.

Результатом приведенного ниже запроса:

```sql
SELECT id, full_name, salary,
       NTH_VALUE(salary, 11) OVER (ORDER BY id
                                   ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_employee_salary
FROM Employees;
```

является:

```
+----+-----------------+--------+----------------------+
| id | full_name       | salary | last_employee_salary |
+----+-----------------+--------+----------------------+
| 1  | Sergey Brin     | 10000  | NULL                 |
| 2  | John Doerr      | 10000  | NULL                 |
| 3  | Larry Page      | 7000   | NULL                 |
| 4  | Eric Schmidt    | 8000   | NULL                 |
| 5  | Sundar Pichai   | 11000  | NULL                 |
| 6  | Marissa Mayer   | 9000   | NULL                 |
| 7  | Susan Wojcicki  | 8000   | NULL                 |
| 8  | John Smith      | 7000   | NULL                 |
| 9  | Sheryl Sandberg | 9000   | NULL                 |
| 10 | Alice Johnson   | 12000  | NULL                 |
+----+-----------------+--------+----------------------+
```

В данном примере оконная функция пробует получить значение поля salary одиннадцатой записи окна, однако окно включает лишь десять записей.

<hr>

[Содержание](#содержание)

## Функция `LAG()`

Функция `LAG()` используется для получения значения, которое содержится в определенном поле записи окна, отстающей от текущей на n. Например, запись окна, отстающая от текущей на 1, считается предыдущей, на 2 — предпредыдущей, и так далее.

В качестве примера использования функции `LAG()` напишем запрос, который зарплате каждого сотрудника ставит в соответствие зарплату предыдущего сотрудника (сотрудника с идентификатором на единицу меньше).

Результатом приведенного ниже запроса:

```sql
SELECT id, full_name, salary,
       LAG(salary, 1) OVER (ORDER BY id) AS prev_employee_salary
FROM Employees;
```

является:

```
+----+-----------------+--------+----------------------+
| id | full_name       | salary | prev_employee_salary |
+----+-----------------+--------+----------------------+
| 1  | Sergey Brin     | 10000  | NULL                 |
| 2  | John Doerr      | 10000  | 10000                |
| 3  | Larry Page      | 7000   | 10000                |
| 4  | Eric Schmidt    | 8000   | 7000                 |
| 5  | Sundar Pichai   | 11000  | 8000                 |
| 6  | Marissa Mayer   | 9000   | 11000                |
| 7  | Susan Wojcicki  | 8000   | 9000                 |
| 8  | John Smith      | 7000   | 8000                 |
| 9  | Sheryl Sandberg | 9000   | 7000                 |
| 10 | Alice Johnson   | 12000  | 9000                 |
+----+-----------------+--------+----------------------+
```

Обратите внимание, что функция `LAG()` возвращает значение `NULL`, если пытается получить значение записи, выходящей за рамки окна. Так, в примере выше для первого сотрудника зарплатой предыдущего сотрудника считается `NULL`.

В случае выхода за рамки окна функция `LAG()` умеет возвращать не только `NULL`, но и любое другое значение. Для этого при вызове функции достаточно указать необходимое значение в качестве третьего аргумента.

Результатом приведенного ниже запроса:

```sql
SELECT id, full_name, salary,
       LAG(salary, 1, 0) OVER (ORDER BY id) AS prev_employee_salary
FROM Employees;
```

является:

```
+----+-----------------+--------+----------------------+
| id | full_name       | salary | prev_employee_salary |
+----+-----------------+--------+----------------------+
| 1  | Sergey Brin     | 10000  | 0                    |
| 2  | John Doerr      | 10000  | 10000                |
| 3  | Larry Page      | 7000   | 10000                |
| 4  | Eric Schmidt    | 8000   | 7000                 |
| 5  | Sundar Pichai   | 11000  | 8000                 |
| 6  | Marissa Mayer   | 9000   | 11000                |
| 7  | Susan Wojcicki  | 8000   | 9000                 |
| 8  | John Smith      | 7000   | 8000                 |
| 9  | Sheryl Sandberg | 9000   | 7000                 |
| 10 | Alice Johnson   | 12000  | 9000                 |
+----+-----------------+--------+----------------------+
```

Здесь функция `LAG()` в случае выхода за рамки окна возвращает число 0, поскольку именно оно указано в качестве третьего аргумента функции.

<hr>

[Содержание](#содержание)

## Функция `LEAD()`

Функция `LEAD()` используется для получения значения, которое содержится в определенном поле записи окна, опережающей текущую на n. Например, запись окна, опережающая текущую на 1, считается следующей, на 2 — следующей за следующей, и так далее.

В качестве примера использования данной функции напишем запрос, который зарплате каждого сотрудника ставит в соответствие зарплату следующего сотрудника (сотрудника с идентификатором на единицу больше).

Результатом приведенного ниже запроса:

```sql
SELECT id, full_name, salary,
       LEAD(salary, 1) OVER (ORDER BY id) AS next_employee_salary
FROM Employees;
```

является:

```
+----+-----------------+--------+----------------------+
| id | full_name       | salary | next_employee_salary |
+----+-----------------+--------+----------------------+
| 1  | Sergey Brin     | 10000  | 10000                |
| 2  | John Doerr      | 10000  | 7000                 |
| 3  | Larry Page      | 7000   | 8000                 |
| 4  | Eric Schmidt    | 8000   | 11000                |
| 5  | Sundar Pichai   | 11000  | 9000                 |
| 6  | Marissa Mayer   | 9000   | 8000                 |
| 7  | Susan Wojcicki  | 8000   | 7000                 |
| 8  | John Smith      | 7000   | 9000                 |
| 9  | Sheryl Sandberg | 9000   | 12000                |
| 10 | Alice Johnson   | 12000  | NULL                 |
+----+-----------------+--------+----------------------+
```

Обратите внимание, что в примере выше функция `LEAD()` применяется к упорядоченному окну, границы которого определены по умолчанию, однако при этом функция корректно определяет значение поля `salary` следующей записи. Дело в том, что функция `LEAD()` относится к числу функций, которые полностью игнорируют границы окна.

Таким образом, определенные в окне границы учитывают только агрегатные функции, а также функции смещения `FIRST_VALUE()`, `LAST_VALUE()` и `NTH_VALUE()`. Все остальные функции, в том числе `LAG()` и `LEAD()`, установленные границы игнорируют и выполняют свои вычисления в рамках всего окна (или секции окна, если было применено секционирование).

Функция `LEAD()`, как и функция `LAG()`, может принимать третий аргумент, определяющий значение, которое будет возвращено при попытке получить значение записи, выходящей за рамки окна.

Результатом приведенного ниже запроса:

```sql
SELECT id, full_name, salary,
       LEAD(salary, 1, 0) OVER (ORDER BY id) AS next_employee_salary
FROM Employees;
```

является:

```
+----+-----------------+--------+----------------------+
| id | full_name       | salary | next_employee_salary |
+----+-----------------+--------+----------------------+
| 1  | Sergey Brin     | 10000  | 10000                |
| 2  | John Doerr      | 10000  | 7000                 |
| 3  | Larry Page      | 7000   | 8000                 |
| 4  | Eric Schmidt    | 8000   | 11000                |
| 5  | Sundar Pichai   | 11000  | 9000                 |
| 6  | Marissa Mayer   | 9000   | 8000                 |
| 7  | Susan Wojcicki  | 8000   | 7000                 |
| 8  | John Smith      | 7000   | 9000                 |
| 9  | Sheryl Sandberg | 9000   | 12000                |
| 10 | Alice Johnson   | 12000  | 0                    |
+----+-----------------+--------+----------------------+
```

<hr>

[Содержание](#содержание)

## Примечания 5.2

**Примечание 1.** Функции `LAG()` и `LEAD()`, входящие в группу функций смещения, практически всегда используются только с упорядоченными окнами.

**Примечание 2.** Если во время использования функции `LAG()` опустить значение, определяющее то, на сколько запись отстает от текущей, оно по умолчанию примет значение 1. Аналогичное справедливо и для функции `LEAD()`.

Результатом приведенного ниже запроса:

```sql
SELECT id, full_name, salary,
       LAG(salary) OVER (ORDER BY id) AS prev_employee_salary,
       LEAD(salary) OVER (ORDER BY id) AS next_employee_salary
FROM Employees;
```

является:

```
+----+-----------------+--------+----------------------+----------------------+
| id | full_name       | salary | prev_employee_salary | next_employee_salary |
+----+-----------------+--------+----------------------+----------------------+
| 1  | Sergey Brin     | 10000  | NULL                 | 10000                |
| 2  | John Doerr      | 10000  | 10000                | 7000                 |
| 3  | Larry Page      | 7000   | 10000                | 8000                 |
| 4  | Eric Schmidt    | 8000   | 7000                 | 11000                |
| 5  | Sundar Pichai   | 11000  | 8000                 | 9000                 |
| 6  | Marissa Mayer   | 9000   | 11000                | 8000                 |
| 7  | Susan Wojcicki  | 8000   | 9000                 | 7000                 |
| 8  | John Smith      | 7000   | 8000                 | 9000                 |
| 9  | Sheryl Sandberg | 9000   | 7000                 | 12000                |
| 10 | Alice Johnson   | 12000  | 9000                 | NULL                 |
+----+-----------------+--------+----------------------+----------------------+
```

<hr>

[Содержание](#содержание)

# 11.6 Решение задач

## Третьи поездки в такси

Вам доступна база данных, принадлежащая службе такси Uber. Она включает таблицу Rides, которая хранит информацию о поездках пассажиров.

Таблица `Rides`

```
+--------------+--------+---------------------+
| passenger_id | amount | requested_on        |
+--------------+--------+---------------------+
| 1            | 30     | 2024-01-01 15:45:00 |
| 2            | 25     | 2024-02-12 07:00:00 |
| 3            | 15     | 2024-01-13 10:30:00 |
| 1            | 15     | 2024-02-08 18:15:00 |
| 1            | 35     | 2024-02-05 12:15:00 |
| 4            | 70     | 2024-01-20 11:55:00 |
| 4            | 110    | 2024-01-01 12:40:00 |
| 4            | 25     | 2024-02-01 21:30:00 |
| 3            | 80     | 2024-01-10 23:00:00 |
| 1            | 10     | 2024-01-02 18:10:00 |
+--------------+--------+---------------------+
```
Первое поле этой таблицы содержит идентификатор пассажира, второе — сумму поездки в долларах, третье — дату и время вызова такси.

Напишите запрос, который извлекает из предложенной базы данных всю информацию о третьей по счету поездке каждого пассажира.

Результат запроса

```
+--------------+--------+---------------------+
| passenger_id | amount | requested_on        |
+--------------+--------+---------------------+
| 1            | 35     | 2024-02-05 12:15:00 |
| 4            | 25     | 2024-02-01 21:30:00 |
+--------------+--------+---------------------+
```

Скрипт для создания таблицы `Rides`

```sql
DROP TABLE IF EXISTS Rides;
CREATE TABLE Rides
(
    passenger_id INT,
    amount INT,
    requested_on DATETIME
);

INSERT INTO Rides (passenger_id, amount, requested_on)
VALUES (1, 30, '2024-01-01 15:45:00'),
       (2, 25, '2024-02-12 07:00:00'),
       (3, 15, '2024-01-13 10:30:00'),
       (1, 15, '2024-02-08 18:15:00'),
       (1, 35, '2024-02-05 12:15:00'),
       (4, 70, '2024-01-20 11:55:00'),
       (4, 110, '2024-01-01 12:40:00'),
       (4, 25, '2024-02-01 21:30:00'),
       (3, 80, '2024-01-10 23:00:00'),
       (1, 10, '2024-01-02 18:10:00');
```

**Примечание 1.** Гарантируется, что хотя бы один из пассажиров совершил минимум три поездки.

**Примечание 2.** Записи в результирующей таблице могут быть расположены в произвольном порядке.

```sql
WITH third_ride AS (
    SELECT passenger_id,
           NTH_VALUE(amount, 3) OVER passengers AS amount,
           NTH_VALUE(requested_on, 3) OVER passengers AS requested_on
    FROM Rides
    WINDOW passengers AS (PARTITION BY passenger_id))

SELECT DISTINCT passenger_id,
       amount,
       requested_on
FROM third_ride
WHERE amount Is NOT NULL;
```

```sql
WITH NumberedRides AS (
    SELECT Rides.*,
           ROW_NUMBER() OVER (PARTITION BY passenger_id ORDER BY requested_on) AS ride_num
    FROM Rides
)
SELECT passenger_id, amount, requested_on
FROM NumberedRides
WHERE ride_num = 3;
```

<hr>

[Содержание](#содержание)
