# 4.  Встроенные функции

## Содержание

+ [4.1 Текстовые функции. Часть 1](#41-текстовые-функции-часть-1)
    + [Функции](#функции)
    + [Функция `CHAR_LENGTH()`](#функция-char_length)
    + [Функция `LOWER()`](#функция-lower)
    + [Функция `UPPER()`](#функция-upper)
    + [Функции `LTRIM()` и `RTRIM()`](#функции-ltrim-и-rtrim)
    + [Функция `REVERSE()`](#функция-reverse)
    + [Функция `REPEAT()`](#функция-repeat)
    + [Функции `LPAD()` и `RPAD()`](#функции-lpad-и-rpad)
    + [Примеры использования функций](#примеры-использования-функций-1)
+ [4.2 Текстовые функции. Часть 2](#42-текстовые-функции-часть-2)
    + [Функция `LEFT()`](#функция-left)
    + [Функция `RIGHT()`](#функция-right)
    + [Функция `LOCATE()`](#функция-locate)
    + [Функция `REPLACE()`](#функция-reverse)
+ [4.3 Текстовые функции. Часть 3](#43-текстовые-функции-часть-3)
    + [Функция `SUBSTRING()`](#функция-substring)
    + [Функция `SUBSTRING_INDEX()`](#функция-substring_index)
    + [Функция `TRIM()`](#функция-trim)
+ [4.4 Числовые функции. Часть 1](#44-числовые-функции-часть-1)
    + [Операторы `DIV` и `MOD`](#операторы-div-и-mod)
    + [Функция `ABS()`](#функция-abs)
    + [Функция `ROUND()`](#функция-round)
    + [Функция `POW()`](#функция-pow)
    + [Функция `SQRT()`](#функция-sqrt)
    + [Функция `RAND()`](#функция-rand)
+ [4.5 Числовые функции. Часть 2](#45-числовые-функции-часть-2)
    + [Функции `DEGREES()` и `RADIANS()`](#функции-degrees-и-radians)
    + [Функции  `PI()`, `COS()`, `SIN()` и `TAN()`](#функции-pi-sin-cos-и-tan)
    + [Функции `LEAST()` и `GREATEST()`](#функции-least-и-greatest)
    + [Функция `CONV()`](#функция-conv)
    + [Функция `FORMAT()`](#функция-format)
+ [4.6 Функции даты и времени. Часть 1](#46-функции-даты-и-времени-часть-1)
    + [Временные интервалы](#временные-интервалы)
    + [Функции `NOW()`, `CURDATE()` и `CURTIME()`](#функции-now-curdate-и-curtime)
    + [Функции `UTC_TIMESTAMP()`, `UTC_DATE()` и `UTC_TIME()`](#функции-utc_timestamp-utc_date-и-utc_time)
    + [Функция `MAKEDATE()`](#функция-makedate)
    + [Функция `MAKETIME()`](#функция-maketime)
    + [Функция `TIME_TO_SEC()` и `SEC_TO_TIME()`](#функция-time_to_sec-и-sec_to_time)
    + [Функции `TO_DAYS()` и `TO_SECONDS()`](#функции-to_days-и-to_seconds)
    + [Функция `LAST_DAY()`](#функция-last_day)
+ [4.7 Функции даты и времени. Часть 2](#47-функции-даты-и-времени-часть-2)
    + [Функции `DATE()` и `TIME()`](#функции-date-и-time)
    + [Функции `HOUR()`, `MINUTE()`, `SECOND()` и `MICROSECOND()`](#функции-hour-minute-second-и-microsecond)
    + [Функции `YEAR()`, `MONTH()` и `DAY()`](#функции-year-month-и-day)
    + [Функция `DAYOFYEAR()`](#функция-dayofyear)
    + [Функция `WEEK()`](#функция-week)
    + [Функция `WEEKDAY()`](#функция-weekday)
    + [Функция `QUARTER()`](#функция-quarter)
    + [Функция `DAYNAME()`](#функция-dayname)
    + [Функция `MONTHNAME()`](#функция-monthname)
+ [4.8 Функции даты и времени. Часть 3](#48-функции-даты-и-времени-часть-3)
    + [Функции `ADDDATE()` и `SUBDATE()`](#функции-adddate-и-subdate)
    + [Функции `ADDTIME()` и `SUBTIME()`](#функции-addtime-и-subtime)
    + [Функция `DATEDIFF()`](#функция-datediff)
    + [Функция `TIMEDIFF()`](#функция-timediff)
    + [Функция `TIMESTAMPDIFF()`](#функция-timestampdiff)
    + [Функция `TIMESTAMP()`](#функция-timestamp)
+ [4.9 Функции даты и времени. Часть 4](#49-функции-даты-и-времени-часть-4)
    + [Форматирование](#форматирование)
    + [Функция `DATE_FORMAT()`](#функция-date_format)
    + [Функция `TIME_FORMAT()`](#функция-time_format)
    + [Функция `STR_TO_DATE()`](#функция-str_to_date)
    + [Функция `GET_FORMAT()`](#функция-get_format)
+ [4.10 Дополнительные функции](#410-дополнительные-функции)
    + [Функция `ISNULL()`](#функция-isnull)
    + [Функция `IF()`](#функция-if)
    + [Функция `COALESCE()`](#функция-coalesce)
    + [Функция `IFNULL()`](#функция-ifnull)
    + [Функция `NULLIF()`](#функция-nullif)
    + [Функции `CONVERT()` и `CAST()`](#функции-convert-и-cast)
+ [4.11 Условные конструкции](#411-условные-конструкции)
    + [Оператор `CASE`](#оператор-case)
        + [Простая форма](#простая-форма)
        + [Усложненная форма](#усложненная-форма)

[Оглавление](/SQL_for_beginners/README.MD)

# 4.1 Текстовые функции. Часть 1

Урок посвящен функциям, предназначенным для обработки текстовых данных.

## Функции

Как и практически любой язык программирования, SQL имеет множество встроенных функций, которые позволяют выполнять различные манипуляции с данными. Все встроенные функции можно разбить на четыре основных типа:
+ **Текстовые функции.** Используются для обработки текста, например, для отсечения пробелов или преобразования символов в верхний регистр.
+ **Числовые функции.** Используются для выполнения математических операций над числовыми данными: например, возведения в степень или извлечения квадратного корня.
+ **Функции даты и времени.** Используются для обработки даты и времени, это может быть определение разницы между датами или проверка даты на корректность.
+ **Системные функции.** Используются для получения специфичной для конкретной СУБД информации, к примеру, сведений об учетной записи пользователя.

Одними из самых важных являются текстовые функции, так как таблицы баз данных зачастую содержат немалое количество текстовой информации. Поэтому знакомство со встроенными функциями мы начнем именно с тех, которые предназначены для обработки строковых значений.

Для более наглядной демонстрации работы рассматриваемых функций мы будем применять их к конкретным значениям, а не к полям какой-либо таблицы.

<hr>

[Содержание](#содержание)

## Функция `CHAR_LENGTH()`
Функция `CHAR_LENGTH()` используется для вычисления длины строки. Она принимает в качестве аргумента строку и возвращает количество символов в ней.

Результатом приведенного ниже запроса:

```sql
SELECT CHAR_LENGTH(''),
       CHAR_LENGTH('b'),
       CHAR_LENGTH('bee'),
       CHAR_LENGTH('beegeek');
```

является:

```
+-----------------+------------------+--------------------+------------------------+
| CHAR_LENGTH('') | CHAR_LENGTH('b') | CHAR_LENGTH('bee') | CHAR_LENGTH('beegeek') |
+-----------------+------------------+--------------------+------------------------+
| 0               | 1                | 3                  | 7                      |
+-----------------+------------------+--------------------+------------------------+
```

<hr>

[Содержание](#содержание)

## Функция `LOWER()`
Функция `LOWER()` используется для перевода строки в нижний регистр. Она принимает в качестве аргумента строку, преобразует все ее символы в нижний регистр и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT LOWER('beegeek'),
       LOWER('BeeGeek'),
       LOWER('BEEGEEK');
```

является:

```
+------------------+------------------+------------------+
| LOWER('beegeek') | LOWER('BeeGeek') | LOWER('BEEGEEK') |
+------------------+------------------+------------------+
| beegeek          | beegeek          | beegeek          |
+------------------+------------------+------------------+
```

<hr>

[Содержание](#содержание)

## Функция `UPPER()`

Функция `UPPER()` используется для перевода строки в верхний регистр. Она принимает в качестве аргумента строку, преобразует все ее символы в верхний регистр и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT UPPER('beegeek'),
       UPPER('BeeGeek'),
       UPPER('BEEGEEK');
```

является:

```
+------------------+------------------+------------------+
| UPPER('beegeek') | UPPER('BeeGeek') | UPPER('BEEGEEK') |
+------------------+------------------+------------------+
| BEEGEEK          | BEEGEEK          | BEEGEEK          |
+------------------+------------------+------------------+
```

<hr>

[Содержание](#содержание)

## Функции `LTRIM()` и `RTRIM()`

Функция `LTRIM()` используется для отсечения ведущих пробелов. Она принимает в качестве аргумента строку, удаляет все пробелы из ее левой части и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT LTRIM(' bee'),
       LTRIM('  bee'),
       LTRIM('   bee');
```

является:

```
+---------------+----------------+-----------------+
| LTRIM(' bee') | LTRIM('  bee') | LTRIM('   bee') |
+---------------+----------------+-----------------+
| bee           | bee            | bee             |
+---------------+----------------+-----------------+
```

Похожим образом работает функция `RTRIM()` за исключением того, что она удаляет пробелы из правой части строки, а не левой.

<hr>

[Содержание](#содержание)

## Функция `REVERSE()`

Функция `REVERSE()` используется для переворота строки. Она принимает в качестве аргумента строку и возвращает ее с обратным порядком символов.

Результатом приведенного ниже запроса:

```sql
SELECT REVERSE('b'),
       REVERSE('bee'),
       REVERSE('beegeek');
```

является:

```
+--------------+----------------+--------------------+
| REVERSE('b') | REVERSE('bee') | REVERSE('beegeek') |
+--------------+----------------+--------------------+
| b            | eeb            | keegeeb            |
+--------------+----------------+--------------------+
```

<hr>

[Содержание](#содержание)

## Функция `REPEAT()`

Функция `REPEAT()` используется для повторения строки. Она принимает два аргумента в следующем порядке:
+ `str` — исходная строка
+ `count` — количество повторений

Функция возвращает строку, состоящую из строки `str`, повторяющейся `count` раз.

Результатом приведенного ниже запроса:

```sql
SELECT REPEAT('bee', 1),
       REPEAT('bee', 2),
       REPEAT('bee', 3);
```

является:

```
+------------------+------------------+------------------+
| REPEAT('bee', 1) | REPEAT('bee', 2) | REPEAT('bee', 3) |
+------------------+------------------+------------------+
| bee              | beebee           | beebeebee        |
+------------------+------------------+------------------+
```

Если количество повторов меньше 1, то функция `REPEAT()` вернет пустую строку.

Результатом приведенного ниже запроса:

```sql
SELECT REPEAT('bee', 0),
       REPEAT('bee', -1);
```

является:

```
+------------------+-------------------+
| REPEAT('bee', 0) | REPEAT('bee', -1) |
+------------------+-------------------+
|                  |                   |
+------------------+-------------------+
```

<hr>

[Содержание](#содержание)

## Функции `LPAD()` и `RPAD()`

Функция `LPAD()` используется для увеличения длины строки до определенного значения путем добавления в ее начало другой строки. Она принимает три аргумента в следующем порядке:

+ `str` — исходная строка
+ `len` — желаемая длина строки
+ `padstr` — дополняющая строка

Функция добавляет строку `padstr` в начало строки `str` до тех пор, пока длина второй не станет равна `len`, и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT LPAD('bee', 5, '-'),
       LPAD('bee', 7, '-'),
       LPAD('bee', 9, '-+');
```
является:

```
+---------------------+---------------------+----------------------+
| LPAD('bee', 5, '-') | LPAD('bee', 7, '-') | LPAD('bee', 9, '-+') |
+---------------------+---------------------+----------------------+
| --bee               | ----bee             | -+-+-+bee            |
+---------------------+---------------------+----------------------+
```

Если длина исходной строки после добавления в ее начало дополняющей строки превышает желаемую длину, то функция `LPAD()` сокращает дополняющую строку путем отбрасывания правых символов.

Результатом приведенного ниже запроса:

```sql
SELECT LPAD('bee', 4, '-+-+'),
       LPAD('bee', 5, '-+-+'),
       LPAD('bee', 6, '-+-+');
```

является:

```
+------------------------+------------------------+------------------------+
| LPAD('bee', 4, '-+-+') | LPAD('bee', 5, '-+-+') | LPAD('bee', 6, '-+-+') |
+------------------------+------------------------+------------------------+
| -bee                   | -+bee                  | -+-bee                 |
+------------------------+------------------------+------------------------+
```

Если желаемая длина строки меньше длины исходной строки, то функция `LPAD()` сокращает исходную строку путем отбрасывания правых символов.

Результатом приведенного ниже запроса:

```sql
SELECT LPAD('bee', 2, '-'),
       LPAD('bee', 1, '-');
```

является:

```
+---------------------+---------------------+
| LPAD('bee', 2, '-') | LPAD('bee', 1, '-') |
+---------------------+---------------------+
| be                  | b                   |
+---------------------+---------------------+
```

Похожим образом себя ведет функция `RPAD()` за исключением того, что она дополняет строку не слева, а справа.

Результатом приведенного ниже запроса:

```sql
SELECT RPAD('bee', 5, '-'),
       RPAD('bee', 7, '-+'),
       RPAD('bee', 6, '-+-+'),
       RPAD('bee', 2, '-');
```

является: 

```sql
+---------------------+----------------------+------------------------+---------------------+
| RPAD('bee', 5, '-') | RPAD('bee', 7, '-+') | RPAD('bee', 6, '-+-+') | RPAD('bee', 2, '-') |
+---------------------+----------------------+------------------------+---------------------+
| bee--               | bee-+-+              | bee-+-                 | be                  |
+---------------------+----------------------+------------------------+---------------------+
```

<hr>

[Содержание](#содержание)

## Примечания 1

**Примечание 1.** Функции могут применяться как в блоке оператора `SELECT`, так и в блоках операторов `WHERE` и `ORDER BY`.

Предположим, во время работы с персональными данными людей нам необходимо выполнить их сортировку по именам, хранящимся в поле name, однако сортировка должна происходить не по прямым значениям имен, а по количеству символов в них. В рамках запроса такой вариант сортировки будет выглядеть следующим образом:

```sql
...
ORDER BY CHAR_LENGTH(name);
```

**Примечание 2.** Одним из недостатков функций является то, что в разных СУБД могут применяться разные функции для одних и тех же целей, и лишь некоторые функции в различных СУБД называются одинаково. Общая функциональность доступна в каждой СУБД, но названия функций и их синтаксис могут существенно отличаться. 

**Примечание 3.** Функции `CHAR_LENGTH()`, `LOWER()`, `UPPER()`, `LTRIM()`, `RTRIM()`, `REVERSE()`, `REPEAT()`, `LPAD()` и `RPAD()` при вызове с аргументом `NULL` возвращают значение `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT CHAR_LENGTH(NULL)  AS value1,
       LOWER(NULL)        AS value2,
       UPPER(NULL)        AS value3,
       LTRIM(NULL)        AS value4,
       REVERSE(NULL)      AS value5,
       REPEAT(NULL, 2)    AS value6,
       LPAD(NULL, 5, '-') AS value7;
```

является:

```
+--------+--------+--------+--------+--------+--------+--------+
| value1 | value2 | value3 | value4 | value5 | value6 | value7 |
+--------+--------+--------+--------+--------+--------+--------+
| NULL   | NULL   | NULL   | NULL   | NULL   | NULL   | NULL   |
+--------+--------+--------+--------+--------+--------+--------+
```

**Примечание 4.** Несмотря на то что функции `CHAR_LENGTH()`, `REVERSE()`, `REPEAT()`, `LPAD()` и `RPAD()` в первую очередь предназначены для работы со строковыми значениями, они также могут обрабатывать и числовые данные.

Результатом приведенного ниже запроса:

```sql
SELECT CHAR_LENGTH(123),
       REVERSE(123),
       REPEAT(123, 2),
       LPAD(123, 4, '-');
```

является:

```
+------------------+--------------+----------------+-------------------+
| CHAR_LENGTH(123) | REVERSE(123) | REPEAT(123, 2) | LPAD(123, 4, '-') |
+------------------+--------------+----------------+-------------------+
| 3                | 321          | 123123         | -123              |
+------------------+--------------+----------------+-------------------+
```

<hr>

[Содержание](#содержание)

## Примеры использования функций 1

В начале урока мы рассмотрели примеры использования функций, в которых они применяются к конкретным значениям. В связи с этим у многих из вас возникли сложности с применением функций к полям таблицы, поэтому мы решили добавить несколько таких примеров.

**Используемая база данных**

Перед тем как приступить к рассмотрению примеров, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем Songs, которая содержит информацию о пяти наиболее популярных песнях на некоторой площадке для прослушивания музыки:

```
+----+-------+----------------------+------------+---------+
| id | place | trackname            | artist     | streams |
+----+-------+----------------------+------------+---------+
| 1  | 4     | Crazy On You         | Heart      | 76338   |
| 2  | 3     | My Lover             | The Sounds | 99488   |
| 3  | 2     | Running up That Hill | Kate Bush  | 121495  |
| 4  | 5     | Thrill               | The Sounds | 49345   |
| 5  | 1     | Spent the Day in Bed | Morrissey  | 174994  |
+----+-------+----------------------+------------+---------+
```

Первое поле этой таблицы содержит уникальный идентификатор песни, второе — позицию песни в топе, третье — название песни, четвертое — псевдоним исполнителя или название группы, пятое — количество прослушиваний.

Скрипт для создания таблицы Songs

```sql
DROP TABLE IF EXISTS Songs;
CREATE TABLE Songs
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    place     INT,
    trackname VARCHAR(30),
    artist    VARCHAR(30),
    streams   INT
);

INSERT INTO Songs (place, trackname, artist, streams)
VALUES (4, 'Crazy On You', 'Heart', 76338),
       (3, 'My Lover', 'The Sounds', 99488),
       (2, 'Running up That Hill', 'Kate Bush', 121495),
       (5, 'Thrill', 'The Sounds', 49345),
       (1, 'Spent the Day in Bed', 'Morrissey', 174994);
```

## Применение функций 1

Для того, чтобы применить функцию к полю таблицы, достаточно просто указать это поле в качестве аргумента функции. Давайте рассмотрим несколько примеров.

**Пример 1.** Необходимо извлечь имена исполнителей, а также посчитать количество символов в именах исполнителей. Для этого мы можем использовать функцию `CHAR_LENGTH()`.

Результатом приведенного ниже запроса:

```sql
SELECT artist, CHAR_LENGTH(artist) AS length
FROM Songs;
```

является:

```
+------------+--------+
| artist     | length |
+------------+--------+
| Heart      | 5      |
| The Sounds | 10     |
| Kate Bush  | 9      |
| The Sounds | 10     |
| Morrissey  | 9      |
+------------+--------+
```

**Пример 2.** Необходимо извлечь имена исполнителей и названия их песен, при этом названия песен должны быть отображены в нижнем регистре. Для этого мы можем использовать функцию `LOWER()`.

Результатом приведенного ниже запроса:

```sql
SELECT artist, LOWER(trackname) AS trackname
FROM Songs;
```

является:

```
+------------+----------------------+
| artist     | trackname            |
+------------+----------------------+
| Heart      | crazy on you         |
| The Sounds | my lover             |
| Kate Bush  | running up that hill |
| The Sounds | thrill               |
| Morrissey  | spent the day in bed |
+------------+----------------------+
```

**Пример 3.** Необходимо извлечь имена исполнителей и названия их песен, при этом названия песен должны быть отображены в верхнем регистре в обратном порядке. Для этого мы можем использовать функции `UPPER()` и `REVERSE()`.

Результатом приведенного ниже запроса:

```sql
SELECT artist, REVERSE(UPPER(trackname)) AS trackname
FROM Songs;
```

является:

```
+------------+----------------------+
| artist     | trackname            |
+------------+----------------------+
| Heart      | UOY NO YZARC         |
| The Sounds | REVOL YM             |
| Kate Bush  | LLIH TAHT PU GNINNUR |
| The Sounds | LLIRHT               |
| Morrissey  | DEB NI YAD EHT TNEPS |
+------------+----------------------+
```

Результатом выполнения функции является определенное значение, поэтому функцию можно использовать в качестве аргумента другой функции. В этом примере сначала функция `UPPER()` переводит строку в верхний регистр, а затем функция `REVERSE()` переворачивает эту строку. При этом, если поменять функции местами, результат не изменится.

Результатом приведенного ниже запроса:

```sql
SELECT artist, UPPER(REVERSE(trackname)) AS trackname
FROM Songs;
```

является:

```
+------------+----------------------+
| artist     | trackname            |
+------------+----------------------+
| Heart      | UOY NO YZARC         |
| The Sounds | REVOL YM             |
| Kate Bush  | LLIH TAHT PU GNINNUR |
| The Sounds | LLIRHT               |
| Morrissey  | DEB NI YAD EHT TNEPS |
+------------+----------------------+
```

Разница заключается лишь в том, что сначала выполнится функция `REVERSE()`, а только потом `UPPER()`. Но при перестановке функций результат не всегда будет одинаковым, в некоторых случаях порядок вложения функций нужно соблюдать.

**Пример 4.** Необходимо извлечь имена исполнителей, при этом каждое имя необходимо развернуть, а затем дополнить символом ! с начала строки до длины 20. Для этого мы можем использовать функции `REVERSE()` и `LPAD()`.

Результатом приведенного ниже запроса:

```sql
SELECT artist, LPAD(REVERSE(artist), 20, '!') AS result
FROM Songs;
```

является:

```
+------------+----------------------+
| artist     | result               |
+------------+----------------------+
| Heart      | !!!!!!!!!!!!!!!traeH |
| The Sounds | !!!!!!!!!!sdnuoS ehT |
| Kate Bush  | !!!!!!!!!!!hsuB etaK |
| The Sounds | !!!!!!!!!!sdnuoS ehT |
| Morrissey  | !!!!!!!!!!!yessirroM |
+------------+----------------------+
```

В этом примере сначала функция `REVERSE()` переворачивает строку, а затем функция `LPAD()` дополняет ее символом `!`. Это пример того, где порядок вложения функций имеет значение. Если мы поменяем функции местами, результат уже будет другим.

Результатом приведенного ниже запроса:

```sql
SELECT artist, REVERSE(LPAD(artist, 20, '!')) AS result
FROM Songs;
```

является:

```
+------------+----------------------+
| artist     | result               |
+------------+----------------------+
| Heart      | traeH!!!!!!!!!!!!!!! |
| The Sounds | sdnuoS ehT!!!!!!!!!! |
| Kate Bush  | hsuB etaK!!!!!!!!!!! |
| The Sounds | sdnuoS ehT!!!!!!!!!! |
| Morrissey  | yessirroM!!!!!!!!!!! |
+------------+----------------------+
```

<hr>

[Содержание](#содержание)

# 4.2 Текстовые функции. Часть 2

Урок посвящен функциям, предназначенным для обработки текстовых данных.

## Функция `LEFT()`

Функция `LEFT()` используется для извлечения определенного количества символов из начала строки. Она принимает два аргумента в следующем порядке:
+ `str` — исходная строка
+ `count` — количество извлекаемых символов

Функция возвращает строку, состоящую из первых `count` символов строки `str`.

Результатом приведенного ниже запроса:

```sql
SELECT LEFT('beegeek', 1),
       LEFT('beegeek', 3),
       LEFT('beegeek', 7);
```

является:

```
+--------------------+--------------------+--------------------+
| LEFT('beegeek', 1) | LEFT('beegeek', 3) | LEFT('beegeek', 7) |
+--------------------+--------------------+--------------------+
| b                  | bee                | beegeek            |
+--------------------+--------------------+--------------------+
```

Если количество извлекаемых символов меньше 1, функция `LEFT()` вернет пустую строку.

Результатом приведенного ниже запроса:

```sql
SELECT LEFT('beegeek', 0),
       LEFT('beegeek', -1);
```

является:

```
+--------------------+---------------------+
| LEFT('beegeek', 0) | LEFT('beegeek', -1) |
+--------------------+---------------------+
|                    |                     |
+--------------------+---------------------+
```

Если количество извлекаемых символов больше длины строки, функция `LEFT()` вернет всю строку.

Результатом приведенного ниже запроса:

```sql
SELECT LEFT('beegeek', 50),
       LEFT('beegeek', 100);
```

является:

```
+---------------------+----------------------+
| LEFT('beegeek', 50) | LEFT('beegeek', 100) |
+---------------------+----------------------+
| beegeek             | beegeek              |
+---------------------+----------------------+
```

<hr>

[Содержание](#содержание)

## Функция `RIGHT()`
Функция `RIGHT()` используется для извлечения определенного количества символов из конца строки. Она принимает два аргумента в следующем порядке:
+ `str` — исходная строка
+ `count` — количество извлекаемых символов

Функция возвращает строку, состоящую из последних `count` символов строки `str`.

Результатом приведенного ниже запроса:

```sql
SELECT RIGHT('beegeek', 1),
       RIGHT('beegeek', 3),
       RIGHT('beegeek', 7);
```

является:

```
+---------------------+---------------------+---------------------+
| RIGHT('beegeek', 1) | RIGHT('beegeek', 3) | RIGHT('beegeek', 7) |
+---------------------+---------------------+---------------------+
| k                   | eek                 | beegeek             |
+---------------------+---------------------+---------------------+
```

Аналогично функции `LEFT()`, если количество извлекаемых символов меньше 1, функция `RIGHT()` вернет пустую строку, если больше длины строки — всю строку.

<hr>

[Содержание](#содержание)

## Функция `LOCATE()`

Функция `LOCATE()` используется для определения местоположения подстроки в строке. Она принимает три аргумента в следующем порядке:
+ `substr` — искомая подстрока
+ `str` — исходная строка
+ `start` — позиция начала поиска (может не указываться, в таком случае поиск выполняется с начала строки)

Функция выполняет поиск подстроки `substr` в строке `str`, начиная с позиции `start`, и возвращает позицию ее первого вхождения.

Результатом приведенного ниже запроса:

```sql
SELECT LOCATE('e', 'beegeek'),
       LOCATE('g', 'beegeek'),
       LOCATE('eg', 'beegeek'),
       LOCATE('geek', 'beegeek');
```

является:


| LOCATE('e', 'beegeek') | LOCATE('g', 'beegeek') | LOCATE('eg', 'beegeek') | LOCATE('geek', 'beegeek') |
-|-|-|-
| 2                      | 4                      | 3                       | 4                         |

Обратите внимание, что при использовании функции `LOCATE()` символы исходной строки нумеруются с 1, а не с 0.

Результатом приведенного ниже запроса:

```sql
SELECT LOCATE('e', 'beegeek', 2),
       LOCATE('e', 'beegeek', 4);
```

является:

```
+---------------------------+---------------------------+
| LOCATE('e', 'beegeek', 2) | LOCATE('e', 'beegeek', 4) |
+---------------------------+---------------------------+
| 2                         | 5                         |
+---------------------------+---------------------------+
```

Также следует отметить, что функция `LOCATE()` выполняет поиск позиции подстроки без учета регистра.

Результатом приведенного ниже запроса:

```sql
SELECT LOCATE('E', 'beegeek'),
       LOCATE('GEEK', 'beegeek');
```

является:

```
+------------------------+---------------------------+
| LOCATE('E', 'beegeek') | LOCATE('GEEK', 'beegeek') |
+------------------------+---------------------------+
| 2                      | 4                         |
+------------------------+---------------------------+
```

Если искомой подстроки в строке нет, функция `LOCATE()` вернет значение 0.

Результатом приведенного ниже запроса:

```sql
SELECT LOCATE('a', 'beegeek'),
       LOCATE('eb', 'beegeek');
```

является:

```
+------------------------+-------------------------+
| LOCATE('a', 'beegeek') | LOCATE('eb', 'beegeek') |
+------------------------+-------------------------+
| 0                      | 0                       |
+------------------------+-------------------------+
```

<hr>

[Содержание](#содержание)

## Функция `REPLACE()`

Функция `REPLACE()` используется для замены подстроки в строке. Она принимает три аргумента в следующем порядке:
+ `str` — исходная строка
+ `from_str` — заменяемая подстрока
+ `to_str` — заменяющая подстрока

Функция заменяет все вхождения подстроки `from_str` в строке `str` на подстроку `to_str` и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT REPLACE('beegeek', 'e', 'i'),
       REPLACE('beegeek', 'geek', 'g'),
       REPLACE('beegeek', 'geek', 'Geek');
```

является:

| REPLACE <br> ('beegeek', 'e', 'i') | REPLACE <br> ('beegeek', 'geek', 'g') | REPLACE <br> ('beegeek', 'geek', 'Geek') |
-|-|-
| biigiik   | beeg  | beeGeek    |

Если заменяемой подстроки в строке нет, функция `REPLACE()` вернет строку в исходном виде.

Результатом приведенного ниже запроса:

```sql
SELECT REPLACE('beegeek', 'a', 'i'),
       REPLACE('beegeek', 'keeg', 'Keeg');
```

является:

```
+------------------------------+------------------------------------+
| REPLACE('beegeek', 'a', 'i') | REPLACE('beegeek', 'keeg', 'Keeg') |
+------------------------------+------------------------------------+
| beegeek                      | beegeek                            |
+------------------------------+------------------------------------+
```

В отличие от функции `LOCATE()`, функция `REPLACE()` выполняет замену с учетом регистра.

Результатом приведенного ниже запроса:

```sql
SELECT REPLACE('beegeek', 'B', 'BBB'),
       REPLACE('beegeek', 'b', 'bbb');
```

является:

```
+--------------------------------+--------------------------------+
| REPLACE('beegeek', 'B', 'BBB') | REPLACE('beegeek', 'b', 'bbb') |
+--------------------------------+--------------------------------+
| beegeek                        | bbbeegeek                      |
+--------------------------------+--------------------------------+
```

<hr>

[Содержание](#содержание)

# 4.3 Текстовые функции. Часть 3

Урок посвящен функциям, предназначенным для обработки текстовых данных.

## Функция `SUBSTRING()`

Функция `SUBSTRING()` используется для извлечения подстроки из строки. Она принимает три аргумента в следующем порядке:
+ `str` — исходная строка
+ `start` — позиция первого извлекаемого символа
+ `len` — длина извлекаемой подстроки (может не указываться, в таком случае подстрока извлекается до конца)

Функция извлекает из строки `str` подстроку длины `len`, начиная с символа с позицией `start`, и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT SUBSTRING('beegeek', 1),
       SUBSTRING('beegeek', 4),
       SUBSTRING('beegeek', 4, 2);
```

является:

```
+-------------------------+-------------------------+----------------------------+
| SUBSTRING('beegeek', 1) | SUBSTRING('beegeek', 4) | SUBSTRING('beegeek', 4, 2) |
+-------------------------+-------------------------+----------------------------+
| beegeek                 | geek                    | ge                         |
+-------------------------+-------------------------+----------------------------+
```

Обратите внимание, что при использовании функции `SUBSTRING()` символы исходной строки нумеруются с 1, а не с 0.

Позиция первого извлекаемого символа может быть отрицательным числом, в таком случае символы нумеруются с конца. Последнему символу соответствует позиция -1, предпоследнему — -2, и так далее.

Результатом приведенного ниже запроса:

```sql
SELECT SUBSTRING('beegeek', -7),
       SUBSTRING('beegeek', -4),
       SUBSTRING('beegeek', -4, 3);
```
является:

```
+--------------------------+--------------------------+-----------------------------+
| SUBSTRING('beegeek', -7) | SUBSTRING('beegeek', -4) | SUBSTRING('beegeek', -4, 3) |
+--------------------------+--------------------------+-----------------------------+
| beegeek                  | geek                     | gee                         |
+--------------------------+--------------------------+-----------------------------+
```

<hr>

[Содержание](#содержание)

## Функция `SUBSTRING_INDEX()`

Функция `SUBSTRING_INDEX()` используется для извлечения подстроки из строки с помощью разделителя. Она принимает три аргумента в следующем порядке:
+ `str` — исходная строка
+ `delimiter` — разделитель
+ `count` — количество появлений разделителя
Функция возвращает подстроку, входящую в `str`, перед `count` появлением разделителя `delimiter`.

Результатом приведенного ниже запроса:

```sql
SELECT SUBSTRING_INDEX('g-e-e-k', '-', 1),
       SUBSTRING_INDEX('g-e-e-k', '-', 2),
       SUBSTRING_INDEX('g-e-e-k', '-', 3);
```

является:

```
+------------------------------------+------------------------------------+------------------------------------+
| SUBSTRING_INDEX('g-e-e-k', '-', 1) | SUBSTRING_INDEX('g-e-e-k', '-', 2) | SUBSTRING_INDEX('g-e-e-k', '-', 3) |
+------------------------------------+------------------------------------+------------------------------------+
| g                                  | g-e                                | g-e-e                              |
+------------------------------------+------------------------------------+------------------------------------+
```

В примере выше рассматривается строка g-e-e-k с разделителем в виде символа -. Разделитель встречается в строке три раза. Подстрока, входящая в строку перед первым появлением разделителя, равна g, перед вторым появлением — g-e, перед третьим появлением — g-e-e.

Если указанное количество появлений разделителя больше количества раз, которое разделитель встречается в строке, функция SUBSTRING_INDEX() вернет всю строку.

Результатом приведенного ниже запроса:

```sql
SELECT SUBSTRING_INDEX('g-e-e-k', '-', 4),
       SUBSTRING_INDEX('g-e-e-k', '-', 10);
```

является:

```
+------------------------------------+-------------------------------------+
| SUBSTRING_INDEX('g-e-e-k', '-', 4) | SUBSTRING_INDEX('g-e-e-k', '-', 10) |
+------------------------------------+-------------------------------------+
| g-e-e-k                            | g-e-e-k                             |
+------------------------------------+-------------------------------------+
```

Количество появлений разделителя может быть отрицательным числом, в таком случае извлечение подстроки происходит с конца.

Результатом приведенного ниже запроса:

```sql
SELECT SUBSTRING_INDEX('g-e-e-k', '-', -2),
       SUBSTRING_INDEX('g-e-e-k', '-', -3);
```

является:

```
+-------------------------------------+-------------------------------------+
| SUBSTRING_INDEX('g-e-e-k', '-', -2) | SUBSTRING_INDEX('g-e-e-k', '-', -3) |
+-------------------------------------+-------------------------------------+
| e-k                                 | e-e-k                               |
+-------------------------------------+-------------------------------------+
```

Если разделителя в строке нет, функция `SUBSTRING_INDEX()` вернет строку в исходном виде.

Результатом приведенного ниже запроса:

```sql
SELECT SUBSTRING_INDEX('geek', '-', 1),
       SUBSTRING_INDEX('geek', '-', -1);
```

является:

```
+---------------------------------+----------------------------------+
| SUBSTRING_INDEX('geek', '-', 1) | SUBSTRING_INDEX('geek', '-', -1) |
+---------------------------------+----------------------------------+
| geek                            | geek                             |
+---------------------------------+----------------------------------+
```

Функция `SUBSTRING_INDEX()` выполняет поиск разделителя в строке с учетом регистра.

<hr>

[Содержание](#содержание)

## Функция `TRIM()`

Функция `TRIM()` используется для удаления всех вхождений подстроки из начала и/или конца строки. Синтаксис данной функции несколько отличается от предыдущих, так как при ее вызове аргументы не указываются через запятую, а связываются с помощью ключевого слова `FROM`:

```sql
TRIM(<ключевое слово LEADING, TRAILING или BOTH> <удаляемая подстрока> FROM <исходная строка>)
```

Ключевые слова `LEADING`, `TRAILING` и `BOTH` определяют, откуда будет происходить удаление подстроки:
+ `LEADING` — из начала строки
+ `TRAILING`  — из конца строки
+ `BOTH` — из начала и конца строки
Результатом приведенного ниже запроса:

```sql
SELECT TRIM(LEADING '-' FROM '--bee--'),
       TRIM(TRAILING '-' FROM '--bee--'),
       TRIM(BOTH '-' FROM '--bee--');
```

является:

```
+----------------------------------+-----------------------------------+-------------------------------+
| TRIM(LEADING '-' FROM '--bee--') | TRIM(TRAILING '-' FROM '--bee--') | TRIM(BOTH '-' FROM '--bee--') |
+----------------------------------+-----------------------------------+-------------------------------+
| bee--                            | --bee                             | bee                           |
+----------------------------------+-----------------------------------+-------------------------------+
```

Ключевые слова `LEADING`, `TRAILING` и `BOTH` могут не указываться, в таком случае удаление подстроки происходит из начала и конца строки.

Результатом приведенного ниже запроса:

```sql
SELECT TRIM('-' FROM '--bee--');
```

является:

```
+--------------------------+
| TRIM('-' FROM '--bee--') |
+--------------------------+
| bee                      |
+--------------------------+
```

Удаляемая подстрока также может быть опущена, в таком случае ею считается пробел.

Результатом приведенного ниже запроса:

```sql
SELECT TRIM(LEADING FROM '   bee   '),
       TRIM(TRAILING FROM '   bee   '),
       TRIM(BOTH FROM '   bee   ');
```

является:

```
+--------------------------------+---------------------------------+-----------------------------+
| TRIM(LEADING FROM '   bee   ') | TRIM(TRAILING FROM '   bee   ') | TRIM(BOTH FROM '   bee   ') |
+--------------------------------+---------------------------------+-----------------------------+
| bee                            |    bee                          | bee                         |
+--------------------------------+---------------------------------+-----------------------------+
```

Если не указаны и ключевое слово, и удаляемая подстрока, функция `TRIM()` выполнит удаление всех пробелов из начала и конца строки.

Результатом приведенного ниже запроса:

```sql
SELECT TRIM(' bee '),
       TRIM('   bee   ');
```

является:

```
+---------------+-------------------+
| TRIM(' bee ') | TRIM('   bee   ') |
+---------------+-------------------+
| bee           | bee               |
+---------------+-------------------+
```

Обратите внимание, что при таком варианте использования функции ключевое слово FROM указывать не нужно.

<hr>

[Содержание](#содержание)

## Примечания 3

**Примечание 1.** Во время использования функции `TRIM()` нужно хорошо понимать принцип ее работы.

Результатом приведенного ниже запроса:

```sql
SELECT TRIM('+-' FROM '+-+-bee+-+-+-');
```

является:

```
+---------------------------------+
| TRIM('+-' FROM '+-+-bee+-+-+-') |
+---------------------------------+
| bee                             |
+---------------------------------+
```

В данном примере из начала и конца строки +-+-bee+-+-+- удаляются подстроки +-. В начале подстрока встречается два раза — +-+-, в конце подстрока встречается три раза — +-+-+-.

Результатом приведенного ниже запроса:

```sql
SELECT TRIM('+-' FROM '+-+bee+-+');
```

является:

```
+-----------------------------+
| TRIM('+-' FROM '+-+bee+-+') |
+-----------------------------+
| +bee+-+                     |
+-----------------------------+
```

В этом примере подстрока +- удаляется из начала и конца строки +-+bee+-+. В начале подстрока встречается один раз — +-, в конце подстрока не встречается ни разу. 

**Примечание 2.** В SQL реализованы практически все необходимые функции для работы с текстовыми данными, и нами была рассмотрена большая их часть, однако не все. Так, среди пропущенных функций можно выделить функцию `SPACE()`, возвращающую строку из заданного числа пробелов, или функции `ORD()` и `CHAR()`, с помощью которых можно получить числовой код символа в ASCII-таблице и наоборот. При необходимости со списком всех текстовых функций можно ознакомиться по [ссылке](https://docs-python.ru/packages/klient-bd-mysql/funktsii-raboty-strokami-bd-mysql/).

<hr>

[Содержание](#содержание)

# 4.4 Числовые функции. Часть 1

Урок посвящен функциям, предназначенным для обработки числовых данных.

## Операторы `DIV` и `MOD`

Оператор `DIV` используется для целочисленного деления одного числа на другое.

Результатом приведенного ниже запроса:

```sql
SELECT 11 DIV 2,
       11 DIV 3,
       11 DIV 4;
```

является:

```
+----------+----------+----------+
| 11 DIV 2 | 11 DIV 3 | 11 DIV 4 |
+----------+----------+----------+
| 5        | 3        | 2        |
+----------+----------+----------+
```

Оператор `MOD` используется для вычисления остатка от деления одного числа на другое.

Результатом приведенного ниже запроса:

```sql
SELECT 11 MOD 2,
       11 MOD 3,
       11 MOD 4;
```

является:

```
+----------+----------+----------+
| 11 MOD 2 | 11 MOD 3 | 11 MOD 4 |
+----------+----------+----------+
| 1        | 2        | 3        |
+----------+----------+----------+
```

Помимо оператора `MOD`, для вычисления остатка от деления можно использовать оператор `%` или функцию `MOD()`.

Результатом приведенного ниже запроса:

```sql
SELECT 11 MOD 3,
       11 % 3,
       MOD(11, 3);
```

является:

```
+----------+--------+------------+
| 11 MOD 3 | 11 % 3 | MOD(11, 3) |
+----------+--------+------------+
| 2        | 2      | 2          |
+----------+--------+------------+
```

Подробнее с операциями целочисленного деления и деления с остатком можно ознакомиться по [ссылке](https://ru.wikipedia.org/wiki/Деление_с_остатком).

<hr>

[Содержание](#содержание)

## Функция `ABS()`

Функция `ABS()` используется для вычисления модуля числа. Она принимает в качестве аргумента число и возвращает его модуль.

Результатом приведенного ниже запроса:

```sql
SELECT ABS(-1),
       ABS(-2.1234),
       ABS(0),
       ABS(35);
```

является:

```
+---------+--------------+--------+---------+
| ABS(-1) | ABS(-2.1234) | ABS(0) | ABS(35) |
+---------+--------------+--------+---------+
| 1       | 2.1234       | 0      | 35      |
+---------+--------------+--------+---------+
```

<hr>

[Содержание](#содержание)

## Функция `ROUND()`

Функция `ROUND()` используется для округления числа. Она принимает два аргумента в следующем порядке:
+ `num` — число
+ `decimals` — количество знаков после запятой

Функция возвращает число `num`, округленное до `decimals` знаков после запятой.

Результатом приведенного ниже запроса:

```sql
SELECT ROUND(23.1653, 3),
       ROUND(23.1653, 2),
       ROUND(23.1653, 1),
       ROUND(23.1653, 0);
```

является:

```
+-------------------+-------------------+-------------------+-------------------+
| ROUND(23.1653, 3) | ROUND(23.1653, 2) | ROUND(23.1653, 1) | ROUND(23.1653, 0) |
+-------------------+-------------------+-------------------+-------------------+
| 23.165            | 23.17             | 23.2              | 23                |
+-------------------+-------------------+-------------------+-------------------+
```

Обратите внимание, что функция `ROUND()` округляет число согласно математическим правилам округления, то есть в большую по модулю сторону.

Результатом приведенного ниже запроса:

```sql
SELECT ROUND(23.165, 2),
       ROUND(-23.165, 2);
```

является:

```
+------------------+-------------------+
| ROUND(23.165, 2) | ROUND(-23.165, 2) |
+------------------+-------------------+
| 23.17            | -23.17            |
+------------------+-------------------+
```

Количество знаков после запятой может быть не указано, в таком случае функция `ROUND()` выполнит округление до целого числа.

Результатом приведенного ниже запроса:

```sql
SELECT ROUND(23.3),
       ROUND(23.5),
       ROUND(23.7),
       ROUND(-23.3),
       ROUND(-23.5),
       ROUND(-23.7);
```

является:

```
+-------------+-------------+-------------+--------------+--------------+--------------+
| ROUND(23.3) | ROUND(23.5) | ROUND(23.7) | ROUND(-23.3) | ROUND(-23.5) | ROUND(-23.7) |
+-------------+-------------+-------------+--------------+--------------+--------------+
| 23          | 24          | 24          | -23          | -24          | -24          |
+-------------+-------------+-------------+--------------+--------------+--------------+
```

<hr>

[Содержание](#содержание)

## Функция `POW()`

Функция `POW()` используется для возведения числа в определенную степень. Она принимает два аргумента в следующем порядке:
+ `num` — число
+ `degree` — показатель степени

Функция возвращает число `num`, возведенное в степень `degree`.

Результатом приведенного ниже запроса:

```sql
SELECT POW(2, 3),
       POW(3, 5),
       POW(4, 0),
       POW(5, -1);
```

является:

```
+-----------+-----------+-----------+------------+
| POW(2, 3) | POW(3, 5) | POW(4, 0) | POW(5, -1) |
+-----------+-----------+-----------+------------+
| 8.0       | 243.0     | 1.0       | 0.2        |
+-----------+-----------+-----------+------------+
```

<hr>

[Содержание](#содержание)

## Функция `SQRT()`

Функция `SQRT()` используется для вычисления квадратного корня. Она принимает в качестве аргумента число, извлекает из него квадратный корень и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT SQRT(0),
       SQRT(9),
       SQRT(20);
```

является:

```
+---------+---------+------------------+
| SQRT(0) | SQRT(9) | SQRT(20)         |
+---------+---------+------------------+
| 0.0     | 3.0     | 4.47213595499958 |
+---------+---------+------------------+
```

Если переданное в качестве аргумента число меньше нуля, функция `SQRT()` вернет значение `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT SQRT(-1),
       SQRT(-100);
```

является:

```
+----------+------------+
| SQRT(-1) | SQRT(-100) |
+----------+------------+
| NULL     | NULL       |
+----------+------------+
```

<hr>

[Содержание](#содержание)

## Функция `RAND()`

Функция `RAND()` используется для генерации случайных чисел. При вызове без аргументов она возвращает случайное число с плавающей точкой в диапазоне $[0, 1)$.

Результатом приведенного ниже запроса:

```sql
SELECT RAND(),
       RAND(),
       RAND();
```

может являться:

```
+-------------------+--------------------+---------------------+
| RAND()            | RAND()             | RAND()              |
+-------------------+--------------------+---------------------+
| 0.338787759038422 | 0.8266121575856694 | 0.11669754154672617 |
+-------------------+--------------------+---------------------+
```

Функция может принимать один необязательный аргумент — целое число, определяющее начальное значение при генерации случайного числа. С одним и тем же аргументом функция будет возвращать одно и то же случайное число.

Результатом приведенного ниже запроса:

```sql
SELECT RAND(2),
       RAND(2),
       RAND(3),
       RAND(3);
```

является:

```
+--------------------+--------------------+--------------------+--------------------+
| RAND(2)            | RAND(2)            | RAND(3)            | RAND(3)            |
+--------------------+--------------------+--------------------+--------------------+
| 0.6555866465490187 | 0.6555866465490187 | 0.9057697559760601 | 0.9057697559760601 |
+--------------------+--------------------+--------------------+--------------------+
```

<hr>

[Содержание](#содержание)

## Примечания 4

**Примечание 1.** Помимо функции `ROUND()`, SQL поддерживает две дополнительные функции для округления чисел: `FLOOR()` и `CEILING()`. Первая функция используется для округления числа в меньшую сторону, вторая — в большую сторону.

Результатом приведенного ниже запроса:

```sql
SELECT FLOOR(123.87),
       FLOOR(-11.22),
       CEILING(18.39),
       CEILING(-11.22);
```

является:

```
+---------------+---------------+----------------+-----------------+
| FLOOR(123.87) | FLOOR(-11.22) | CEILING(18.39) | CEILING(-11.22) |
+---------------+---------------+----------------+-----------------+
| 123           | -12           | 19             | -11             |
+---------------+---------------+----------------+-----------------+
```

**Примечание 2.** Функция `RAND()` в комбинации с операторами `ORDER BY` и `LIMIT` позволяет извлекать из таблицы определенное количество случайных записей.

Предположим, мы работаем с таблицей SQLTeam, которая имеет следующий вид:

```
+----+---------+
| id | name    |
+----+---------+
| 1  | Timur   |
| 2  | Arthur  |
| 3  | Valera  |
| 4  | Rustam  |
+----+---------+
```

При необходимости извлечь из этой таблицы, скажем, две случайные записи мы можем сначала отсортировать их с помощью функции `RAND()`, а затем ограничить полученный результат двумя записями.

Результатом приведенного ниже запроса:

```sql
SELECT *
FROM SQLTeam
ORDER BY RAND()
LIMIT 2;
```

является (может отличаться):

```
+----+---------+
| id | name    |
+----+---------+
| 1  | Timur   |
| 4  | Rustam  |
+----+---------+
```

Извлечение происходит случайным образом потому, что во время сортировки для каждой записи функция `RAND()` вызывается отдельно. Таким образом, сначала каждой записи сопоставляется определенное случайное число, а затем записи сортируются на основе этих случайных чисел.

<hr>

[Содержание](#содержание)

# 4.5 Числовые функции. Часть 2

Урок посвящен функциям, предназначенным для обработки числовых данных.

## Функции `DEGREES()` и `RADIANS()`

Функция `DEGREES()` используется для перевода значения из радиан в градусы. Она принимает в качестве аргумента значение в радианах, конвертирует его в градусы и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT DEGREES(1),
       DEGREES(3.14),
       DEGREES(6.28);
```

является:

```
+-------------------+-------------------+------------------+
| DEGREES(1)        | DEGREES(3.14)     | DEGREES(6.28)    |
+-------------------+-------------------+------------------+
| 57.29577951308232 | 179.9087476710785 | 359.817495342157 |
+-------------------+-------------------+------------------+
```

Похожим образом себя ведет функция `RADIANS()` за тем исключением, что она выполняет обратный перевод — из градусов в радианы.

Результатом приведенного ниже запроса:

```sql
SELECT RADIANS(57),
       RADIANS(180),
       RADIANS(360);
```

является:

```
+--------------------+-------------------+-------------------+
| RADIANS(57)        | RADIANS(180)      | RADIANS(360)      |
+--------------------+-------------------+-------------------+
| 0.9948376736367679 | 3.141592653589793 | 6.283185307179586 |
+--------------------+-------------------+-------------------+
```

Подробнее с радианной системой измерения можно ознакомиться по [ссылке](https://ru.wikipedia.org/wiki/Радиан).

<hr>

[Содержание](#содержание)

## Функции `PI()`, `SIN()`, `COS()` и `TAN()`

Функция `PI()` используется для получения числа пи (𝜋). Она не принимает никаких аргументов и возвращает число пи с точностью до шести знаков после запятой.

Результатом приведенного ниже запроса:

```sql
SELECT PI();
```

является:

```
+----------+
| PI()     |
+----------+
| 3.141593 |
+----------+
```

Функции `SIN()`, `COS()` и `TAN()` используются для вычисления синуса, косинуса и тангенса соответственно. Каждая функция принимает в качестве аргумента значение в радианах и возвращает соответствующую тригонометрическую величину.

Результатом приведенного ниже запроса:

```sql
SELECT SIN(PI()),
       COS(PI()),
       TAN(PI());
```

является:

```
+-----------+-----------+-----------+
| SIN(PI()) | COS(PI()) | TAN(PI()) |
+-----------+-----------+-----------+
| 0         | -1        | 0         |
+-----------+-----------+-----------+
```

<hr>

[Содержание](#содержание)

## Функции `LEAST()` и `GREATEST()`

Функция `LEAST()` используется для поиска минимального значения. Она принимает переменное количество аргументов (не меньше двух) и возвращает наименьший из них.

Результатом приведенного ниже запроса:

```sql
SELECT LEAST(2, 1, 3, 5, 4);
```

является:

```
+----------------------+
| LEAST(2, 1, 3, 5, 4) |
+----------------------+
| 1                    |
+----------------------+
```

Если поиск минимального значения происходит среди действительных (типы `FLOAT` и `DOUBLE`) и целых чисел, функция `LEAST()` сначала преобразует все числа в действительные.

Результатом приведенного ниже запроса:

```sql
SELECT LEAST(2, 1, 3.0, 5, 4);
```

является:

```
+------------------------+
| LEAST(2, 1, 3.0, 5, 4) |
+------------------------+
| 1.0                    |
+------------------------+
```

Если хотя бы один из аргументов, переданных в функцию `LEAST()`, является строкой, функция перед поиском минимального значения сначала преобразует все аргументы в строки.

Результатом приведенного ниже запроса:

```sql
SELECT LEAST(100, '11');
```

является:

```
+------------------+
| LEAST(100, '11') |
+------------------+
| 100              |
+------------------+
```

Если хотя бы один из аргументов, переданных в функцию `LEAST()`, равняется `NULL`, возвращаемым значением функции также будет `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT LEAST(2, 1, NULL, 5, 4);
```

является:

```
+-------------------------+
| LEAST(2, 1, NULL, 5, 4) |
+-------------------------+
| NULL                    |
+-------------------------+
```

Похожим образом себя ведет функция `GREATEST()` за тем исключением, что она выполняет поиск наибольшего значения, а не наименьшего.

Результатом приведенного ниже запроса:

```sql
SELECT GREATEST(2, 1, 3, 5, 4);
```

является:

```
+-------------------------+
| GREATEST(2, 1, 3, 5, 4) |
+-------------------------+
| 5                       |
+-------------------------+
```

<hr>

[Содержание](#содержание)

## Функция `CONV()`

Функция `CONV()` используется для перевода числа из одной системы счисления в другую. Она принимает три аргумента в следующем порядке:
+ `num` — число
+ `from_base` — система счисления, в которой представлено число
+ `to_base` — система счисления, в которую нужно перевести число

Функция переводит число num из системы счисления `from_base` в систему счисления `to_base` и возвращает полученный результат в виде строки.

Результатом приведенного ниже запроса:

```sql
SELECT CONV(5, 10, 2),
       CONV(101, 2, 10),
       CONV(100, 10, 16),
       CONV('F', 16, 10),
       CONV('10F', 16, 2);
```

является:

```
+----------------+------------------+-------------------+-------------------+--------------------+
| CONV(5, 10, 2) | CONV(101, 2, 10) | CONV(100, 10, 16) | CONV('F', 16, 10) | CONV('10F', 16, 2) |
+----------------+------------------+-------------------+-------------------+--------------------+
| 101            | 5                | 64                | 15                | 100001111          |
+----------------+------------------+-------------------+-------------------+--------------------+
```

<hr>

[Содержание](#содержание)

## Функция `FORMAT()`
Функция `FORMAT()` используется для округления и форматирования числа. Она принимает два аргумента в следующем порядке:
+ num — число
+ decimals — количество знаков после запятой

Функция округляет число `num` до `decimals` знаков после запятой, форматирует его путем разбиения на разряды и возвращает полученный результат в виде строки.

Результатом приведенного ниже запроса:

```sql
SELECT FORMAT(1000000.1653, 3),
       FORMAT(1000000.1653, 2),
       FORMAT(1000000.1653, 1),
       FORMAT(1000000.1653, 0);
```

является:

```
+-------------------------+-------------------------+-------------------------+-------------------------+
| FORMAT(1000000.1653, 3) | FORMAT(1000000.1653, 2) | FORMAT(1000000.1653, 1) | FORMAT(1000000.1653, 0) |
+-------------------------+-------------------------+-------------------------+-------------------------+
| 1,000,000.165           | 1,000,000.17            | 1,000,000.2             | 1,000,000               |
+-------------------------+-------------------------+-------------------------+-------------------------+
```

Обратите внимание, что функция `FORMAT()` округляет число согласно математическим правилам округления, то есть в большую по модулю сторону.

Если указанное количество знаков после запятой больше фактического количества знаков у числа, функция `FORMAT()` заполнит недостающие знаки незначащими нулями.

Результатом приведенного ниже запроса:

```sql
SELECT FORMAT(1000000.1653, 5),
       FORMAT(1000000.1653, 7);
```

является:

```
+-------------------------+-------------------------+
| FORMAT(1000000.1653, 5) | FORMAT(1000000.1653, 7) |
+-------------------------+-------------------------+
| 1,000,000.16530         | 1,000,000.1653000       |
+-------------------------+-------------------------+
```

<hr>

[Содержание](#содержание)

## Примечания 5

**Примечание 1.** В SQL реализованы практически все необходимые математические функции для работы с числовыми данными, и нами была рассмотрена большая их часть, однако не все. Так, среди пропущенных функций можно выделить функцию `COT()`, возвращающую значение котангенса, или функцию `LOG2()` с помощью которой можно получить значение двоичного логарифма. При необходимости со списком всех математических функций можно ознакомиться по [ссылке](https://docs-python.ru/packages/klient-bd-mysql/matematicheskie-funktsii-bd-mysql/).

<hr>

[Содержание](#содержание)

# 4.6 Функции даты и времени. Часть 1

Урок посвящен функциям, предназначенным для обработки даты и времени.

## Временные интервалы

В SQL для работы с датой и временем часто используются временные интервалы. Они представляют собой некоторый промежуток времени, выраженный в тех или иных единицах измерения (день, год, минута), и используются для выполнения арифметических операций с датой и временем.

Для записи временных интервалов применяется следующий синтаксис:

```sql
INTERVAL <величина интервала> <единица измерения>
```

Единица измерения во временном интервале определяется ключевым словом. Например, день — это DAY, год — это YEAR, год и месяц — это YEAR_MONTH. Формат величины интервала напрямую зависит от единицы измерения. Для одиночных единиц измерения, таких как день или год, форматом величины является целое число. 

К примеру, интервал в 1 год определяется следующим образом:

```sql
INTERVAL 1 YEAR
```

Для составных единиц измерения, таких как год и месяц, форматом величины является строка определенного вида, в которой перечислены все необходимые значения компонентов.

К примеру, интервал в 10 лет и 2 месяца определяется следующим образом:

```sql
INTERVAL '10-2' YEAR_MONTH
```

### Поддерживаемые единицы измерения

SQL поддерживает большое количество единиц измерения. Для удобства мы разбили их на две таблицы, в одной из которых представлены одиночные единицы измерения, в другой — составные.

Итак, первая таблица включает все поддерживаемые одиночные единицы измерения:


Единица измерения | Ключевое слово
-|-
микросекунда | MICROSECOND
секунда | SECOND
минута | MINUTE
час | HOUR
день | DAY
неделя | WEEK
месяц | MONTH
квартал | QUARTER
год | YEAR

Вторая таблица включает все поддерживаемые составные единицы измерения, а также формат величины для каждой из единиц:

Единица измерения | Ключевое слово | Формат величины
-|-|-
секунда и микросекунда | SECOND_MICROSECOND | секунды.микросекунды
минута, секунда и микросекунда | MINUTE_MICROSECOND | минуты:секунды.микросекунды
минута и секунда | MINUTE_SECOND | минуты:секунды
час, минута, секунда и микросекунда | HOUR_MICROSECOND | часы:минуты:секунды.микросекунды
час, минута и секунда | HOUR_SECOND | часы:минуты:секунды
час и минута | HOUR_MINUTE | часы:минуты
день, час, минута, секунда и микросекунда | DAY_MICROSECOND | дни часы:минуты:секунды.микросекунды
день, час, минута и секунда | DAY_SECOND | дни часы:минуты:секунды
день, час и минута | DAY_MINUTE | дни часы:минуты
день и час | DAY_HOUR | дни часы
год и месяц | YEAR_MONTH | годы-месяцы

### Примеры использования временных интервалов

Для большей наглядности рассмотрим несколько примеров использования временных интервалов.

**Пример 1.** Прибавим к дате 2023-01-01 интервал в 10 лет и 2 месяца.

Результатом приведенного ниже запроса:

```sql
SELECT '2023-01-01' + INTERVAL '10-2' YEAR_MONTH;
```

является:

```
+-------------------------------------------+
| '2023-01-01' + INTERVAL '10-2' YEAR_MONTH |
+-------------------------------------------+
| 2033-03-01                                |
+-------------------------------------------+
```

**Пример 2.** Вычтем из даты и времени 2023-01-01 14:00:00 интервал в 1 час и 30 минут.

Результатом приведенного ниже запроса:

```sql
SELECT '2023-01-01 14:00:00' - INTERVAL '01:30' HOUR_MINUTE;
```

является:

```
+------------------------------------------------------+
| '2023-01-01 14:00:00' - INTERVAL '01:30' HOUR_MINUTE |
+------------------------------------------------------+
| 2023-01-01 12:30:00                                  |
+------------------------------------------------------+
```

**Пример 3.** Прибавим к дате и времени 2023-01-01 14:00:00 интервал в 4 дня и 2 часа.

Результатом приведенного ниже запроса:

```sql
SELECT '2023-01-01 14:00:00' + INTERVAL '4 2' DAY_HOUR;
```

является:

```
+-------------------------------------------------+
| '2023-01-01 14:00:00' + INTERVAL '4 2' DAY_HOUR |
+-------------------------------------------------+
| 2023-01-05 16:00:00                             |
+-------------------------------------------------+
```

**Пример 4.** Вычтем из даты 2023-01-01 интервал в 1 час.

Результатом приведенного ниже запроса:

```sql
SELECT '2023-01-01' - INTERVAL 1 HOUR;
```

является:

```
+--------------------------------+
| '2023-01-01' - INTERVAL 1 HOUR |
+--------------------------------+
| 2022-12-31 23:00:00            |
+--------------------------------+
```

Обратите внимание, что из даты без времени допускается вычитать временное значение. Во время выполнения такой операции считается, что дата имеет нулевые значения по всем компонентам времени — 0 часов, 0 минут и 0 секунд. Аналогичное справедливо и при прибавлении временного значения к дате без времени.

<hr>

[Содержание](#содержание)

## Функции `NOW()`, `CURDATE()` и `CURTIME()`

Функция `NOW()` используется для получения текущей даты и времени. Она не принимает никаких аргументов и возвращает текущую дату и время в локальном часовом поясе, например, в том, который используется в операционной системе.

Результатом приведенного ниже запроса:

```sql
SELECT NOW();
```

может являться:

```
+---------------------+
| NOW()               |
+---------------------+
| 2023-06-27 10:14:48 |
+---------------------+
```

Похожим образом себя ведут функции `CURDATE()` и `CURTIME()` за тем исключением, что они возвращают текущую дату и текущее время соответственно.

Результатом приведенного ниже запроса:

```sql
SELECT CURTIME(),
       CURDATE();
```

может являться:

```
+-----------+------------+
| CURTIME() | CURDATE()  |
+-----------+------------+
| 10:23:15  | 2023-06-27 |
+-----------+------------+
```

<hr>

[Содержание](#содержание)

## Функции `UTC_TIMESTAMP()`, `UTC_DATE()` и `UTC_TIME()`

Функция `UTC_TIMESTAMP()` используется для получения текущей даты и времени. Она не принимает никаких аргументов и возвращает текущую дату и время в UTC, то есть в нулевом часовом поясе.

Результатом приведенного ниже запроса:

```sql
SELECT UTC_TIMESTAMP();
```

может являться:

```
+---------------------+
| UTC_TIMESTAMP()     |
+---------------------+
| 2023-06-28 05:44:53 |
+---------------------+
```

Похожим образом себя ведут функции `UTC_DATE()` и `UTC_TIME()` за тем исключением, что они возвращают текущую дату и текущее время соответственно.

Результатом приведенного ниже запроса:

```sql
SELECT UTC_DATE(),
       UTC_TIME();
```

может являться:

```
+------------+------------+
| UTC_DATE() | UTC_TIME() |
+------------+------------+
| 2023-10-17 | 13:57:34   |
+------------+------------+
```

Во время работы с датой и временем рекомендуется использовать именно функции `UTC_TIMESTAMP()`, `UTC_DATE()` и `UTC_TIME()`, а приведение к определенному часовому поясу при необходимости выполнять вручную.

<hr>

[Содержание](#содержание)

## Функция `MAKEDATE()`

Функция `MAKEDATE()` используется для создания даты. Она принимает два аргумента в следующем порядке:
+ `year` — год
+ `day` — номер дня в году

Функция возвращает дату, которая имеет порядковый номер `day` в году `year`.

Результатом приведенного ниже запроса:

```sql
SELECT MAKEDATE(2023, 1),
       MAKEDATE(2023, 255),
       MAKEDATE(2023, 365);
```

является:

```
+-------------------+---------------------+---------------------+
| MAKEDATE(2023, 1) | MAKEDATE(2023, 255) | MAKEDATE(2023, 365) |
+-------------------+---------------------+---------------------+
| 2023-01-01        | 2023-09-12          | 2023-12-31          |
+-------------------+---------------------+---------------------+
```

Если указанный номер дня в году больше количества дней в этом году, функция `MAKEDATE()` преобразует каждые 365-366 дней в полный год.

Результатом приведенного ниже запроса:

```sql
SELECT MAKEDATE(2023, 366),
       MAKEDATE(2023, 732);
```

является:

```
+---------------------+---------------------+
| MAKEDATE(2023, 366) | MAKEDATE(2023, 732) |
+---------------------+---------------------+
| 2024-01-01          | 2025-01-01          |
+---------------------+---------------------+
```

<hr>

[Содержание](#содержание)

## Функция `MAKETIME()`

Функция `MAKETIME()` используется для создания временного значения. Она принимает три аргумента в следующем порядке:
+ `hours` — часы
+ `minutes` — минуты
+ `seconds` — секунды

Функция возвращает временное значение, состоящее из `hours` часов, `minutes` минут и `seconds` секунд.

Результатом приведенного ниже запроса:

```sql
SELECT MAKETIME(12, 33, 1),
       MAKETIME(0, 1, 2),
       MAKETIME(21, 11, 42);
```

является:

```
+---------------------+-------------------+----------------------+
| MAKETIME(12, 33, 1) | MAKETIME(0, 1, 2) | MAKETIME(21, 11, 42) |
+---------------------+-------------------+----------------------+
| 12:33:01            | 00:01:02          | 21:11:42             |
+---------------------+-------------------+----------------------+
```

Функция `MAKETIME()` может обрабатывать значение часов больше, чем есть в сутках, но не может обрабатывать значение минут и секунд больше 59. Если количество минут или секунд больше 59, функция вернет значение `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT MAKETIME(222, 50, 11),
       MAKETIME(10, 60, 12),
       MAKETIME(5, 33, 79);
```

является:

```
+-----------------------+----------------------+---------------------+
| MAKETIME(222, 50, 11) | MAKETIME(10, 60, 12) | MAKETIME(5, 33, 79) |
+-----------------------+----------------------+---------------------+
| 222:50:11             | NULL                 | NULL                |
+-----------------------+----------------------+---------------------+
```

<hr>

[Содержание](#содержание)

## Примечания 6

**Примечание 1.** Если хотя бы один из аргументов, переданных в функции `MAKEDATE()` и `MAKETIME()`, являeтся значением `NULL`, функции вернут значение `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT MAKETIME(NULL, 1, 1),
       MAKETIME(1, NULL, 1),
       MAKETIME(1, 1, NULL),
       MAKEDATE(2023, NULL),
       MAKEDATE(NULL, 9);
```

является:

```
+----------------------+----------------------+----------------------+----------------------+-------------------+
| MAKETIME(NULL, 1, 1) | MAKETIME(1, NULL, 1) | MAKETIME(1, 1, NULL) | MAKEDATE(2023, NULL) | MAKEDATE(NULL, 9) |
+----------------------+----------------------+----------------------+----------------------+-------------------+
| NULL                 | NULL                 | NULL                 | NULL                 | NULL              |
+----------------------+----------------------+----------------------+----------------------+-------------------+
```

<hr>

[Содержание](#содержание)

## Функция `TIME_TO_SEC()` и `SEC_TO_TIME()`

Функция `TIME_TO_SEC()` используется для преобразования временного значения в секунды. Она принимает в качестве аргумента временное значение, преобразует его в количество секунд и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT TIME_TO_SEC('00:00:25'),
       TIME_TO_SEC('00:01:30'),
       TIME_TO_SEC('01:00:00');
```

является:

```
+-------------------------+-------------------------+-------------------------+
| TIME_TO_SEC('00:00:25') | TIME_TO_SEC('00:01:30') | TIME_TO_SEC('01:00:00') |
+-------------------------+-------------------------+-------------------------+
| 25                      | 90                      | 3600                    |
+-------------------------+-------------------------+-------------------------+
```

Похожим образом себя ведет функция `SEC_TO_TIME()` за тем исключением, что она выполняет обратное преобразование — количество секунд во временное значение.

Результатом приведенного ниже запроса:

```sql
SELECT SEC_TO_TIME(25),
       SEC_TO_TIME(90),
       SEC_TO_TIME(3600);
```

является:

```
+-----------------+-----------------+-------------------+
| SEC_TO_TIME(25) | SEC_TO_TIME(90) | SEC_TO_TIME(3600) |
+-----------------+-----------------+-------------------+
| 00:00:25        | 00:01:30        | 01:00:00          |
+-----------------+-----------------+-------------------+
```

<hr>

[Содержание](#содержание)

## Функции `TO_DAYS()` и `TO_SECONDS()`

Функция `TO_DAYS()` используется для преобразования даты в количество дней. Она принимает в качестве аргумента дату, преобразует ее в количество дней и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT TO_DAYS('2023-04-01'),
       TO_DAYS('0001-01-01'),
       TO_DAYS('0000-01-01');
```

является:

```
+-----------------------+-----------------------+-----------------------+
| TO_DAYS('2023-04-01') | TO_DAYS('0001-01-01') | TO_DAYS('0000-01-01') |
+-----------------------+-----------------------+-----------------------+
| 738976                | 366                   | 1                     |
+-----------------------+-----------------------+-----------------------+
```

Обратите внимание, что отсчет количества дней начинается с нулевого года.

Похожим образом себя ведет функция `TO_SECONDS()`, за тем исключением, что она преобразует дату в количество секунд, а не дней.

Результатом приведенного ниже запроса:

```sql
SELECT TO_SECONDS('2023-04-01'),
       TO_SECONDS('0001-01-01'),
       TO_SECONDS('0000-01-01');
```

является:

```
+--------------------------+--------------------------+--------------------------+
| TO_SECONDS('2023-04-01') | TO_SECONDS('0001-01-01') | TO_SECONDS('0000-01-01') |
+--------------------------+--------------------------+--------------------------+
| 63847526400              | 31622400                 | 86400                    |
+--------------------------+--------------------------+--------------------------+
```

<hr>

[Содержание](#содержание)

## Функция `LAST_DAY()`

Функция `LAST_DAY()` используется для замены дня на последний день месяца. Она принимает в качестве аргумента дату, заменяет в ней день на последний день месяца этой даты и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT LAST_DAY('2023-02-14'),
       LAST_DAY('2023-03-14'),
       LAST_DAY('2023-04-14');
```

является:

```
+------------------------+------------------------+------------------------+
| LAST_DAY('2023-02-14') | LAST_DAY('2023-03-14') | LAST_DAY('2023-04-14') |
+------------------------+------------------------+------------------------+
| 2023-02-28             | 2023-03-31             | 2023-04-30             |
+------------------------+------------------------+------------------------+
```

## Примечания 6.2

**Примечание 1.** Функции `TIME_TO_SEC()`, `SEC_TO_TIME()`, `TO_DAYS()`, `TO_SECONDS()` и `LAST_DAY()` при вызове с аргументом `NULL` возвращают значение `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT TIME_TO_SEC(NULL),
       SEC_TO_TIME(NULL),
       TO_DAYS(NULL),
       TO_SECONDS(NULL),
       LAST_DAY(NULL);
```

является:

```
+-------------------+-------------------+---------------+------------------+----------------+
| TIME_TO_SEC(NULL) | SEC_TO_TIME(NULL) | TO_DAYS(NULL) | TO_SECONDS(NULL) | LAST_DAY(NULL) |
+-------------------+-------------------+---------------+------------------+----------------+
| NULL              | NULL              | NULL          | NULL             | NULL           |
+-------------------+-------------------+---------------+------------------+----------------+
```

<hr>

[Содержание](#содержание)

# 4.7 Функции даты и времени. Часть 2

Урок посвящен функциям, предназначенным для обработки даты и времени.

## Функции `DATE()` и `TIME()`

Функция `DATE()` используется для получения даты из даты и времени. Она принимает в качестве аргумента дату и время, извлекает из него дату и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT DATE('2023-10-20 12:30:00'),
       DATE('2023-12-31 10:00:20');
```

является:

```
+-----------------------------+-----------------------------+
| DATE('2023-10-20 12:30:00') | DATE('2023-12-31 10:00:20') |
+-----------------------------+-----------------------------+
| 2023-10-20                  | 2023-12-31                  |
+-----------------------------+-----------------------------+
```

Если аргументом функции `DATE()` является дата без времени, функция вернет ее в исходном виде.

Результатом приведенного ниже запроса:

```sql
SELECT DATE('2023-10-20');
```

является:

```
+--------------------+
| DATE('2023-10-20') |
+--------------------+
| 2023-10-20         |
+--------------------+
```

Похожим образом себя ведет функция `TIME()` за тем исключением, что она извлекает временное значение, а не дату.

Результатом приведенного ниже запроса:

```sql
SELECT TIME('2023-10-20 12:30:00'),
       TIME('2023-12-31 10:00:20'),
       TIME('12:30:00');
```

является:

```
+-----------------------------+-----------------------------+------------------+
| TIME('2023-10-20 12:30:00') | TIME('2023-12-31 10:00:20') | TIME('12:30:00') |
+-----------------------------+-----------------------------+------------------+
| 12:30:00                    | 10:00:20                    | 12:30:00         |
+-----------------------------+-----------------------------+------------------+
```

<hr>

[Содержание](#содержание)

## Функции `HOUR()`, `MINUTE()`, `SECOND()` и `MICROSECOND()`

Функция `HOUR()` используется для определения количества часов во времени. Она принимает в качестве аргумента временное значение, извлекает из него часы и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT HOUR('12:30:10'),
       HOUR('18:20:00');
```

является:

```
+------------------+------------------+
| HOUR('12:30:10') | HOUR('18:20:00') |
+------------------+------------------+
| 12               | 18               |
+------------------+------------------+
```

Похожим образом себя ведут функции `MINUTE()`, `SECOND()` и `MICROSECOND()` за тем исключением, что они извлекают минуты, секунды и микросекунды соответственно.

Результатом приведенного ниже запроса:

```sql
SELECT MINUTE('12:30:10.1415'),
       SECOND('12:30:10.1415'),
       MICROSECOND('12:30:10.1415');
```

является:

```
+-------------------------+-------------------------+------------------------------+
| MINUTE('12:30:10.1415') | SECOND('12:30:10.1415') | MICROSECOND('12:30:10.1415') |
+-------------------------+-------------------------+------------------------------+
| 30                      | 10                      | 141500                       |
+-------------------------+-------------------------+------------------------------+
```

<hr>

[Содержание](#содержание)

## Функции `YEAR()`, `MONTH()` и `DAY()`

Функция `YEAR()` используется для извлечения значения года из даты. Она принимает в качестве аргумента дату, извлекает из нее год и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT YEAR('2023-10-20'),
       YEAR('2027-12-31');
```

является:

```
+--------------------+--------------------+
| YEAR('2023-10-20') | YEAR('2027-12-31') |
+--------------------+--------------------+
| 2023               | 2027               |
+--------------------+--------------------+
```

Похожим образом себя ведут функции `MONTH()` и `DAY()` за тем исключением, что они извлекают месяц и день соответственно.

Результатом приведенного ниже запроса:

```sql
SELECT MONTH('2023-10-20'),
       DAY('2023-10-20');
```

является:

```
+---------------------+-------------------+
| MONTH('2023-10-20') | DAY('2023-10-20') |
+---------------------+-------------------+
| 10                  | 20                |
+---------------------+-------------------+
```

<hr>

[Содержание](#содержание)

## Функция `DAYOFYEAR()`

Функция `DAYOFYEAR()` используется для вычисления номера дня в году (от 1 до 366) на основе даты. Она принимает в качестве аргумента дату, определяет, какой по счету день в году соответствует переданной дате, и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT DAYOFYEAR('2023-01-01'),
       DAYOFYEAR('2023-02-01'),
       DAYOFYEAR('2023-12-31');
```

является:

```
+-------------------------+-------------------------+-------------------------+
| DAYOFYEAR('2023-01-01') | DAYOFYEAR('2023-02-01') | DAYOFYEAR('2023-12-31') |
+-------------------------+-------------------------+-------------------------+
| 1                       | 32                      | 365                     |
+-------------------------+-------------------------+-------------------------+
```

<hr>

[Содержание](#содержание)

## Функция `WEEK()`
Функция `WEEK()` используется для вычисления номера недели в году на основе даты. Она принимает в качестве аргумента дату, определяет, какая по счету неделя в году соответствует переданной дате, и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT WEEK('2023-01-01'),
       WEEK('2023-01-08'),
       WEEK('2023-12-31');
```

является:

```
+--------------------+--------------------+--------------------+
| WEEK('2023-01-01') | WEEK('2023-01-08') | WEEK('2023-12-31') |
+--------------------+--------------------+--------------------+
| 1                  | 2                  | 53                 |
+--------------------+--------------------+--------------------+
```

Функция `WEEK()` имеет несколько режимов работы, например, она может считать неделю от понедельника или воскресенья. Подробнее с возможностями данной функции можно ознакомиться по [ссылке](https://docs-python.ru/packages/klient-bd-mysql/funktsii-bd-mysql-raboty-datoi-vremenem/#WEEK).

<hr>

[Содержание](#содержание)

## Функция `WEEKDAY()`

Функция `WEEKDAY()` используется для вычисления номера дня недели (от 0 до 6) на основе даты. Она принимает в качестве аргумента дату, определяет день недели, который соответствует переданной дате, и возвращает его номер.

Результатом приведенного ниже запроса:

```sql
SELECT WEEKDAY('2023-10-16'),      -- понедельник
       WEEKDAY('2023-10-17'),      -- вторник
       WEEKDAY('2023-10-18'),      -- среда
       WEEKDAY('2023-10-23');      -- понедельник
```

является:

```
+-----------------------+-----------------------+-----------------------+-----------------------+
| WEEKDAY('2023-10-16') | WEEKDAY('2023-10-17') | WEEKDAY('2023-10-18') | WEEKDAY('2023-10-23') |
+-----------------------+-----------------------+-----------------------+-----------------------+
| 0                     | 1                     | 2                     | 0                     |
+-----------------------+-----------------------+-----------------------+-----------------------+
```

<hr>

[Содержание](#содержание)

## Функция `QUARTER()`

Функция `QUARTER()` используется для вычисления номера квартала (от 1 до 4) на основе даты. Она принимает в качестве аргумента дату, определяет квартал, в котором находится переданная дата, и возвращает его номер.

Результатом приведенного ниже запроса:

```sql
SELECT QUARTER('2023-01-01'),      -- январь
       QUARTER('2023-04-01'),      -- апрель
       QUARTER('2023-07-01'),      -- июль
       QUARTER('2023-10-01');      -- октябрь
```

является:

```
+-----------------------+-----------------------+-----------------------+-----------------------+
| QUARTER('2023-01-01') | QUARTER('2023-04-01') | QUARTER('2023-07-01') | QUARTER('2023-10-01') |
+-----------------------+-----------------------+-----------------------+-----------------------+
| 1                     | 2                     | 3                     | 4                     |
+-----------------------+-----------------------+-----------------------+-----------------------+
```

Квартал — четвертая часть года. 1 квартал включает январь, февраль, март, 2 — апрель, май, июнь, 3 — июль, август, сентябрь, 4 — октябрь, ноябрь, декабрь.

<hr>

[Содержание](#содержание)

## Функция `DAYNAME()`
Функция `DAYNAME()` используется для вычисления названия дня недели на основе даты. Она принимает в качестве аргумента дату, определяет день недели, который соответствует переданной дате, и возвращает его полное название.

Результатом приведенного ниже запроса:

```sql
SELECT DAYNAME('2023-10-16'),      -- понедельник
       DAYNAME('2023-10-17'),      -- вторник
       DAYNAME('2023-10-18');      -- среда
```

является:

```
+-----------------------+-----------------------+-----------------------+
| DAYNAME('2023-10-16') | DAYNAME('2023-10-17') | DAYNAME('2023-10-18') |
+-----------------------+-----------------------+-----------------------+
| Monday                | Tuesday               | Wednesday             |
+-----------------------+-----------------------+-----------------------+
```

<hr>

[Содержание](#содержание)

## Функция `MONTHNAME()`

Функция `MONTHNAME()` используется для определения названия месяца на основе даты. Она принимает в качестве аргумента дату и возвращает полное название ее месяца.

Результатом приведенного ниже запроса:

```sql
SELECT MONTHNAME('2023-01-01'),    -- январь
       MONTHNAME('2023-04-01'),    -- апрель
       MONTHNAME('2023-07-01');    -- июль
```

является:

```
+-------------------------+-------------------------+-------------------------+
| MONTHNAME('2023-01-01') | MONTHNAME('2023-04-01') | MONTHNAME('2023-07-01') |
+-------------------------+-------------------------+-------------------------+
| January                 | April                   | July                    |
+-------------------------+-------------------------+-------------------------+
```

<hr>

[Содержание](#содержание)

## Примечания 7

**Примечание 1.** Функции, предназначенные в большей степени для работы только с датой или только с временем, могут использоваться для работы с датой и временем.

Результатом приведенного ниже запроса:

```sql
SELECT HOUR('2023-10-20 12:30:00'),
       YEAR('2023-10-20 12:30:00'),
       DAYNAME('2023-10-20 12:30:00');
```

является:

```
+-----------------------------+-----------------------------+--------------------------------+
| HOUR('2023-10-20 12:30:00') | YEAR('2023-10-20 12:30:00') | DAYNAME('2023-10-20 12:30:00') |
+-----------------------------+-----------------------------+--------------------------------+
| 12                          | 2023                        | Friday                         |
+-----------------------------+-----------------------------+--------------------------------+
```

**Примечание 2.** В MySQL временные значения ограничены диапазоном [-838:59:59; 838:59:59].

Результатом приведенного ниже запроса:

```sql
SELECT TIME('400:00:00'),
       TIME('900:00:00'),
       TIME('-400:00:00'),
       TIME('-900:00:00');
```

является:

```
+-------------------+-------------------+--------------------+--------------------+
| TIME('400:00:00') | TIME('900:00:00') | TIME('-400:00:00') | TIME('-900:00:00') |
+-------------------+-------------------+--------------------+--------------------+
| 400:00:00         | 838:59:59         | -400:00:00         | -838:59:59         |
+-------------------+-------------------+--------------------+--------------------+
```

С причинами использования именно такого диапазона можно ознакомиться по [ссылке](https://habr.com/ru/companies/flant/articles/526712/).

**Примечание 3.** В MySQL имеется специальная переменная `lc_time_names`, которая управляет локализацией. Она определяет, как будут отображаться названия дней недели и месяцев при использовании таких функций, как `DAYNAME()` и `MONTHNAME()`.

Переменная `lc_time_names` может принимать различные значения в зависимости от того, какая локализация необходима: например, `'ru_RU'` — русская, `'en_US'` — английская. Изменение ее значения выполняется с помощью следующей конструкции:

```sql
SET lc_time_names = <языковая локаль>;
```

Результатом приведенного ниже запроса:

```sql
SET lc_time_names = 'ru_RU';

SELECT DAYNAME('2023-10-20'),
       MONTHNAME('2023-10-20');
```

в Windows 11 является:

```
+-----------------------+-------------------------+
| DAYNAME('2023-10-20') | MONTHNAME('2023-10-20') |
+-----------------------+-------------------------+
| Пятница               | Октября                 |
+-----------------------+-------------------------+
```

С полным списком поддерживаемых языковых локалей можно ознакомиться по [ссылке](https://dev.mysql.com/doc/refman/8.0/en/locale-support.html).

**Примечание 4.** Если любой из функций, которые были рассмотрены в этом уроке, вместо даты, времени или даты и времени передать значение `NULL`, функции также вернут значение `NULL`.

<hr>

[Содержание](#содержание)

# 4.8 Функции даты и времени. Часть 3

Урок посвящен функциям, предназначенным для обработки даты и времени.

## Функции `ADDDATE()` и `SUBDATE()`

Функция `ADDDATE()` используется для прибавления временного интервала к дате и времени. Она принимает два аргумента в следующем порядке:
+ `datetime` — дата и время
+ `interval` — временной интервал

Функция прибавляет временной интервал `interval` к дате и времени `datetime` и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT ADDDATE('2023-10-20 07:30:00', INTERVAL 4 DAY),
       ADDDATE('2023-10-20 07:30:00', INTERVAL 4 HOUR);
```

является:

```
+------------------------------------------------+-------------------------------------------------+
| ADDDATE('2023-10-20 07:30:00', INTERVAL 4 DAY) | ADDDATE('2023-10-20 07:30:00', INTERVAL 4 HOUR) |
+------------------------------------------------+-------------------------------------------------+
| 2023-10-24 07:30:00                            | 2023-10-20 11:30:00                             |
+------------------------------------------------+-------------------------------------------------+
```

Похожим образом себя ведет функция `SUBDATE()` за тем исключением, что она вычитает временной интервал из даты и времени, а не прибавляет.

Результатом приведенного ниже запроса:

```sql
SELECT SUBDATE('2023-10-20 07:30:00', INTERVAL 4 DAY),
       SUBDATE('2023-10-20 07:30:00', INTERVAL 4 HOUR);
```

является:

```
+------------------------------------------------+-------------------------------------------------+
| SUBDATE('2023-10-20 07:30:00', INTERVAL 4 DAY) | SUBDATE('2023-10-20 07:30:00', INTERVAL 4 HOUR) |
+------------------------------------------------+-------------------------------------------------+
| 2023-10-16 07:30:00                            | 2023-10-20 03:30:00                             |
+------------------------------------------------+-------------------------------------------------+
```

Функции `ADDDATE()` и `SUBDATE()` в качестве первого аргумента могут принимать не только дату и время, но и просто дату.

Результатом приведенного ниже запроса:

```sql
SELECT ADDDATE('2023-10-20', INTERVAL 4 DAY),
       SUBDATE('2023-10-20', INTERVAL 24 HOUR);
```

является:

```
+---------------------------------------+-----------------------------------------+
| ADDDATE('2023-10-20', INTERVAL 4 DAY) | SUBDATE('2023-10-20', INTERVAL 24 HOUR) |
+---------------------------------------+-----------------------------------------+
| 2023-10-24                            | 2023-10-19 00:00:00                     |
+---------------------------------------+-----------------------------------------+
```

<hr>

[Содержание](#содержание)

## Функции `ADDTIME()` и `SUBTIME()`

Функция `ADDTIME()` используется для прибавления временного значения к дате и времени. Она принимает два аргумента в следующем порядке:
+ `datetime` — дата и время
+ `time` — временное значение

Функция прибавляет временное значение `time` к дате и времени `datetime` и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT ADDTIME('2023-10-20 21:00:00', '02:00:00'),
       ADDTIME('2023-10-20 21:00:00', '06:00:00');
```

является:

```
+--------------------------------------------+--------------------------------------------+
| ADDTIME('2023-10-20 21:00:00', '02:00:00') | ADDTIME('2023-10-20 21:00:00', '06:00:00') |
+--------------------------------------------+--------------------------------------------+
| 2023-10-20 23:00:00                        | 2023-10-21 03:00:00                        |
+--------------------------------------------+--------------------------------------------+
```

Похожим образом себя ведет функция `SUBTIME()` за тем исключением, что она вычитает временное значение из даты и времени, а не прибавляет.

Результатом приведенного ниже запроса:

```sql
SELECT SUBTIME('2023-10-20 21:00:00', '02:00:00'),
       SUBTIME('2023-10-20 21:00:00', '06:00:00');
```

является:

```
+--------------------------------------------+--------------------------------------------+
| SUBTIME('2023-10-20 21:00:00', '02:00:00') | SUBTIME('2023-10-20 21:00:00', '06:00:00') |
+--------------------------------------------+--------------------------------------------+
| 2023-10-20 19:00:00                        | 2023-10-20 15:00:00                        |
+--------------------------------------------+--------------------------------------------+
```

Функции `ADDTIME()` и `SUBTIME()` в качестве первого аргумента могут принимать не только дату и время, но и просто время, поэтому они могут использоваться для выполнения арифметических операций с временными значениями.

Результатом приведенного ниже запроса:

```sql
SELECT ADDTIME('21:30:00', '08:30:00'),
       SUBTIME('20:40:00', '10:00:00');
```

является:

```
+---------------------------------+---------------------------------+
| ADDTIME('21:30:00', '08:30:00') | SUBTIME('20:40:00', '10:00:00') |
+---------------------------------+---------------------------------+
| 30:00:00                        | 10:40:00                        |
+---------------------------------+---------------------------------+
```

Если первое временное значение, переданное в функцию `SUBTIME()`, меньше второго, функция вернет отрицательный результат.

Результатом приведенного ниже запроса:

```sql
SELECT SUBTIME('20:00:00', '30:00:00');
```

является:

```
+---------------------------------+
| SUBTIME('20:00:00', '30:00:00') |
+---------------------------------+
| -10:00:00                       |
+---------------------------------+
```

<hr>

[Содержание](#содержание)

## Функция `DATEDIFF()`

Функция `DATEDIFF()` используется для вычисления разницы в днях между двумя значениями даты и времени. Она принимает два аргумента в следующем порядке:
+ `datetime1` — первая дата и время
+ `datetime2` — вторая дата и время

Функция возвращает количество дней между значениями даты и времени `datetime1` и `datetime2`.

Результатом приведенного ниже запроса:

```sql
SELECT DATEDIFF('2023-10-20 7:30:00', '2023-10-20 8:00:00'),
       DATEDIFF('2023-10-26 7:30:00', '2023-10-20 8:00:00');
```

является:

```
+------------------------------------------------------+------------------------------------------------------+
| DATEDIFF('2023-10-20 7:30:00', '2023-10-20 8:00:00') | DATEDIFF('2023-10-26 7:30:00', '2023-10-20 8:00:00') |
+------------------------------------------------------+------------------------------------------------------+
| 0                                                    | 6                                                    |
+------------------------------------------------------+------------------------------------------------------+
```

Если первая дата и время, переданная в функцию `DATEDIFF()`, меньше второй, функция вернет отрицательный результат.

Результатом приведенного ниже запроса:

```sql
SELECT DATEDIFF('2023-10-20 07:30:00', '2023-10-26 08:00:00');
```

является:

```
+--------------------------------------------------------+
| DATEDIFF('2023-10-20 07:30:00', '2023-10-26 08:00:00') |
+--------------------------------------------------------+
| -6                                                     |
+--------------------------------------------------------+
```

При вычислении разницы функция `DATEDIFF()` использует только дату, время не используется, поэтому каждый из аргументов, передаваемых в функцию, может быть как датой и временем, так и просто датой.

<hr>

[Содержание](#содержание)

## Функция `TIMEDIFF()`

Функция `TIMEDIFF()` используется для вычисления разницы во времени между двумя значениями даты и времени. Она принимает два аргумента в следующем порядке:
+ `datetime1` — первая дата и время
+ `datetime2` — вторая дата и время

Функция возвращает разницу во времени между значениями даты и времени `datetime1` и `datetime2`.

Результатом приведенного ниже запроса:

```sql
SELECT TIMEDIFF('2023-10-20 9:00:00', '2023-10-20 07:00:00'),
       TIMEDIFF('2023-10-25 9:00:00', '2023-10-20 07:00:00');
```

является:

```
+-------------------------------------------------------+-------------------------------------------------------+
| TIMEDIFF('2023-10-20 9:00:00', '2023-10-20 07:00:00') | TIMEDIFF('2023-10-25 9:00:00', '2023-10-20 07:00:00') |
+-------------------------------------------------------+-------------------------------------------------------+
| 02:00:00                                              | 122:00:00                                             |
+-------------------------------------------------------+-------------------------------------------------------+
```

Если первая дата и время, переданная в функцию `TIMEDIFF()`, меньше второй, функция вернет результат в виде отрицательного временного значения.

Результатом приведенного ниже запроса:

```sql
SELECT TIMEDIFF('2023-10-20 7:00:00', '2023-10-20 9:00:00');
```

является:

```
+------------------------------------------------------+
| TIMEDIFF('2023-10-20 7:00:00', '2023-10-20 9:00:00') |
+------------------------------------------------------+
| -02:00:00                                            |
+------------------------------------------------------+
```

Функция `TIMEDIFF()` может использоваться не только для вычисления разницы во времени между двумя значениями даты и времени, но и просто между двумя временными значениями.

Результатом приведенного ниже запроса:

```sql
SELECT TIMEDIFF('7:00:00', '15:00:00'),
       TIMEDIFF('16:00:00', '11:00:00');
```

является:

```
+---------------------------------+----------------------------------+
| TIMEDIFF('7:00:00', '15:00:00') | TIMEDIFF('16:00:00', '11:00:00') |
+---------------------------------+----------------------------------+
| -08:00:00                       | 05:00:00                         |
+---------------------------------+----------------------------------+
```

<hr>

[Содержание](#содержание)

## Функция `TIMESTAMPDIFF()`

Функция `TIMESTAMPDIFF()` используется для вычисления разницы между двумя значениями даты и времени в определенных единицах измерения. Она принимает три аргумента в следующем порядке:
+ `unit` — единица измерения, в которой требуется получить разницу
+ `datetime1` — первая дата и время
+ `datetime2` — вторая дата и время

Функция возвращает разницу между значениями даты и времени `datetime1` и `datetime2` в единицах измерения `unit`.

Результатом приведенного ниже запроса:

```sql
SELECT TIMESTAMPDIFF(HOUR, '2023-10-20 07:00:00', '2023-10-20 12:00:00') AS hours,
       TIMESTAMPDIFF(MONTH, '2023-10-20 07:00:00', '2023-12-31 12:00:00') AS months;
```

является:

```
+-------+--------+
| hours | months |
+-------+--------+
| 5     | 2      |
+-------+--------+
```

Если первое дата и время, переданное в функцию `TIMESTAMPDIFF()`, больше второго, функция вернет отрицательный результат.

Результатом приведенного ниже запроса:

```sql
SELECT TIMESTAMPDIFF(HOUR, '2023-10-20 12:00:00', '2023-10-20 07:00:00');
```

является:

```
+-------------------------------------------------------------------+
| TIMESTAMPDIFF(HOUR, '2023-10-20 12:00:00', '2023-10-20 07:00:00') |
+-------------------------------------------------------------------+
| -5                                                                |
+-------------------------------------------------------------------+
```

Следует заметить, что единица измерения, передаваемая в функцию `TIMESTAMPDIFF()` в качестве первого аргумента, должна быть одиночной, в противном случае произойдет ошибка.

Результатом приведенного ниже запроса:

```sql
SELECT TIMESTAMPDIFF(DAY_HOUR, '2023-10-20 07:00:00', '2023-10-25 12:00:00');
```

является ошибка:

```
ERROR 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'DAY_HOUR, '2023-10-20 07:00:00', '2023-10-25 12:00:00' at line 1
```

Каждый из аргументов, передаваемых в функцию `TIMESTAMPDIFF()`, может быть как датой и временем, так и просто датой, при этом дата имеет нулевые значения по всем компонентам времени.

<hr>

[Содержание](#содержание)

## Функция `TIMESTAMP()`

Функция `TIMESTAMP()` используется для объединения даты и временного значения. Она принимает два аргумента в следующем порядке:
+ `date` — дата
+ `time` — временное значение

Функция объединяет дату `date` и время `time` и возвращает полученный результат в виде единого объекта.

Результатом приведенного ниже запроса:

```sql
SELECT TIMESTAMP('2023-10-20', '08:00'),
       TIMESTAMP('2023-10-20', '28:00');
```

является:

```
+----------------------------------+----------------------------------+
| TIMESTAMP('2023-10-20', '08:00') | TIMESTAMP('2023-10-20', '28:00') |
+----------------------------------+----------------------------------+
| 2023-10-20 08:00:00              | 2023-10-21 04:00:00              |
+----------------------------------+----------------------------------+
```

Обратите внимание, что функция `TIMESTAMP()` автоматически конвертирует каждые 24 часа в 1 день.

Временное значение может не указываться, в таком случае оно будет принято равным 00:00:00.

Результатом приведенного ниже запроса:

```sql
SELECT TIMESTAMP('2023-10-20');
```

является:

```
+-------------------------+
| TIMESTAMP('2023-10-20') |
+-------------------------+
| 2023-10-20 00:00:00     |
+-------------------------+
```

<hr>

[Содержание](#содержание)

## Примечания 8

**Примечание 1.** Если любой из функций, которые были рассмотрены в этом уроке, вместо даты, времени или даты и времени передать значение `NULL`, функции также вернут значение `NULL`.

<hr>

[Содержание](#содержание)

# 4.9 Функции даты и времени. Часть 4

Урок посвящен функциям, предназначенным для обработки даты и времени.

## Форматирование

По умолчанию вывод даты и времени осуществляется в ISO-формате. Например, дата в таком формате записывается в виде `2023-10-25` (год, месяц, день). Однако для конечного пользователя такой формат может быть не всегда удобен. Российские пользователи, к примеру, привыкли видеть дату в виде `25.10.2023` (день, месяц, год), что заметно отличается от даты в формате ISO.

SQL позволяет определить любой необходимый формат отображения даты и времени c помощью строк формата. Например, дата `2023-10-25` при форматировании в соответствии со строкой формата `%d.%m.%Y` будет иметь вид `25.10.2023`. Значения `%d`, `%m` и `%Y` в строке формата называются спецификаторами формата. Каждый из них представляет собой символ, предваренный знаком процента (`%`), который обозначает какую-либо компоненту даты и времени. Например, `%d` обозначает день месяца, а `%m` и `%Y` — номер месяца и год соответственно.

В таблице ниже представлены основные спецификаторы формата:

Спецификатор | Описание
-|-
`%M` | Полное название месяца (January..December)
`%b` | Сокращенное название месяца (Jan..Dec)
`%W` | Полное название дня недели (Sunday..Saturday)
`%a` | Сокращенное название дня недели (Sun..Sat)
`%Y` | Год (0000..9999)
`%m` | Номер месяца (00..12)
`%d` | День месяца (00..31)
`%w` | Номер дня недели (0..6)
`%H` | Часы (00..23)
`%i` | Минуты (00..59)
`%S` | Секунды (00..59)
`%f` | Микросекунды (000000..999999)
`%T` | Время в формате HH:MM:SS

Следует уточнить, что таблица выше включает лишь отобранные нами наиболее полезные спецификаторы формата, однако на самом деле их гораздо больше. С полным списком спецификаторов формата можно ознакомиться по [ссылке](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_date-format).

<hr>

[Содержание](#содержание)

## Функция `DATE_FORMAT()`

Функция `DATE_FORMAT()` используется для форматирования даты и времени. Она принимает два аргумента в следующем порядке:
+ `datetime` — дата и время
+ `format` — строка формата

Функция преобразует дату и время `datetime` в строку в соответствии с форматом `format` и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT DATE_FORMAT('2023-10-20 07:30:00', '%H:%i, %d.%m.%Y');
```

является:

```
+-------------------------------------------------------+
| DATE_FORMAT('2023-10-20 07:30:00', '%H:%i, %d.%m.%Y') |
+-------------------------------------------------------+
| 07:30, 20.10.2023                                     |
+-------------------------------------------------------+
```

Функция `DATE_FORMAT()` в качестве первого аргумента может принимать не только дату и время, но и просто дату. Во втором случае считается, что дата имеет нулевые значения по всем компонентам времени.

Результатом приведенного ниже запроса:

```sql
SELECT DATE_FORMAT('2023-10-20', '%d.%m.%Y'),
       DATE_FORMAT('2023-10-20', '%H:%i, %d.%m.%Y');
```

является:

```
+---------------------------------------+----------------------------------------------+
| DATE_FORMAT('2023-10-20', '%d.%m.%Y') | DATE_FORMAT('2023-10-20', '%H:%i, %d.%m.%Y') |
+---------------------------------------+----------------------------------------------+
| 20.10.2023                            | 00:00, 20.10.2023                            |
+---------------------------------------+----------------------------------------------+
```

<hr>

[Содержание](#содержание)

## Функция `TIME_FORMAT()`

Функция `TIME_FORMAT()` используется для форматирования времени. Она принимает два аргумента в следующем порядке:
+ `time` — временное значение
+ `format` — строка формата

Функция преобразует временное значение `time` в строку в соответствии с форматом `format` и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT TIME_FORMAT('12:30:00', '%H::%i::%s'),
       TIME_FORMAT('12:30:00', 'Time: %H:%i');
```

является:

```
+---------------------------------------+----------------------------------------+
| TIME_FORMAT('12:30:00', '%H::%i::%s') | TIME_FORMAT('12:30:00', 'Time: %H:%i') |
+---------------------------------------+----------------------------------------+
| 12::30::00                            | Time: 12:30                            |
+---------------------------------------+----------------------------------------+
```

<hr>

[Содержание](#содержание)

## Функция `STR_TO_DATE()`

Функция `STR_TO_DATE()` используется для выполнения операции, обратной форматированию. Она принимает два аргумента в следующем порядке:
+ `string` — строка с компонентами даты и времени
+ `format` — строка формата

Функция извлекает из строки `string` компоненты даты и времени в соответствии с форматом `format` и возвращает дату и время на основе извлеченных компонентов.

Результатом приведенного ниже запроса:

```sql
SELECT STR_TO_DATE('07:30, 20.10.2023', '%H:%i, %d.%m.%Y');
```

является:

```
+-----------------------------------------------------+
| STR_TO_DATE('07:30, 20.10.2023', '%H:%i, %d.%m.%Y') |
+-----------------------------------------------------+
| 2023-10-20 07:30:00                                 |
+-----------------------------------------------------+
```

Если в строке с компонентами представлены только компоненты даты, функция `STR_TO_DATE()` вернет дату без времени, если только компоненты времени — время без даты.

Результатом приведенного ниже запроса:

```sql
SELECT STR_TO_DATE('20.10.2023', '%d.%m.%Y'),
       STR_TO_DATE('Time: 07:30', 'Time: %H:%i');
```

является:

```
+---------------------------------------+-------------------------------------------+
| STR_TO_DATE('20.10.2023', '%d.%m.%Y') | STR_TO_DATE('Time: 07:30', 'Time: %H:%i') |
+---------------------------------------+-------------------------------------------+
| 2023-10-20                            | 07:30:00                                  |
+---------------------------------------+-------------------------------------------+
```

При этом для создания даты или даты и времени должны быть определены все компоненты даты (год, месяц, число), и если хотя бы один компонент пропущен, функция вернет значение `NULL`. В случае с временным значением достаточно одного любого компонента, остальные по умолчанию примут значение 0.

Результатом приведенного ниже запроса:

```sql
SELECT STR_TO_DATE('20.10', '%d.%m'),
       STR_TO_DATE('Time: 07', 'Time: %H');
```

является:

```
+-------------------------------+-------------------------------------+
| STR_TO_DATE('20.10', '%d.%m') | STR_TO_DATE('Time: 07', 'Time: %H') |
+-------------------------------+-------------------------------------+
| NULL                          | 7:00:00                             |
+-------------------------------+-------------------------------------+
```

Во время использования функции `STR_TO_DATE()` необходимо следить за тем, чтобы строка с компонентами даты и времени полностью соответствовала строке формата, в противном случае функция вернет значение `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT STR_TO_DATE('20.10.2023', '%d-%m-%Y'),
       STR_TO_DATE('Time: 07:30', '%H:%i');
```

является:

```
+---------------------------------------+-------------------------------------+
| STR_TO_DATE('20.10.2023', '%d-%m-%Y') | STR_TO_DATE('Time: 07:30', '%H:%i') |
+---------------------------------------+-------------------------------------+
| NULL                                  | NULL                                |
+---------------------------------------+-------------------------------------+
```

<hr>

[Содержание](#содержание)

## Функция `GET_FORMAT()`

Функция `GET_FORMAT()` используется для получения определенной строки формата для даты, времени или даты и времени. Она принимает два аргумента в следующем порядке:
+ `type` — тип объекта, для которого требуется строка формата (`DATE`, `TIME` или `DATETIME`)
+ `format` — непосредственно формат (`USA`, `JIS`, `ISO` или `EUR`)

Функция возвращает строку формата `format` для объекта типа `type`.

Результатом приведенного ниже запроса:

```sql
SELECT GET_FORMAT(DATE, 'EUR'),
       GET_FORMAT(TIME, 'EUR'),
       GET_FORMAT(DATETIME, 'EUR');
```

является:

```
+-------------------------+-------------------------+-----------------------------+
| GET_FORMAT(DATE, 'EUR') | GET_FORMAT(TIME, 'EUR') | GET_FORMAT(DATETIME, 'EUR') |
+-------------------------+-------------------------+-----------------------------+
| %d.%m.%Y                | %H.%i.%s                | %Y-%m-%d %H.%i.%s           |
+-------------------------+-------------------------+-----------------------------+
```

Функцию `GET_FORMAT()` удобно использовать совместно с функциями `DATE_FORMAT()` и `TIME_FORMAT()`.

Результатом приведенного ниже запроса:

```sql
SELECT DATE_FORMAT('2023-10-20', GET_FORMAT(DATE, 'USA')),
       TIME_FORMAT('07:30:00', GET_FORMAT(TIME, 'USA'));
```

является:

```
+----------------------------------------------------+--------------------------------------------------+
| DATE_FORMAT('2023-10-20', GET_FORMAT(DATE, 'USA')) | TIME_FORMAT('07:30:00', GET_FORMAT(TIME, 'USA')) |
+----------------------------------------------------+--------------------------------------------------+
| 10.20.2023                                         | 07:30:00 AM                                      |
+----------------------------------------------------+--------------------------------------------------+
```

<hr>

[Содержание](#содержание)

## Примечания 9

**Примечание 1.** Формат ISO — международный стандарт, выпущенный организацией ISO (International Organization for Standardization), который описывает форматы дат и времени и дает рекомендации для их использования в международном контексте. Подробнее с форматом ISO, а также историей его создания можно ознакомиться по [ссылке](https://ru.wikipedia.org/wiki/ISO_8601).

**Примечание 2.** Если любой из функций, которые были рассмотрены в этом уроке, вместо даты, времени или даты и времени передать значение `NULL`, функции также вернут значение `NULL`.

**Примечание 3.** В SQL реализованы практически все необходимые функции для работы с датой и временем, и нами была рассмотрена большая их часть, однако не все. При необходимости со списком всех функций для работы с датой и временем можно ознакомиться по [ссылке](https://docs-python.ru/packages/klient-bd-mysql/funktsii-bd-mysql-raboty-datoi-vremenem/#PERIOD_ADD).

<hr>

[Содержание](#содержание)

# 4.10 Дополнительные функции

Урок посвящен функциям, предназначенным для решения различных вспомогательных задач.

## Функция `ISNULL()`
Функция `ISNULL()` используется для проверки значения на `NULL`. Она принимает в качестве аргумента произвольное значение и возвращает 1, если переданным значением является `NULL`, или 0 в противном случае.

Результатом приведенного ниже запроса:

```sql
SELECT ISNULL(0),
       ISNULL(1),
       ISNULL(1.1),
       ISNULL(''),
       ISNULL('bee'),
       ISNULL(NULL);
```

является:

```
+-----------+-----------+-------------+------------+---------------+--------------+
| ISNULL(0) | ISNULL(1) | ISNULL(1.1) | ISNULL('') | ISNULL('bee') | ISNULL(NULL) |
+-----------+-----------+-------------+------------+---------------+--------------+
| 0         | 0         | 0           | 0          | 0             | 1            |
+-----------+-----------+-------------+------------+---------------+--------------+
```

<hr>

[Содержание](#содержание)

## Функция `IF()`

Функция `IF()` используется для выбора одного из двух значений в зависимости от результата некоторого условного выражения. Она принимает три аргумента в следующем порядке:
+ `condition` — условное выражение
+ `value1` — произвольное значение
+ `value2` — произвольное значение

Функция возвращает значение `value1`, если условное выражение `condition` истинно, или значение `value2` в противном случае.

Результатом приведенного ниже запроса:

```sql
SELECT IF(1 > 0, 'bee', 'geek'),
       IF(1 < 0, 'bee', 'geek');
```

является:

```
+--------------------------+--------------------------+
| IF(1 > 0, 'bee', 'geek') | IF(1 < 0, 'bee', 'geek') |
+--------------------------+--------------------------+
| bee                      | geek                     |
+--------------------------+--------------------------+
```

<hr>

[Содержание](#содержание)

## Функция `COALESCE()`
Функция `COALESCE()` используется для поиска первого непустого значения. Она принимает переменное количество аргументов и возвращает первый из них, не равный `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT COALESCE(1, 2, 3),
       COALESCE(NULL, 2, 3),
       COALESCE(1, NULL, 3),
       COALESCE(NULL, NULL, 3);
```

является:

```
+-------------------+----------------------+----------------------+-------------------------+
| COALESCE(1, 2, 3) | COALESCE(NULL, 2, 3) | COALESCE(1, NULL, 3) | COALESCE(NULL, NULL, 3) |
+-------------------+----------------------+----------------------+-------------------------+
| 1                 | 2                    | 1                    | 3                       |
+-------------------+----------------------+----------------------+-------------------------+
```

Если все аргументы, переданные в функцию `COALESCE()`, являются значением `NULL`, возвращаемым значением функции также будет значение `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT COALESCE(NULL),
       COALESCE(NULL, NULL);
```

является:

```
+----------------+----------------------+
| COALESCE(NULL) | COALESCE(NULL, NULL) |
+----------------+----------------------+
| NULL           | NULL                 |
+----------------+----------------------+
```

<hr>

[Содержание](#содержание)

## Функция `IFNULL()`

Функция `IFNULL()` используется для замены некоторого значения на альтернативное, если исходное значение равняется `NULL`. Она принимает два аргумента в следующем порядке:
+ `value` — исходное значение
+ `alternative_value` — альтернативное значение

Функция возвращает значение `value`, если оно не равняется `NULL`, или значение `alternative_value` в противном случае.

Результатом приведенного ниже запроса:

```sql
SELECT IFNULL(NULL, 'geek'),
       IFNULL('bee', 'geek');
```

является:

```
+----------------------+-----------------------+
| IFNULL(NULL, 'geek') | IFNULL('bee', 'geek') |
+----------------------+-----------------------+
| geek                 | bee                   |
+----------------------+-----------------------+
```

<hr>

[Содержание](#содержание)

## Функция `NULLIF()`

Функция `NULLIF()` используется для сравнения двух значений. Она принимает два аргумента в следующем порядке:
+ `value1` — произвольное значение
+ `value2` — произвольное значение

Функция возвращает значение `NULL`, если значения `value1` и `value2` совпадают, или значение `value1` в противном случае.

Результатом приведенного ниже запроса:

```sql
SELECT NULLIF('bee', 'bee'),
       NULLIF('bee', 'geek');
```

является:

```
+----------------------+-----------------------+
| NULLIF('bee', 'bee') | NULLIF('bee', 'geek') |
+----------------------+-----------------------+
| NULL                 | bee                   |
+----------------------+-----------------------+
```

<hr>

[Содержание](#содержание)

## Функции `CONVERT()` и `CAST()`

Во время выполнения операций со значениями разных типов происходит автоматическое приведение этих значений к одному типу. Например, при попытке сложить число и строку СУБД сначала конвертирует прибавляемую строку в число.

Результатом приведенного ниже запроса:

```sql
SELECT 1 + '15';
```

является:

```
+----------+
| 1 + '15' |
+----------+
| 16.0     |
+----------+
```

Однако не всегда СУБД может автоматически привести используемые значения к нужному типу для корректного выполнения операции, поэтому иногда это приходится делать вручную. В SQL для преобразования типов используются функции `CONVERT()` и `CAST()`.

Функция `CONVERT()` принимает два аргумента в следующем порядке:
+ `value` — значение, которое необходимо преобразовать
+ `type` — желаемый тип

Функция приводит значение `value` к типу `type` и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT CONVERT(100.78, DECIMAL(4, 1)),
       CONVERT(100.78, DECIMAL(3, 0));
```

является:

```
+--------------------------------+--------------------------------+
| CONVERT(100.78, DECIMAL(4, 1)) | CONVERT(100.78, DECIMAL(3, 0)) |
+--------------------------------+--------------------------------+
| 100.8                          | 101                            |
+--------------------------------+--------------------------------+
```

Функция `CONVERT()` умеет приводить значение к следующим типам:

Тип | Описание
-|-
DATE | значение типа DATE
DATETIME | значение типа DATETIME
TIME | значение типа TIME
DECIMAL(M, D) | значение типа DECIMAL
CHAR(N) | значение типа CHAR
BINARY | значение типа BINARY
SIGNED | значение типа BIGINT с учетом знака
UNSIGNED | значение типа BIGINT без учета знака
YEAR | значение типа YEAR

Значение, приводимое к определенному типу, должно соответствовать формату этого типа, в противном случае функция `CONVERT()` вернет значение `NULL`. 

Результатом приведенного ниже запроса:

```sql
SELECT CONVERT('2023-01-01', DATE),
       CONVERT('beegeek', DATE);
```

является:

```
+-----------------------------+--------------------------+
| CONVERT('2023-01-01', DATE) | CONVERT('beegeek', DATE) |
+-----------------------------+--------------------------+
| 2023-01-01                  | NULL                     |
+-----------------------------+--------------------------+
```

Однако при попытке привести несоответствующее формату значение к числовому типу функция `CONVERT()` вернет значение 0.

Результатом приведенного ниже запроса:

```sql
SELECT CONVERT('beegeek', SIGNED),
       CONVERT('beegeek', UNSIGNED),
       CONVERT('beegeek', DECIMAL(5, 2));
```

является:

```
+----------------------------+------------------------------+-----------------------------------+
| CONVERT('beegeek', SIGNED) | CONVERT('beegeek', UNSIGNED) | CONVERT('beegeek', DECIMAL(5, 2)) |
+----------------------------+------------------------------+-----------------------------------+
| 0                          | 0                            | 0.00                              |
+----------------------------+------------------------------+-----------------------------------+
```

Похожим образом себя ведет функция `CAST()` за тем исключением, что она разделяет передаваемые аргументы не запятой, а ключевым словом `AS`.

Результатом приведенного ниже запроса:

```sql
SELECT CAST(100.78 AS DECIMAL(4, 1)),
       CAST(100.78 AS DECIMAL(3, 0));
```

является:

```
+-------------------------------+-------------------------------+
| CAST(100.78 AS DECIMAL(4, 1)) | CAST(100.78 AS DECIMAL(3, 0)) |
+-------------------------------+-------------------------------+
| 100.8                         | 101                           |
+-------------------------------+-------------------------------+
```

<hr>

[Содержание](#содержание)

## Примечания 10

**Примечание 1.** Практическое применение функции `NULLIF()` на первый взгляд недостаточно очевидно. Одним из примеров ее использования является реализация безопасного деления путем замены делителя на значение `NULL`, если тот равен нулю:

```sql
<делимое> / NULLIF(<делитель>, 0)
```

Если делитель не равен нулю, функция `NULLIF()` вернет его в исходном виде. Если же делитель равен нулю, функция вернет значение `NULL`, и результатом деления будет `NULL`.

**Примечание 2.** Использование функции `COALESCE()` считается хорошим тоном по сравнению с функцией `IFNULL()`, так как они по сути выполняют одно и то же, но функция `COALESCE()` может обрабатывать переменное количество аргументов, а функция `IFNULL()` — только два.

<hr>

[Содержание](#содержание)

# 4.11 Условные конструкции

Урок посвящен условным конструкциям.

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем Books, которая содержит информацию о пяти различных книгах, размещенных в некотором онлайн-магазине:

```
+----+------------------------+---------------------+-------+----------+
| id | title                  | author              | price | quantity |
+----+------------------------+---------------------+-------+----------+
| 1  | Fight Club             | Chuck Palahniuk     | 9.99  | 12       |
| 2  | The Catcher in the Rye | J.D. Salinger       | 3.49  | 1        |
| 3  | The Green Mile         | Stephen King        | 15.99 | 4        |
| 4  | The Great Gatsby       | F. Scott Fitzgerald | 7.99  | 3        |
| 5  | The Lord of the Rings  | J.R.R. Tolkien      | 29.99 | 0        |
+----+------------------------+---------------------+-------+----------+
```

Первое поле этой таблицы содержит уникальный идентификатор книги, второе — название, третье — данные об авторе, четвертое — цену в долларах, пятое — доступное для покупки количество.

Скрипт для создания таблицы `Books`

```sql
DROP TABLE IF EXISTS Books;
CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author    VARCHAR(40),
    price     DECIMAL(10, 2),
    quantity  INT
);

INSERT INTO Books (title, author, price, quantity)
VALUES ('Fight Club', 'Chuck Palahniuk', 9.99, 12),
       ('The Catcher in the Rye', 'J.D. Salinger', 3.49, 1),
       ('The Green Mile', 'Stephen King', 15.99, 4),
       ('The Great Gatsby', 'F. Scott Fitzgerald', 7.99, 3),
       ('The Lord of the Rings', 'J.R.R. Tolkien', 29.99, 0);
```

## Оператор `CASE`

Функция `IF()` позволяет выбрать одно из двух значений в зависимости от того, истинно определенное условие или нет. Она достаточно удобна, однако не подходит для построения каких-либо сложных условных конструкций, поскольку ограничена лишь двумя потенциальными значениями и единственным условием. Для решения задач, в которых необходимо выполнить проверку нескольких условий и в зависимости от истинности одного из них вернуть соответствующее значение, используется оператор `CASE`.

Для студентов, знакомых с любым современным языком программирования, оператор `CASE` покажется знакомым, поскольку функционально повторяет привычные ветвления `if-else`.

<hr>

[Содержание](#содержание)

### Простая форма

Оператор `CASE` поддерживает две формы записи: простую и усложненную. Простая форма имеет следующий синтаксис:

```sql
CASE <значение>
    WHEN <первое сравниваемое значение> THEN <результат>
    WHEN <второе сравниваемое значение> THEN <результат>
    ...
    WHEN <n-oe сравниваемое значение> THEN <результат>
    ELSE <значение по умолчанию>
END
```

Простая форма подразумевает, что после оператора `CASE` указывается некоторое значение, которое последовательно сравнивается на равенство с другими значениями. Каждое сравниваемое значение указывается после ключевого слова `WHEN`, а результат, который будет возвращен, если исходное значение и сравниваемое окажутся равными, — после ключевого слова `THEN`. Если исходное значение не совпадет ни с одним из сравниваемых значений, результатом будет значение по умолчанию, которое указывается после ключевого слова `ELSE`.

Ключевое слово `ELSE` может быть опущено, в таком случае значением по умолчанию считается `NULL`.

Условная конструкция с оператором `CASE` может использоваться как для преобразования значения для дальнейшего его использования, так и для последующего извлечения. Если возвращаемое оператором `CASE` значение предполагается отображать в результирующей таблице, то в таком случае полю с этим значением можно дать псевдоним, который необходимо указать после ключевого слова `END`.

```sql
    ...
    WHEN <n-oe сравниваемое значение> THEN <результат>
    ELSE <значение по умолчанию>
END AS <псевдоним>
```

В качестве примера использования простой формы оператора `CASE` напишем запрос, который извлекает информацию о книгах и сообщает об их доступном для покупки количестве.

Результатом приведенного ниже запроса:

```sql
SELECT title, author,
       CASE quantity
           WHEN 0 THEN 'Out of stock'
           WHEN 1 THEN 'One in stock'
           WHEN 2 THEN 'Little in stock'
           WHEN 3 THEN 'Little in stock'
           WHEN 4 THEN 'Little in stock'
           WHEN 5 THEN 'Little in stock'
           ELSE 'A lot in stock'
       END AS availability
FROM Books;
```

является:

```
+------------------------+---------------------+-----------------+
| title                  | author              | availability    |
+------------------------+---------------------+-----------------+
| Fight Club             | Chuck Palahniuk     | A lot in stock  |
| The Catcher in the Rye | J.D. Salinger       | One in stock    |
| The Green Mile         | Stephen King        | Little in stock |
| The Great Gatsby       | F. Scott Fitzgerald | Little in stock |
| The Lord of the Rings  | J.R.R. Tolkien      | Out of stock    |
+------------------------+---------------------+-----------------+
```

В запросе выше числовые значения поля `quantity` преобразуются в соответствующие им строковые значения путем последовательных сравнений. Значение поля `quantity`, попадая в условную конструкцию, сравнивается с числами от 0 до 5, пока не будет найдено совпадение с одним из них. Например, для значения 0 результатом будет строка `Out of stock`, для значения 3 — строка `Little in stock`. Для значений больше 5 результатом будет значение по умолчанию — строка `A lot in stock`, поскольку для такого числа гарантированно не будет найдено ни одно совпадение.

<hr>

[Содержание](#содержание)

### Усложненная форма

Усложненная форма оператора `CASE` имеет следующий синтаксис:

```sql
CASE
    WHEN <первое условие> THEN <результат>
    WHEN <второе условие> THEN <результат>
    ...
    WHEN <n-oe условие> THEN <результат>
    ELSE <значение по умолчанию>
END AS <псевдоним>
```

Ключевая разница усложненной формы от простой заключается в том, что она не требует какого-либо значения, которое будет сравниваться с другими. По сути усложненная форма представляет собой набор произвольных условий, которые последовательно проверяются на истинность. Если проверяемое условие истинно, то результатом будет соответствующее ему значение, если ложно — проверка перейдет к следующему условию. Если все условия окажутся ложными, результатом будет значение по умолчанию.

Усложненная форма позволяет писать более гибкие и компактные условные конструкции. В качестве демонстрации преимущества усложненной формы напишем запрос, выполняющий ровно ту же задачу, что выполнял предыдущий запрос с оператором `CASE` в простой форме.

Результатом приведенного ниже запроса:

```sql
SELECT title, author,
       CASE
           WHEN quantity = 0 THEN 'Out of stock'
           WHEN quantity = 1 THEN 'One in stock'
           WHEN quantity BETWEEN 2 AND 5 THEN 'Little in stock'
           ELSE 'A lot in stock'
       END AS availability
FROM Books;
```

является:

```
+------------------------+---------------------+-----------------+
| title                  | author              | availability    |
+------------------------+---------------------+-----------------+
| Fight Club             | Chuck Palahniuk     | A lot in stock  |
| The Catcher in the Rye | J.D. Salinger       | One in stock    |
| The Green Mile         | Stephen King        | Little in stock |
| The Great Gatsby       | F. Scott Fitzgerald | Little in stock |
| The Lord of the Rings  | J.R.R. Tolkien      | Out of stock    |
+------------------------+---------------------+-----------------+
```

Запрос выше по-прежнему извлекает поля `title`, `author` и `availability`, однако для вычисления значений последнего поля оператор `CASE` не привязывается к полю `quantity`, а лишь использует его значения в своих условиях. Так, если значение поля `quantity` равняется 0, то значением поля `availability` будет строка `Out of stock`, если значение представляет собой число в диапазоне [2; 5], то значением поля `availability` будет строка `Little in stock`. Для значений больше 5 определено значение по умолчанию в виде строки `A lot in stock`.

В качестве дополнительного примера использования усложненной формы оператора `CASE` напишем запрос, который извлекает информацию о книгах и оценивает их стоимость.

Результатом приведенного ниже запроса:

```sql
SELECT title, author,
       CASE
           WHEN price < 5 THEN 'Cheap'
           WHEN price BETWEEN 5 AND 15 THEN 'Regular'
           ELSE 'Expensive'
       END AS rate
FROM Books;
```

является:

```
+------------------------+---------------------+-----------+
| title                  | author              | rate      |
+------------------------+---------------------+-----------+
| Fight Club             | Chuck Palahniuk     | Regular   |
| The Catcher in the Rye | J.D. Salinger       | Cheap     |
| The Green Mile         | Stephen King        | Expensive |
| The Great Gatsby       | F. Scott Fitzgerald | Regular   |
| The Lord of the Rings  | J.R.R. Tolkien      | Expensive |
+------------------------+---------------------+-----------+
```

Здесь оператор `CASE` используется для создания поля `rate` с оценкой стоимости книги. Если ее цена меньше 5 долларов, она считается дешевой, если от 5 до 15 — обычной, в остальных случаях книга считается дорогой.

<hr>

[Содержание](#содержание)

## Примечания 11

**Примечание 1.** Оператор `CASE` может рассматриваться как функция, поскольку результатом его выполнения, независимо от формы, всегда является определенное значение. Например, условные конструкции можно использовать в блоках операторов `WHERE` и `ORDER BY`, а также помещать их в различные функции для последующего преобразования результата.

Результатом приведенного ниже запроса:

```sql
SELECT title, author,
       UPPER(CASE
                 WHEN price < 5 THEN 'Cheap'
                 WHEN price BETWEEN 5 AND 15 THEN 'Regular'
                 ELSE 'Expensive'
             END) AS rate
FROM Books;
```

является:

```
+------------------------+---------------------+-----------+
| title                  | author              | rate      |
+------------------------+---------------------+-----------+
| Fight Club             | Chuck Palahniuk     | REGULAR   |
| The Catcher in the Rye | J.D. Salinger       | CHEAP     |
| The Green Mile         | Stephen King        | EXPENSIVE |
| The Great Gatsby       | F. Scott Fitzgerald | REGULAR   |
| The Lord of the Rings  | J.R.R. Tolkien      | EXPENSIVE |
+------------------------+---------------------+-----------+
```

<hr>

[Содержание](#содержание)