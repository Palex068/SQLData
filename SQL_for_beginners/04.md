# 4.  Встроенные функции

## Содержание


+ [4.1 Текстовые функции. Часть 1](#41-текстовые-функции-часть-1)
    + [Функции](#функции)
    + [Функция `CHAR_LENGTH()`](#функция-char_length)
    + [Функция `LOWER()`](#функция-lower)
    + [Функция `UPPER()`](#функция-upper)
    + [Функции `LTRIM()` и `RTRIM()`](#функции-ltrim-и-rtrim)
    + [Функция `REVERSE()`](#функция-reverse)
    + [Функция `REPEAT()`](#функция-repeat)
    + [Функции `LPAD()` и `RPAD()`](#функции-lpad-и-rpad)
    + [Примеры использования функций](#примеры-использования-функций-1)
+ [4.2 Текстовые функции. Часть 2](#42-текстовые-функции-часть-2)
    + [Функция `LEFT()`](#функция-left)
    + [Функция `RIGHT()`](#функция-right)
    + [Функция `LOCATE()`](#функция-locate)
    + [Функция `REPLACE()`](#функция-reverse)
+ [4.3 Текстовые функции. Часть 3](#43-текстовые-функции-часть-3)
    + [Функция `SUBSTRING()`](#функция-substring)
    + [Функция `SUBSTRING_INDEX()`](#функция-substring_index)
    + [Функция `TRIM()`](#функция-trim)
+ [4.4 Числовые функции. Часть 1](#44-числовые-функции-часть-1)
    + [Операторы `DIV` и `MOD`](#операторы-div-и-mod)
    + [Функция `ABS()`](#функция-abs)
    + [Функция `ROUND()`](#функция-round)
    + [Функция `POW()`](#функция-pow)
    + [Функция `SQRT()`](#функция-sqrt)
    + [Функция `RAND()`](#функция-rand)
+ [4.5 Числовые функции. Часть 2](#45-числовые-функции-часть-2)
    + [Функции `DEGREES()` и `RADIANS()`](#функции-degrees-и-radians)
    + [Функции  `PI()`, `COS()`, `SIN()` и `TAN()`](#функции-pi-sin-cos-и-tan)
    + [Функции `LEAST()` и `GREATEST()`](#функции-least-и-greatest)
    + [Функция `CONV()`](#функция-conv)
    + [Функция `FORMAT()`](#функция-format)
+ [4.6 Функции даты и времени. Часть 1](#46-функции-даты-и-времени-часть-1)
    + [Временные интервалы](#временные-интервалы)
    + [Функции `NOW()`, `CURDATE()` и `CURTIME()`](#функции-now-curdate-и-curtime)
    + [Функции `UTC_TIMESTAMP()`, `UTC_DATE()` и `UTC_TIME()`](#функции-utc_timestamp-utc_date-и-utc_time)
    + [Функция `MAKEDATE()`](#функция-makedate)
    + [Функция `MAKETIME()`](#функция-maketime)
    + [Функция `TIME_TO_SEC()` и `SEC_TO_TIME()`](#функция-time_to_sec-и-sec_to_time)
    + [Функции `TO_DAYS()` и `TO_SECONDS()`](#функции-to_days-и-to_seconds)
    + [Функция `LAST_DAY()`](#функция-last_day)
+ [4.7 Функции даты и времени. Часть 2](#47-функции-даты-и-времени-часть-2)
    + [Функции `DATE()` и `TIME()`](#функции-date-и-time)
    + [Функции `HOUR()`, `MINUTE()`, `SECOND()` и `MICROSECOND()`](#функции-hour-minute-second-и-microsecond)
    + [Функции `YEAR()`, `MONTH()` и `DAY()`](#функции-year-month-и-day)
    + [Функция `DAYOFYEAR()`](#функция-dayofyear)
    + [Функция `WEEK()`](#функция-week)
    + [Функция `WEEKDAY()`](#функция-weekday)
    + [Функция `QUARTER()`](#функция-quarter)
    + [Функция `DAYNAME()`](#функция-dayname)
    + [Функция `MONTHNAME()`](#функция-monthname)
+ [4.8 Функции даты и времени. Часть 3](#48-функции-даты-и-времени-часть-3)
+ [4.9 Функции даты и времени. Часть 4](#49-функции-даты-и-времени-часть-4)
+ [4.10 Дополнительные функции](#410-дополнительные-функции)
+ [4.11 Условные конструкции](#411-условные-конструкции)

[Оглавление](/SQL_for_beginners/README.MD)

# 4.1 Текстовые функции. Часть 1

Урок посвящен функциям, предназначенным для обработки текстовых данных.

## Функции

Как и практически любой язык программирования, SQL имеет множество встроенных функций, которые позволяют выполнять различные манипуляции с данными. Все встроенные функции можно разбить на четыре основных типа:
+ **Текстовые функции.** Используются для обработки текста, например, для отсечения пробелов или преобразования символов в верхний регистр.
+ **Числовые функции.** Используются для выполнения математических операций над числовыми данными: например, возведения в степень или извлечения квадратного корня.
+ **Функции даты и времени.** Используются для обработки даты и времени, это может быть определение разницы между датами или проверка даты на корректность.
+ **Системные функции.** Используются для получения специфичной для конкретной СУБД информации, к примеру, сведений об учетной записи пользователя.

Одними из самых важных являются текстовые функции, так как таблицы баз данных зачастую содержат немалое количество текстовой информации. Поэтому знакомство со встроенными функциями мы начнем именно с тех, которые предназначены для обработки строковых значений.

Для более наглядной демонстрации работы рассматриваемых функций мы будем применять их к конкретным значениям, а не к полям какой-либо таблицы.

<hr>

[Содержание](#содержание)

## Функция `CHAR_LENGTH()`
Функция `CHAR_LENGTH()` используется для вычисления длины строки. Она принимает в качестве аргумента строку и возвращает количество символов в ней.

Результатом приведенного ниже запроса:

```sql
SELECT CHAR_LENGTH(''),
       CHAR_LENGTH('b'),
       CHAR_LENGTH('bee'),
       CHAR_LENGTH('beegeek');
```

является:

```
+-----------------+------------------+--------------------+------------------------+
| CHAR_LENGTH('') | CHAR_LENGTH('b') | CHAR_LENGTH('bee') | CHAR_LENGTH('beegeek') |
+-----------------+------------------+--------------------+------------------------+
| 0               | 1                | 3                  | 7                      |
+-----------------+------------------+--------------------+------------------------+
```

<hr>

[Содержание](#содержание)

## Функция `LOWER()`
Функция `LOWER()` используется для перевода строки в нижний регистр. Она принимает в качестве аргумента строку, преобразует все ее символы в нижний регистр и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT LOWER('beegeek'),
       LOWER('BeeGeek'),
       LOWER('BEEGEEK');
```

является:

```
+------------------+------------------+------------------+
| LOWER('beegeek') | LOWER('BeeGeek') | LOWER('BEEGEEK') |
+------------------+------------------+------------------+
| beegeek          | beegeek          | beegeek          |
+------------------+------------------+------------------+
```

<hr>

[Содержание](#содержание)

## Функция `UPPER()`

Функция `UPPER()` используется для перевода строки в верхний регистр. Она принимает в качестве аргумента строку, преобразует все ее символы в верхний регистр и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT UPPER('beegeek'),
       UPPER('BeeGeek'),
       UPPER('BEEGEEK');
```

является:

```
+------------------+------------------+------------------+
| UPPER('beegeek') | UPPER('BeeGeek') | UPPER('BEEGEEK') |
+------------------+------------------+------------------+
| BEEGEEK          | BEEGEEK          | BEEGEEK          |
+------------------+------------------+------------------+
```

<hr>

[Содержание](#содержание)

## Функции `LTRIM()` и `RTRIM()`

Функция `LTRIM()` используется для отсечения ведущих пробелов. Она принимает в качестве аргумента строку, удаляет все пробелы из ее левой части и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT LTRIM(' bee'),
       LTRIM('  bee'),
       LTRIM('   bee');
```

является:

```
+---------------+----------------+-----------------+
| LTRIM(' bee') | LTRIM('  bee') | LTRIM('   bee') |
+---------------+----------------+-----------------+
| bee           | bee            | bee             |
+---------------+----------------+-----------------+
```

Похожим образом работает функция `RTRIM()` за исключением того, что она удаляет пробелы из правой части строки, а не левой.

<hr>

[Содержание](#содержание)

## Функция `REVERSE()`

Функция `REVERSE()` используется для переворота строки. Она принимает в качестве аргумента строку и возвращает ее с обратным порядком символов.

Результатом приведенного ниже запроса:

```sql
SELECT REVERSE('b'),
       REVERSE('bee'),
       REVERSE('beegeek');
```

является:

```
+--------------+----------------+--------------------+
| REVERSE('b') | REVERSE('bee') | REVERSE('beegeek') |
+--------------+----------------+--------------------+
| b            | eeb            | keegeeb            |
+--------------+----------------+--------------------+
```

<hr>

[Содержание](#содержание)

## Функция `REPEAT()`

Функция `REPEAT()` используется для повторения строки. Она принимает два аргумента в следующем порядке:
+ `str` — исходная строка
+ `count` — количество повторений

Функция возвращает строку, состоящую из строки `str`, повторяющейся `count` раз.

Результатом приведенного ниже запроса:

```sql
SELECT REPEAT('bee', 1),
       REPEAT('bee', 2),
       REPEAT('bee', 3);
```

является:

```
+------------------+------------------+------------------+
| REPEAT('bee', 1) | REPEAT('bee', 2) | REPEAT('bee', 3) |
+------------------+------------------+------------------+
| bee              | beebee           | beebeebee        |
+------------------+------------------+------------------+
```

Если количество повторов меньше 1, то функция `REPEAT()` вернет пустую строку.

Результатом приведенного ниже запроса:

```sql
SELECT REPEAT('bee', 0),
       REPEAT('bee', -1);
```

является:

```
+------------------+-------------------+
| REPEAT('bee', 0) | REPEAT('bee', -1) |
+------------------+-------------------+
|                  |                   |
+------------------+-------------------+
```

<hr>

[Содержание](#содержание)

## Функции `LPAD()` и `RPAD()`

Функция `LPAD()` используется для увеличения длины строки до определенного значения путем добавления в ее начало другой строки. Она принимает три аргумента в следующем порядке:

+ `str` — исходная строка
+ `len` — желаемая длина строки
+ `padstr` — дополняющая строка

Функция добавляет строку `padstr` в начало строки `str` до тех пор, пока длина второй не станет равна `len`, и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT LPAD('bee', 5, '-'),
       LPAD('bee', 7, '-'),
       LPAD('bee', 9, '-+');
```
является:

```
+---------------------+---------------------+----------------------+
| LPAD('bee', 5, '-') | LPAD('bee', 7, '-') | LPAD('bee', 9, '-+') |
+---------------------+---------------------+----------------------+
| --bee               | ----bee             | -+-+-+bee            |
+---------------------+---------------------+----------------------+
```

Если длина исходной строки после добавления в ее начало дополняющей строки превышает желаемую длину, то функция `LPAD()` сокращает дополняющую строку путем отбрасывания правых символов.

Результатом приведенного ниже запроса:

```sql
SELECT LPAD('bee', 4, '-+-+'),
       LPAD('bee', 5, '-+-+'),
       LPAD('bee', 6, '-+-+');
```

является:

```
+------------------------+------------------------+------------------------+
| LPAD('bee', 4, '-+-+') | LPAD('bee', 5, '-+-+') | LPAD('bee', 6, '-+-+') |
+------------------------+------------------------+------------------------+
| -bee                   | -+bee                  | -+-bee                 |
+------------------------+------------------------+------------------------+
```

Если желаемая длина строки меньше длины исходной строки, то функция `LPAD()` сокращает исходную строку путем отбрасывания правых символов.

Результатом приведенного ниже запроса:

```sql
SELECT LPAD('bee', 2, '-'),
       LPAD('bee', 1, '-');
```

является:

```
+---------------------+---------------------+
| LPAD('bee', 2, '-') | LPAD('bee', 1, '-') |
+---------------------+---------------------+
| be                  | b                   |
+---------------------+---------------------+
```

Похожим образом себя ведет функция `RPAD()` за исключением того, что она дополняет строку не слева, а справа.

Результатом приведенного ниже запроса:

```sql
SELECT RPAD('bee', 5, '-'),
       RPAD('bee', 7, '-+'),
       RPAD('bee', 6, '-+-+'),
       RPAD('bee', 2, '-');
```

является: 

```sql
+---------------------+----------------------+------------------------+---------------------+
| RPAD('bee', 5, '-') | RPAD('bee', 7, '-+') | RPAD('bee', 6, '-+-+') | RPAD('bee', 2, '-') |
+---------------------+----------------------+------------------------+---------------------+
| bee--               | bee-+-+              | bee-+-                 | be                  |
+---------------------+----------------------+------------------------+---------------------+
```

<hr>

[Содержание](#содержание)

## Примечания 1

**Примечание 1.** Функции могут применяться как в блоке оператора `SELECT`, так и в блоках операторов `WHERE` и `ORDER BY`.

Предположим, во время работы с персональными данными людей нам необходимо выполнить их сортировку по именам, хранящимся в поле name, однако сортировка должна происходить не по прямым значениям имен, а по количеству символов в них. В рамках запроса такой вариант сортировки будет выглядеть следующим образом:

```sql
...
ORDER BY CHAR_LENGTH(name);
```

**Примечание 2.** Одним из недостатков функций является то, что в разных СУБД могут применяться разные функции для одних и тех же целей, и лишь некоторые функции в различных СУБД называются одинаково. Общая функциональность доступна в каждой СУБД, но названия функций и их синтаксис могут существенно отличаться. 

**Примечание 3.** Функции `CHAR_LENGTH()`, `LOWER()`, `UPPER()`, `LTRIM()`, `RTRIM()`, `REVERSE()`, `REPEAT()`, `LPAD()` и `RPAD()` при вызове с аргументом `NULL` возвращают значение `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT CHAR_LENGTH(NULL)  AS value1,
       LOWER(NULL)        AS value2,
       UPPER(NULL)        AS value3,
       LTRIM(NULL)        AS value4,
       REVERSE(NULL)      AS value5,
       REPEAT(NULL, 2)    AS value6,
       LPAD(NULL, 5, '-') AS value7;
```

является:

```
+--------+--------+--------+--------+--------+--------+--------+
| value1 | value2 | value3 | value4 | value5 | value6 | value7 |
+--------+--------+--------+--------+--------+--------+--------+
| NULL   | NULL   | NULL   | NULL   | NULL   | NULL   | NULL   |
+--------+--------+--------+--------+--------+--------+--------+
```

**Примечание 4.** Несмотря на то что функции `CHAR_LENGTH()`, `REVERSE()`, `REPEAT()`, `LPAD()` и `RPAD()` в первую очередь предназначены для работы со строковыми значениями, они также могут обрабатывать и числовые данные.

Результатом приведенного ниже запроса:

```sql
SELECT CHAR_LENGTH(123),
       REVERSE(123),
       REPEAT(123, 2),
       LPAD(123, 4, '-');
```

является:

```
+------------------+--------------+----------------+-------------------+
| CHAR_LENGTH(123) | REVERSE(123) | REPEAT(123, 2) | LPAD(123, 4, '-') |
+------------------+--------------+----------------+-------------------+
| 3                | 321          | 123123         | -123              |
+------------------+--------------+----------------+-------------------+
```

<hr>

[Содержание](#содержание)

## Примеры использования функций 1

В начале урока мы рассмотрели примеры использования функций, в которых они применяются к конкретным значениям. В связи с этим у многих из вас возникли сложности с применением функций к полям таблицы, поэтому мы решили добавить несколько таких примеров.

**Используемая база данных**

Перед тем как приступить к рассмотрению примеров, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем Songs, которая содержит информацию о пяти наиболее популярных песнях на некоторой площадке для прослушивания музыки:

```
+----+-------+----------------------+------------+---------+
| id | place | trackname            | artist     | streams |
+----+-------+----------------------+------------+---------+
| 1  | 4     | Crazy On You         | Heart      | 76338   |
| 2  | 3     | My Lover             | The Sounds | 99488   |
| 3  | 2     | Running up That Hill | Kate Bush  | 121495  |
| 4  | 5     | Thrill               | The Sounds | 49345   |
| 5  | 1     | Spent the Day in Bed | Morrissey  | 174994  |
+----+-------+----------------------+------------+---------+
```

Первое поле этой таблицы содержит уникальный идентификатор песни, второе — позицию песни в топе, третье — название песни, четвертое — псевдоним исполнителя или название группы, пятое — количество прослушиваний.

Скрипт для создания таблицы Songs

```sql
DROP TABLE IF EXISTS Songs;
CREATE TABLE Songs
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    place     INT,
    trackname VARCHAR(30),
    artist    VARCHAR(30),
    streams   INT
);

INSERT INTO Songs (place, trackname, artist, streams)
VALUES (4, 'Crazy On You', 'Heart', 76338),
       (3, 'My Lover', 'The Sounds', 99488),
       (2, 'Running up That Hill', 'Kate Bush', 121495),
       (5, 'Thrill', 'The Sounds', 49345),
       (1, 'Spent the Day in Bed', 'Morrissey', 174994);
```

## Применение функций 1

Для того, чтобы применить функцию к полю таблицы, достаточно просто указать это поле в качестве аргумента функции. Давайте рассмотрим несколько примеров.

**Пример 1.** Необходимо извлечь имена исполнителей, а также посчитать количество символов в именах исполнителей. Для этого мы можем использовать функцию `CHAR_LENGTH()`.

Результатом приведенного ниже запроса:

```sql
SELECT artist, CHAR_LENGTH(artist) AS length
FROM Songs;
```

является:

```
+------------+--------+
| artist     | length |
+------------+--------+
| Heart      | 5      |
| The Sounds | 10     |
| Kate Bush  | 9      |
| The Sounds | 10     |
| Morrissey  | 9      |
+------------+--------+
```

**Пример 2.** Необходимо извлечь имена исполнителей и названия их песен, при этом названия песен должны быть отображены в нижнем регистре. Для этого мы можем использовать функцию `LOWER()`.

Результатом приведенного ниже запроса:

```sql
SELECT artist, LOWER(trackname) AS trackname
FROM Songs;
```

является:

```
+------------+----------------------+
| artist     | trackname            |
+------------+----------------------+
| Heart      | crazy on you         |
| The Sounds | my lover             |
| Kate Bush  | running up that hill |
| The Sounds | thrill               |
| Morrissey  | spent the day in bed |
+------------+----------------------+
```

**Пример 3.** Необходимо извлечь имена исполнителей и названия их песен, при этом названия песен должны быть отображены в верхнем регистре в обратном порядке. Для этого мы можем использовать функции `UPPER()` и `REVERSE()`.

Результатом приведенного ниже запроса:

```sql
SELECT artist, REVERSE(UPPER(trackname)) AS trackname
FROM Songs;
```

является:

```
+------------+----------------------+
| artist     | trackname            |
+------------+----------------------+
| Heart      | UOY NO YZARC         |
| The Sounds | REVOL YM             |
| Kate Bush  | LLIH TAHT PU GNINNUR |
| The Sounds | LLIRHT               |
| Morrissey  | DEB NI YAD EHT TNEPS |
+------------+----------------------+
```

Результатом выполнения функции является определенное значение, поэтому функцию можно использовать в качестве аргумента другой функции. В этом примере сначала функция `UPPER()` переводит строку в верхний регистр, а затем функция `REVERSE()` переворачивает эту строку. При этом, если поменять функции местами, результат не изменится.

Результатом приведенного ниже запроса:

```sql
SELECT artist, UPPER(REVERSE(trackname)) AS trackname
FROM Songs;
```

является:

```
+------------+----------------------+
| artist     | trackname            |
+------------+----------------------+
| Heart      | UOY NO YZARC         |
| The Sounds | REVOL YM             |
| Kate Bush  | LLIH TAHT PU GNINNUR |
| The Sounds | LLIRHT               |
| Morrissey  | DEB NI YAD EHT TNEPS |
+------------+----------------------+
```

Разница заключается лишь в том, что сначала выполнится функция `REVERSE()`, а только потом `UPPER()`. Но при перестановке функций результат не всегда будет одинаковым, в некоторых случаях порядок вложения функций нужно соблюдать.

**Пример 4.** Необходимо извлечь имена исполнителей, при этом каждое имя необходимо развернуть, а затем дополнить символом ! с начала строки до длины 20. Для этого мы можем использовать функции `REVERSE()` и `LPAD()`.

Результатом приведенного ниже запроса:

```sql
SELECT artist, LPAD(REVERSE(artist), 20, '!') AS result
FROM Songs;
```

является:

```
+------------+----------------------+
| artist     | result               |
+------------+----------------------+
| Heart      | !!!!!!!!!!!!!!!traeH |
| The Sounds | !!!!!!!!!!sdnuoS ehT |
| Kate Bush  | !!!!!!!!!!!hsuB etaK |
| The Sounds | !!!!!!!!!!sdnuoS ehT |
| Morrissey  | !!!!!!!!!!!yessirroM |
+------------+----------------------+
```

В этом примере сначала функция `REVERSE()` переворачивает строку, а затем функция `LPAD()` дополняет ее символом `!`. Это пример того, где порядок вложения функций имеет значение. Если мы поменяем функции местами, результат уже будет другим.

Результатом приведенного ниже запроса:

```sql
SELECT artist, REVERSE(LPAD(artist, 20, '!')) AS result
FROM Songs;
```

является:

```
+------------+----------------------+
| artist     | result               |
+------------+----------------------+
| Heart      | traeH!!!!!!!!!!!!!!! |
| The Sounds | sdnuoS ehT!!!!!!!!!! |
| Kate Bush  | hsuB etaK!!!!!!!!!!! |
| The Sounds | sdnuoS ehT!!!!!!!!!! |
| Morrissey  | yessirroM!!!!!!!!!!! |
+------------+----------------------+
```

<hr>

[Содержание](#содержание)

# 4.2 Текстовые функции. Часть 2

Урок посвящен функциям, предназначенным для обработки текстовых данных.

## Функция `LEFT()`

Функция `LEFT()` используется для извлечения определенного количества символов из начала строки. Она принимает два аргумента в следующем порядке:
+ `str` — исходная строка
+ `count` — количество извлекаемых символов

Функция возвращает строку, состоящую из первых `count` символов строки `str`.

Результатом приведенного ниже запроса:

```sql
SELECT LEFT('beegeek', 1),
       LEFT('beegeek', 3),
       LEFT('beegeek', 7);
```

является:

```
+--------------------+--------------------+--------------------+
| LEFT('beegeek', 1) | LEFT('beegeek', 3) | LEFT('beegeek', 7) |
+--------------------+--------------------+--------------------+
| b                  | bee                | beegeek            |
+--------------------+--------------------+--------------------+
```

Если количество извлекаемых символов меньше 1, функция `LEFT()` вернет пустую строку.

Результатом приведенного ниже запроса:

```sql
SELECT LEFT('beegeek', 0),
       LEFT('beegeek', -1);
```

является:

```
+--------------------+---------------------+
| LEFT('beegeek', 0) | LEFT('beegeek', -1) |
+--------------------+---------------------+
|                    |                     |
+--------------------+---------------------+
```

Если количество извлекаемых символов больше длины строки, функция `LEFT()` вернет всю строку.

Результатом приведенного ниже запроса:

```sql
SELECT LEFT('beegeek', 50),
       LEFT('beegeek', 100);
```

является:

```
+---------------------+----------------------+
| LEFT('beegeek', 50) | LEFT('beegeek', 100) |
+---------------------+----------------------+
| beegeek             | beegeek              |
+---------------------+----------------------+
```

<hr>

[Содержание](#содержание)

## Функция `RIGHT()`
Функция `RIGHT()` используется для извлечения определенного количества символов из конца строки. Она принимает два аргумента в следующем порядке:
+ `str` — исходная строка
+ `count` — количество извлекаемых символов

Функция возвращает строку, состоящую из последних `count` символов строки `str`.

Результатом приведенного ниже запроса:

```sql
SELECT RIGHT('beegeek', 1),
       RIGHT('beegeek', 3),
       RIGHT('beegeek', 7);
```

является:

```
+---------------------+---------------------+---------------------+
| RIGHT('beegeek', 1) | RIGHT('beegeek', 3) | RIGHT('beegeek', 7) |
+---------------------+---------------------+---------------------+
| k                   | eek                 | beegeek             |
+---------------------+---------------------+---------------------+
```

Аналогично функции `LEFT()`, если количество извлекаемых символов меньше 1, функция `RIGHT()` вернет пустую строку, если больше длины строки — всю строку.

<hr>

[Содержание](#содержание)

## Функция `LOCATE()`

Функция `LOCATE()` используется для определения местоположения подстроки в строке. Она принимает три аргумента в следующем порядке:
+ `substr` — искомая подстрока
+ `str` — исходная строка
+ `start` — позиция начала поиска (может не указываться, в таком случае поиск выполняется с начала строки)

Функция выполняет поиск подстроки `substr` в строке `str`, начиная с позиции `start`, и возвращает позицию ее первого вхождения.

Результатом приведенного ниже запроса:

```sql
SELECT LOCATE('e', 'beegeek'),
       LOCATE('g', 'beegeek'),
       LOCATE('eg', 'beegeek'),
       LOCATE('geek', 'beegeek');
```

является:


| LOCATE('e', 'beegeek') | LOCATE('g', 'beegeek') | LOCATE('eg', 'beegeek') | LOCATE('geek', 'beegeek') |
-|-|-|-
| 2                      | 4                      | 3                       | 4                         |

Обратите внимание, что при использовании функции `LOCATE()` символы исходной строки нумеруются с 1, а не с 0.

Результатом приведенного ниже запроса:

```sql
SELECT LOCATE('e', 'beegeek', 2),
       LOCATE('e', 'beegeek', 4);
```

является:

```
+---------------------------+---------------------------+
| LOCATE('e', 'beegeek', 2) | LOCATE('e', 'beegeek', 4) |
+---------------------------+---------------------------+
| 2                         | 5                         |
+---------------------------+---------------------------+
```

Также следует отметить, что функция `LOCATE()` выполняет поиск позиции подстроки без учета регистра.

Результатом приведенного ниже запроса:

```sql
SELECT LOCATE('E', 'beegeek'),
       LOCATE('GEEK', 'beegeek');
```

является:

```
+------------------------+---------------------------+
| LOCATE('E', 'beegeek') | LOCATE('GEEK', 'beegeek') |
+------------------------+---------------------------+
| 2                      | 4                         |
+------------------------+---------------------------+
```

Если искомой подстроки в строке нет, функция `LOCATE()` вернет значение 0.

Результатом приведенного ниже запроса:

```sql
SELECT LOCATE('a', 'beegeek'),
       LOCATE('eb', 'beegeek');
```

является:

```
+------------------------+-------------------------+
| LOCATE('a', 'beegeek') | LOCATE('eb', 'beegeek') |
+------------------------+-------------------------+
| 0                      | 0                       |
+------------------------+-------------------------+
```

<hr>

[Содержание](#содержание)

## Функция `REPLACE()`

Функция `REPLACE()` используется для замены подстроки в строке. Она принимает три аргумента в следующем порядке:
+ `str` — исходная строка
+ `from_str` — заменяемая подстрока
+ `to_str` — заменяющая подстрока

Функция заменяет все вхождения подстроки `from_str` в строке `str` на подстроку `to_str` и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT REPLACE('beegeek', 'e', 'i'),
       REPLACE('beegeek', 'geek', 'g'),
       REPLACE('beegeek', 'geek', 'Geek');
```

является:

| REPLACE <br> ('beegeek', 'e', 'i') | REPLACE <br> ('beegeek', 'geek', 'g') | REPLACE <br> ('beegeek', 'geek', 'Geek') |
-|-|-
| biigiik   | beeg  | beeGeek    |

Если заменяемой подстроки в строке нет, функция `REPLACE()` вернет строку в исходном виде.

Результатом приведенного ниже запроса:

```sql
SELECT REPLACE('beegeek', 'a', 'i'),
       REPLACE('beegeek', 'keeg', 'Keeg');
```

является:

```
+------------------------------+------------------------------------+
| REPLACE('beegeek', 'a', 'i') | REPLACE('beegeek', 'keeg', 'Keeg') |
+------------------------------+------------------------------------+
| beegeek                      | beegeek                            |
+------------------------------+------------------------------------+
```

В отличие от функции `LOCATE()`, функция `REPLACE()` выполняет замену с учетом регистра.

Результатом приведенного ниже запроса:

```sql
SELECT REPLACE('beegeek', 'B', 'BBB'),
       REPLACE('beegeek', 'b', 'bbb');
```

является:

```
+--------------------------------+--------------------------------+
| REPLACE('beegeek', 'B', 'BBB') | REPLACE('beegeek', 'b', 'bbb') |
+--------------------------------+--------------------------------+
| beegeek                        | bbbeegeek                      |
+--------------------------------+--------------------------------+
```

<hr>

[Содержание](#содержание)

# 4.3 Текстовые функции. Часть 3

Урок посвящен функциям, предназначенным для обработки текстовых данных.

## Функция `SUBSTRING()`

Функция `SUBSTRING()` используется для извлечения подстроки из строки. Она принимает три аргумента в следующем порядке:
+ `str` — исходная строка
+ `start` — позиция первого извлекаемого символа
+ `len` — длина извлекаемой подстроки (может не указываться, в таком случае подстрока извлекается до конца)

Функция извлекает из строки `str` подстроку длины `len`, начиная с символа с позицией `start`, и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT SUBSTRING('beegeek', 1),
       SUBSTRING('beegeek', 4),
       SUBSTRING('beegeek', 4, 2);
```

является:

```
+-------------------------+-------------------------+----------------------------+
| SUBSTRING('beegeek', 1) | SUBSTRING('beegeek', 4) | SUBSTRING('beegeek', 4, 2) |
+-------------------------+-------------------------+----------------------------+
| beegeek                 | geek                    | ge                         |
+-------------------------+-------------------------+----------------------------+
```

Обратите внимание, что при использовании функции `SUBSTRING()` символы исходной строки нумеруются с 1, а не с 0.

Позиция первого извлекаемого символа может быть отрицательным числом, в таком случае символы нумеруются с конца. Последнему символу соответствует позиция -1, предпоследнему — -2, и так далее.

Результатом приведенного ниже запроса:

```sql
SELECT SUBSTRING('beegeek', -7),
       SUBSTRING('beegeek', -4),
       SUBSTRING('beegeek', -4, 3);
```
является:

```
+--------------------------+--------------------------+-----------------------------+
| SUBSTRING('beegeek', -7) | SUBSTRING('beegeek', -4) | SUBSTRING('beegeek', -4, 3) |
+--------------------------+--------------------------+-----------------------------+
| beegeek                  | geek                     | gee                         |
+--------------------------+--------------------------+-----------------------------+
```

<hr>

[Содержание](#содержание)

## Функция `SUBSTRING_INDEX()`

Функция `SUBSTRING_INDEX()` используется для извлечения подстроки из строки с помощью разделителя. Она принимает три аргумента в следующем порядке:
+ `str` — исходная строка
+ `delimiter` — разделитель
+ `count` — количество появлений разделителя
Функция возвращает подстроку, входящую в `str`, перед `count` появлением разделителя `delimiter`.

Результатом приведенного ниже запроса:

```sql
SELECT SUBSTRING_INDEX('g-e-e-k', '-', 1),
       SUBSTRING_INDEX('g-e-e-k', '-', 2),
       SUBSTRING_INDEX('g-e-e-k', '-', 3);
```

является:

```
+------------------------------------+------------------------------------+------------------------------------+
| SUBSTRING_INDEX('g-e-e-k', '-', 1) | SUBSTRING_INDEX('g-e-e-k', '-', 2) | SUBSTRING_INDEX('g-e-e-k', '-', 3) |
+------------------------------------+------------------------------------+------------------------------------+
| g                                  | g-e                                | g-e-e                              |
+------------------------------------+------------------------------------+------------------------------------+
```

В примере выше рассматривается строка g-e-e-k с разделителем в виде символа -. Разделитель встречается в строке три раза. Подстрока, входящая в строку перед первым появлением разделителя, равна g, перед вторым появлением — g-e, перед третьим появлением — g-e-e.

Если указанное количество появлений разделителя больше количества раз, которое разделитель встречается в строке, функция SUBSTRING_INDEX() вернет всю строку.

Результатом приведенного ниже запроса:

```sql
SELECT SUBSTRING_INDEX('g-e-e-k', '-', 4),
       SUBSTRING_INDEX('g-e-e-k', '-', 10);
```

является:

```
+------------------------------------+-------------------------------------+
| SUBSTRING_INDEX('g-e-e-k', '-', 4) | SUBSTRING_INDEX('g-e-e-k', '-', 10) |
+------------------------------------+-------------------------------------+
| g-e-e-k                            | g-e-e-k                             |
+------------------------------------+-------------------------------------+
```

Количество появлений разделителя может быть отрицательным числом, в таком случае извлечение подстроки происходит с конца.

Результатом приведенного ниже запроса:

```sql
SELECT SUBSTRING_INDEX('g-e-e-k', '-', -2),
       SUBSTRING_INDEX('g-e-e-k', '-', -3);
```

является:

```
+-------------------------------------+-------------------------------------+
| SUBSTRING_INDEX('g-e-e-k', '-', -2) | SUBSTRING_INDEX('g-e-e-k', '-', -3) |
+-------------------------------------+-------------------------------------+
| e-k                                 | e-e-k                               |
+-------------------------------------+-------------------------------------+
```

Если разделителя в строке нет, функция `SUBSTRING_INDEX()` вернет строку в исходном виде.

Результатом приведенного ниже запроса:

```sql
SELECT SUBSTRING_INDEX('geek', '-', 1),
       SUBSTRING_INDEX('geek', '-', -1);
```

является:

```
+---------------------------------+----------------------------------+
| SUBSTRING_INDEX('geek', '-', 1) | SUBSTRING_INDEX('geek', '-', -1) |
+---------------------------------+----------------------------------+
| geek                            | geek                             |
+---------------------------------+----------------------------------+
```

Функция `SUBSTRING_INDEX()` выполняет поиск разделителя в строке с учетом регистра.

<hr>

[Содержание](#содержание)

## Функция `TRIM()`

Функция `TRIM()` используется для удаления всех вхождений подстроки из начала и/или конца строки. Синтаксис данной функции несколько отличается от предыдущих, так как при ее вызове аргументы не указываются через запятую, а связываются с помощью ключевого слова `FROM`:

```sql
TRIM(<ключевое слово LEADING, TRAILING или BOTH> <удаляемая подстрока> FROM <исходная строка>)
```

Ключевые слова `LEADING`, `TRAILING` и `BOTH` определяют, откуда будет происходить удаление подстроки:
+ `LEADING` — из начала строки
+ `TRAILING`  — из конца строки
+ `BOTH` — из начала и конца строки
Результатом приведенного ниже запроса:

```sql
SELECT TRIM(LEADING '-' FROM '--bee--'),
       TRIM(TRAILING '-' FROM '--bee--'),
       TRIM(BOTH '-' FROM '--bee--');
```

является:

```
+----------------------------------+-----------------------------------+-------------------------------+
| TRIM(LEADING '-' FROM '--bee--') | TRIM(TRAILING '-' FROM '--bee--') | TRIM(BOTH '-' FROM '--bee--') |
+----------------------------------+-----------------------------------+-------------------------------+
| bee--                            | --bee                             | bee                           |
+----------------------------------+-----------------------------------+-------------------------------+
```

Ключевые слова `LEADING`, `TRAILING` и `BOTH` могут не указываться, в таком случае удаление подстроки происходит из начала и конца строки.

Результатом приведенного ниже запроса:

```sql
SELECT TRIM('-' FROM '--bee--');
```

является:

```
+--------------------------+
| TRIM('-' FROM '--bee--') |
+--------------------------+
| bee                      |
+--------------------------+
```

Удаляемая подстрока также может быть опущена, в таком случае ею считается пробел.

Результатом приведенного ниже запроса:

```sql
SELECT TRIM(LEADING FROM '   bee   '),
       TRIM(TRAILING FROM '   bee   '),
       TRIM(BOTH FROM '   bee   ');
```

является:

```
+--------------------------------+---------------------------------+-----------------------------+
| TRIM(LEADING FROM '   bee   ') | TRIM(TRAILING FROM '   bee   ') | TRIM(BOTH FROM '   bee   ') |
+--------------------------------+---------------------------------+-----------------------------+
| bee                            |    bee                          | bee                         |
+--------------------------------+---------------------------------+-----------------------------+
```

Если не указаны и ключевое слово, и удаляемая подстрока, функция `TRIM()` выполнит удаление всех пробелов из начала и конца строки.

Результатом приведенного ниже запроса:

```sql
SELECT TRIM(' bee '),
       TRIM('   bee   ');
```

является:

```
+---------------+-------------------+
| TRIM(' bee ') | TRIM('   bee   ') |
+---------------+-------------------+
| bee           | bee               |
+---------------+-------------------+
```

Обратите внимание, что при таком варианте использования функции ключевое слово FROM указывать не нужно.

<hr>

[Содержание](#содержание)

## Примечания 3

**Примечание 1.** Во время использования функции `TRIM()` нужно хорошо понимать принцип ее работы.

Результатом приведенного ниже запроса:

```sql
SELECT TRIM('+-' FROM '+-+-bee+-+-+-');
```

является:

```
+---------------------------------+
| TRIM('+-' FROM '+-+-bee+-+-+-') |
+---------------------------------+
| bee                             |
+---------------------------------+
```

В данном примере из начала и конца строки +-+-bee+-+-+- удаляются подстроки +-. В начале подстрока встречается два раза — +-+-, в конце подстрока встречается три раза — +-+-+-.

Результатом приведенного ниже запроса:

```sql
SELECT TRIM('+-' FROM '+-+bee+-+');
```

является:

```
+-----------------------------+
| TRIM('+-' FROM '+-+bee+-+') |
+-----------------------------+
| +bee+-+                     |
+-----------------------------+
```

В этом примере подстрока +- удаляется из начала и конца строки +-+bee+-+. В начале подстрока встречается один раз — +-, в конце подстрока не встречается ни разу. 

**Примечание 2.** В SQL реализованы практически все необходимые функции для работы с текстовыми данными, и нами была рассмотрена большая их часть, однако не все. Так, среди пропущенных функций можно выделить функцию `SPACE()`, возвращающую строку из заданного числа пробелов, или функции `ORD()` и `CHAR()`, с помощью которых можно получить числовой код символа в ASCII-таблице и наоборот. При необходимости со списком всех текстовых функций можно ознакомиться по [ссылке](https://docs-python.ru/packages/klient-bd-mysql/funktsii-raboty-strokami-bd-mysql/).

<hr>

[Содержание](#содержание)

# 4.4 Числовые функции. Часть 1

Урок посвящен функциям, предназначенным для обработки числовых данных.

## Операторы `DIV` и `MOD`

Оператор `DIV` используется для целочисленного деления одного числа на другое.

Результатом приведенного ниже запроса:

```sql
SELECT 11 DIV 2,
       11 DIV 3,
       11 DIV 4;
```

является:

```
+----------+----------+----------+
| 11 DIV 2 | 11 DIV 3 | 11 DIV 4 |
+----------+----------+----------+
| 5        | 3        | 2        |
+----------+----------+----------+
```

Оператор `MOD` используется для вычисления остатка от деления одного числа на другое.

Результатом приведенного ниже запроса:

```sql
SELECT 11 MOD 2,
       11 MOD 3,
       11 MOD 4;
```

является:

```
+----------+----------+----------+
| 11 MOD 2 | 11 MOD 3 | 11 MOD 4 |
+----------+----------+----------+
| 1        | 2        | 3        |
+----------+----------+----------+
```

Помимо оператора `MOD`, для вычисления остатка от деления можно использовать оператор `%` или функцию `MOD()`.

Результатом приведенного ниже запроса:

```sql
SELECT 11 MOD 3,
       11 % 3,
       MOD(11, 3);
```

является:

```
+----------+--------+------------+
| 11 MOD 3 | 11 % 3 | MOD(11, 3) |
+----------+--------+------------+
| 2        | 2      | 2          |
+----------+--------+------------+
```

Подробнее с операциями целочисленного деления и деления с остатком можно ознакомиться по [ссылке](https://ru.wikipedia.org/wiki/Деление_с_остатком).

<hr>

[Содержание](#содержание)

## Функция `ABS()`

Функция `ABS()` используется для вычисления модуля числа. Она принимает в качестве аргумента число и возвращает его модуль.

Результатом приведенного ниже запроса:

```sql
SELECT ABS(-1),
       ABS(-2.1234),
       ABS(0),
       ABS(35);
```

является:

```
+---------+--------------+--------+---------+
| ABS(-1) | ABS(-2.1234) | ABS(0) | ABS(35) |
+---------+--------------+--------+---------+
| 1       | 2.1234       | 0      | 35      |
+---------+--------------+--------+---------+
```

<hr>

[Содержание](#содержание)

## Функция `ROUND()`

Функция `ROUND()` используется для округления числа. Она принимает два аргумента в следующем порядке:
+ `num` — число
+ `decimals` — количество знаков после запятой

Функция возвращает число `num`, округленное до `decimals` знаков после запятой.

Результатом приведенного ниже запроса:

```sql
SELECT ROUND(23.1653, 3),
       ROUND(23.1653, 2),
       ROUND(23.1653, 1),
       ROUND(23.1653, 0);
```

является:

```
+-------------------+-------------------+-------------------+-------------------+
| ROUND(23.1653, 3) | ROUND(23.1653, 2) | ROUND(23.1653, 1) | ROUND(23.1653, 0) |
+-------------------+-------------------+-------------------+-------------------+
| 23.165            | 23.17             | 23.2              | 23                |
+-------------------+-------------------+-------------------+-------------------+
```

Обратите внимание, что функция `ROUND()` округляет число согласно математическим правилам округления, то есть в большую по модулю сторону.

Результатом приведенного ниже запроса:

```sql
SELECT ROUND(23.165, 2),
       ROUND(-23.165, 2);
```

является:

```
+------------------+-------------------+
| ROUND(23.165, 2) | ROUND(-23.165, 2) |
+------------------+-------------------+
| 23.17            | -23.17            |
+------------------+-------------------+
```

Количество знаков после запятой может быть не указано, в таком случае функция `ROUND()` выполнит округление до целого числа.

Результатом приведенного ниже запроса:

```sql
SELECT ROUND(23.3),
       ROUND(23.5),
       ROUND(23.7),
       ROUND(-23.3),
       ROUND(-23.5),
       ROUND(-23.7);
```

является:

```
+-------------+-------------+-------------+--------------+--------------+--------------+
| ROUND(23.3) | ROUND(23.5) | ROUND(23.7) | ROUND(-23.3) | ROUND(-23.5) | ROUND(-23.7) |
+-------------+-------------+-------------+--------------+--------------+--------------+
| 23          | 24          | 24          | -23          | -24          | -24          |
+-------------+-------------+-------------+--------------+--------------+--------------+
```

<hr>

[Содержание](#содержание)

## Функция `POW()`

Функция `POW()` используется для возведения числа в определенную степень. Она принимает два аргумента в следующем порядке:
+ `num` — число
+ `degree` — показатель степени

Функция возвращает число `num`, возведенное в степень `degree`.

Результатом приведенного ниже запроса:

```sql
SELECT POW(2, 3),
       POW(3, 5),
       POW(4, 0),
       POW(5, -1);
```

является:

```
+-----------+-----------+-----------+------------+
| POW(2, 3) | POW(3, 5) | POW(4, 0) | POW(5, -1) |
+-----------+-----------+-----------+------------+
| 8.0       | 243.0     | 1.0       | 0.2        |
+-----------+-----------+-----------+------------+
```

<hr>

[Содержание](#содержание)

## Функция `SQRT()`

Функция `SQRT()` используется для вычисления квадратного корня. Она принимает в качестве аргумента число, извлекает из него квадратный корень и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT SQRT(0),
       SQRT(9),
       SQRT(20);
```

является:

```
+---------+---------+------------------+
| SQRT(0) | SQRT(9) | SQRT(20)         |
+---------+---------+------------------+
| 0.0     | 3.0     | 4.47213595499958 |
+---------+---------+------------------+
```

Если переданное в качестве аргумента число меньше нуля, функция `SQRT()` вернет значение `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT SQRT(-1),
       SQRT(-100);
```

является:

```
+----------+------------+
| SQRT(-1) | SQRT(-100) |
+----------+------------+
| NULL     | NULL       |
+----------+------------+
```

<hr>

[Содержание](#содержание)

## Функция `RAND()`

Функция `RAND()` используется для генерации случайных чисел. При вызове без аргументов она возвращает случайное число с плавающей точкой в диапазоне $[0, 1)$.

Результатом приведенного ниже запроса:

```sql
SELECT RAND(),
       RAND(),
       RAND();
```

может являться:

```
+-------------------+--------------------+---------------------+
| RAND()            | RAND()             | RAND()              |
+-------------------+--------------------+---------------------+
| 0.338787759038422 | 0.8266121575856694 | 0.11669754154672617 |
+-------------------+--------------------+---------------------+
```

Функция может принимать один необязательный аргумент — целое число, определяющее начальное значение при генерации случайного числа. С одним и тем же аргументом функция будет возвращать одно и то же случайное число.

Результатом приведенного ниже запроса:

```sql
SELECT RAND(2),
       RAND(2),
       RAND(3),
       RAND(3);
```

является:

```
+--------------------+--------------------+--------------------+--------------------+
| RAND(2)            | RAND(2)            | RAND(3)            | RAND(3)            |
+--------------------+--------------------+--------------------+--------------------+
| 0.6555866465490187 | 0.6555866465490187 | 0.9057697559760601 | 0.9057697559760601 |
+--------------------+--------------------+--------------------+--------------------+
```

<hr>

[Содержание](#содержание)

## Примечания 4

**Примечание 1.** Помимо функции `ROUND()`, SQL поддерживает две дополнительные функции для округления чисел: `FLOOR()` и `CEILING()`. Первая функция используется для округления числа в меньшую сторону, вторая — в большую сторону.

Результатом приведенного ниже запроса:

```sql
SELECT FLOOR(123.87),
       FLOOR(-11.22),
       CEILING(18.39),
       CEILING(-11.22);
```

является:

```
+---------------+---------------+----------------+-----------------+
| FLOOR(123.87) | FLOOR(-11.22) | CEILING(18.39) | CEILING(-11.22) |
+---------------+---------------+----------------+-----------------+
| 123           | -12           | 19             | -11             |
+---------------+---------------+----------------+-----------------+
```

**Примечание 2.** Функция `RAND()` в комбинации с операторами `ORDER BY` и `LIMIT` позволяет извлекать из таблицы определенное количество случайных записей.

Предположим, мы работаем с таблицей SQLTeam, которая имеет следующий вид:

```
+----+---------+
| id | name    |
+----+---------+
| 1  | Timur   |
| 2  | Arthur  |
| 3  | Valera  |
| 4  | Rustam  |
+----+---------+
```

При необходимости извлечь из этой таблицы, скажем, две случайные записи мы можем сначала отсортировать их с помощью функции `RAND()`, а затем ограничить полученный результат двумя записями.

Результатом приведенного ниже запроса:

```sql
SELECT *
FROM SQLTeam
ORDER BY RAND()
LIMIT 2;
```

является (может отличаться):

```
+----+---------+
| id | name    |
+----+---------+
| 1  | Timur   |
| 4  | Rustam  |
+----+---------+
```

Извлечение происходит случайным образом потому, что во время сортировки для каждой записи функция `RAND()` вызывается отдельно. Таким образом, сначала каждой записи сопоставляется определенное случайное число, а затем записи сортируются на основе этих случайных чисел.

<hr>

[Содержание](#содержание)

# 4.5 Числовые функции. Часть 2

Урок посвящен функциям, предназначенным для обработки числовых данных.

## Функции `DEGREES()` и `RADIANS()`

Функция `DEGREES()` используется для перевода значения из радиан в градусы. Она принимает в качестве аргумента значение в радианах, конвертирует его в градусы и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT DEGREES(1),
       DEGREES(3.14),
       DEGREES(6.28);
```

является:

```
+-------------------+-------------------+------------------+
| DEGREES(1)        | DEGREES(3.14)     | DEGREES(6.28)    |
+-------------------+-------------------+------------------+
| 57.29577951308232 | 179.9087476710785 | 359.817495342157 |
+-------------------+-------------------+------------------+
```

Похожим образом себя ведет функция `RADIANS()` за тем исключением, что она выполняет обратный перевод — из градусов в радианы.

Результатом приведенного ниже запроса:

```sql
SELECT RADIANS(57),
       RADIANS(180),
       RADIANS(360);
```

является:

```
+--------------------+-------------------+-------------------+
| RADIANS(57)        | RADIANS(180)      | RADIANS(360)      |
+--------------------+-------------------+-------------------+
| 0.9948376736367679 | 3.141592653589793 | 6.283185307179586 |
+--------------------+-------------------+-------------------+
```

Подробнее с радианной системой измерения можно ознакомиться по [ссылке](https://ru.wikipedia.org/wiki/Радиан).

<hr>

[Содержание](#содержание)

## Функции `PI()`, `SIN()`, `COS()` и `TAN()`

Функция `PI()` используется для получения числа пи (𝜋). Она не принимает никаких аргументов и возвращает число пи с точностью до шести знаков после запятой.

Результатом приведенного ниже запроса:

```sql
SELECT PI();
```

является:

```
+----------+
| PI()     |
+----------+
| 3.141593 |
+----------+
```

Функции `SIN()`, `COS()` и `TAN()` используются для вычисления синуса, косинуса и тангенса соответственно. Каждая функция принимает в качестве аргумента значение в радианах и возвращает соответствующую тригонометрическую величину.

Результатом приведенного ниже запроса:

```sql
SELECT SIN(PI()),
       COS(PI()),
       TAN(PI());
```

является:

```
+-----------+-----------+-----------+
| SIN(PI()) | COS(PI()) | TAN(PI()) |
+-----------+-----------+-----------+
| 0         | -1        | 0         |
+-----------+-----------+-----------+
```

<hr>

[Содержание](#содержание)

## Функции `LEAST()` и `GREATEST()`

Функция `LEAST()` используется для поиска минимального значения. Она принимает переменное количество аргументов (не меньше двух) и возвращает наименьший из них.

Результатом приведенного ниже запроса:

```sql
SELECT LEAST(2, 1, 3, 5, 4);
```

является:

```
+----------------------+
| LEAST(2, 1, 3, 5, 4) |
+----------------------+
| 1                    |
+----------------------+
```

Если поиск минимального значения происходит среди действительных (типы `FLOAT` и `DOUBLE`) и целых чисел, функция `LEAST()` сначала преобразует все числа в действительные.

Результатом приведенного ниже запроса:

```sql
SELECT LEAST(2, 1, 3.0, 5, 4);
```

является:

```
+------------------------+
| LEAST(2, 1, 3.0, 5, 4) |
+------------------------+
| 1.0                    |
+------------------------+
```

Если хотя бы один из аргументов, переданных в функцию `LEAST()`, является строкой, функция перед поиском минимального значения сначала преобразует все аргументы в строки.

Результатом приведенного ниже запроса:

```sql
SELECT LEAST(100, '11');
```

является:

```
+------------------+
| LEAST(100, '11') |
+------------------+
| 100              |
+------------------+
```

Если хотя бы один из аргументов, переданных в функцию `LEAST()`, равняется `NULL`, возвращаемым значением функции также будет `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT LEAST(2, 1, NULL, 5, 4);
```

является:

```
+-------------------------+
| LEAST(2, 1, NULL, 5, 4) |
+-------------------------+
| NULL                    |
+-------------------------+
```

Похожим образом себя ведет функция `GREATEST()` за тем исключением, что она выполняет поиск наибольшего значения, а не наименьшего.

Результатом приведенного ниже запроса:

```sql
SELECT GREATEST(2, 1, 3, 5, 4);
```

является:

```
+-------------------------+
| GREATEST(2, 1, 3, 5, 4) |
+-------------------------+
| 5                       |
+-------------------------+
```

<hr>

[Содержание](#содержание)

## Функция `CONV()`

Функция `CONV()` используется для перевода числа из одной системы счисления в другую. Она принимает три аргумента в следующем порядке:
+ `num` — число
+ `from_base` — система счисления, в которой представлено число
+ `to_base` — система счисления, в которую нужно перевести число

Функция переводит число num из системы счисления `from_base` в систему счисления `to_base` и возвращает полученный результат в виде строки.

Результатом приведенного ниже запроса:

```sql
SELECT CONV(5, 10, 2),
       CONV(101, 2, 10),
       CONV(100, 10, 16),
       CONV('F', 16, 10),
       CONV('10F', 16, 2);
```

является:

```
+----------------+------------------+-------------------+-------------------+--------------------+
| CONV(5, 10, 2) | CONV(101, 2, 10) | CONV(100, 10, 16) | CONV('F', 16, 10) | CONV('10F', 16, 2) |
+----------------+------------------+-------------------+-------------------+--------------------+
| 101            | 5                | 64                | 15                | 100001111          |
+----------------+------------------+-------------------+-------------------+--------------------+
```

<hr>

[Содержание](#содержание)

## Функция `FORMAT()`
Функция `FORMAT()` используется для округления и форматирования числа. Она принимает два аргумента в следующем порядке:
+ num — число
+ decimals — количество знаков после запятой

Функция округляет число `num` до `decimals` знаков после запятой, форматирует его путем разбиения на разряды и возвращает полученный результат в виде строки.

Результатом приведенного ниже запроса:

```sql
SELECT FORMAT(1000000.1653, 3),
       FORMAT(1000000.1653, 2),
       FORMAT(1000000.1653, 1),
       FORMAT(1000000.1653, 0);
```

является:

```
+-------------------------+-------------------------+-------------------------+-------------------------+
| FORMAT(1000000.1653, 3) | FORMAT(1000000.1653, 2) | FORMAT(1000000.1653, 1) | FORMAT(1000000.1653, 0) |
+-------------------------+-------------------------+-------------------------+-------------------------+
| 1,000,000.165           | 1,000,000.17            | 1,000,000.2             | 1,000,000               |
+-------------------------+-------------------------+-------------------------+-------------------------+
```

Обратите внимание, что функция `FORMAT()` округляет число согласно математическим правилам округления, то есть в большую по модулю сторону.

Если указанное количество знаков после запятой больше фактического количества знаков у числа, функция `FORMAT()` заполнит недостающие знаки незначащими нулями.

Результатом приведенного ниже запроса:

```sql
SELECT FORMAT(1000000.1653, 5),
       FORMAT(1000000.1653, 7);
```

является:

```
+-------------------------+-------------------------+
| FORMAT(1000000.1653, 5) | FORMAT(1000000.1653, 7) |
+-------------------------+-------------------------+
| 1,000,000.16530         | 1,000,000.1653000       |
+-------------------------+-------------------------+
```

<hr>

[Содержание](#содержание)

## Примечания 5

**Примечание 1.** В SQL реализованы практически все необходимые математические функции для работы с числовыми данными, и нами была рассмотрена большая их часть, однако не все. Так, среди пропущенных функций можно выделить функцию `COT()`, возвращающую значение котангенса, или функцию `LOG2()` с помощью которой можно получить значение двоичного логарифма. При необходимости со списком всех математических функций можно ознакомиться по [ссылке](https://docs-python.ru/packages/klient-bd-mysql/matematicheskie-funktsii-bd-mysql/).

<hr>

[Содержание](#содержание)

# 4.6 Функции даты и времени. Часть 1

Урок посвящен функциям, предназначенным для обработки даты и времени.

## Временные интервалы

В SQL для работы с датой и временем часто используются временные интервалы. Они представляют собой некоторый промежуток времени, выраженный в тех или иных единицах измерения (день, год, минута), и используются для выполнения арифметических операций с датой и временем.

Для записи временных интервалов применяется следующий синтаксис:

```sql
INTERVAL <величина интервала> <единица измерения>
```

Единица измерения во временном интервале определяется ключевым словом. Например, день — это DAY, год — это YEAR, год и месяц — это YEAR_MONTH. Формат величины интервала напрямую зависит от единицы измерения. Для одиночных единиц измерения, таких как день или год, форматом величины является целое число. 

К примеру, интервал в 1 год определяется следующим образом:

```sql
INTERVAL 1 YEAR
```

Для составных единиц измерения, таких как год и месяц, форматом величины является строка определенного вида, в которой перечислены все необходимые значения компонентов.

К примеру, интервал в 10 лет и 2 месяца определяется следующим образом:

```sql
INTERVAL '10-2' YEAR_MONTH
```

### Поддерживаемые единицы измерения

SQL поддерживает большое количество единиц измерения. Для удобства мы разбили их на две таблицы, в одной из которых представлены одиночные единицы измерения, в другой — составные.

Итак, первая таблица включает все поддерживаемые одиночные единицы измерения:


Единица измерения | Ключевое слово
-|-
микросекунда | MICROSECOND
секунда | SECOND
минута | MINUTE
час | HOUR
день | DAY
неделя | WEEK
месяц | MONTH
квартал | QUARTER
год | YEAR

Вторая таблица включает все поддерживаемые составные единицы измерения, а также формат величины для каждой из единиц:

Единица измерения | Ключевое слово | Формат величины
-|-|-
секунда и микросекунда | SECOND_MICROSECOND | секунды.микросекунды
минута, секунда и микросекунда | MINUTE_MICROSECOND | минуты:секунды.микросекунды
минута и секунда | MINUTE_SECOND | минуты:секунды
час, минута, секунда и микросекунда | HOUR_MICROSECOND | часы:минуты:секунды.микросекунды
час, минута и секунда | HOUR_SECOND | часы:минуты:секунды
час и минута | HOUR_MINUTE | часы:минуты
день, час, минута, секунда и микросекунда | DAY_MICROSECOND | дни часы:минуты:секунды.микросекунды
день, час, минута и секунда | DAY_SECOND | дни часы:минуты:секунды
день, час и минута | DAY_MINUTE | дни часы:минуты
день и час | DAY_HOUR | дни часы
год и месяц | YEAR_MONTH | годы-месяцы

### Примеры использования временных интервалов

Для большей наглядности рассмотрим несколько примеров использования временных интервалов.

**Пример 1.** Прибавим к дате 2023-01-01 интервал в 10 лет и 2 месяца.

Результатом приведенного ниже запроса:

```sql
SELECT '2023-01-01' + INTERVAL '10-2' YEAR_MONTH;
```

является:

```
+-------------------------------------------+
| '2023-01-01' + INTERVAL '10-2' YEAR_MONTH |
+-------------------------------------------+
| 2033-03-01                                |
+-------------------------------------------+
```

**Пример 2.** Вычтем из даты и времени 2023-01-01 14:00:00 интервал в 1 час и 30 минут.

Результатом приведенного ниже запроса:

```sql
SELECT '2023-01-01 14:00:00' - INTERVAL '01:30' HOUR_MINUTE;
```

является:

```
+------------------------------------------------------+
| '2023-01-01 14:00:00' - INTERVAL '01:30' HOUR_MINUTE |
+------------------------------------------------------+
| 2023-01-01 12:30:00                                  |
+------------------------------------------------------+
```

**Пример 3.** Прибавим к дате и времени 2023-01-01 14:00:00 интервал в 4 дня и 2 часа.

Результатом приведенного ниже запроса:

```sql
SELECT '2023-01-01 14:00:00' + INTERVAL '4 2' DAY_HOUR;
```

является:

```
+-------------------------------------------------+
| '2023-01-01 14:00:00' + INTERVAL '4 2' DAY_HOUR |
+-------------------------------------------------+
| 2023-01-05 16:00:00                             |
+-------------------------------------------------+
```

**Пример 4.** Вычтем из даты 2023-01-01 интервал в 1 час.

Результатом приведенного ниже запроса:

```sql
SELECT '2023-01-01' - INTERVAL 1 HOUR;
```

является:

```
+--------------------------------+
| '2023-01-01' - INTERVAL 1 HOUR |
+--------------------------------+
| 2022-12-31 23:00:00            |
+--------------------------------+
```

Обратите внимание, что из даты без времени допускается вычитать временное значение. Во время выполнения такой операции считается, что дата имеет нулевые значения по всем компонентам времени — 0 часов, 0 минут и 0 секунд. Аналогичное справедливо и при прибавлении временного значения к дате без времени.

<hr>

[Содержание](#содержание)

## Функции `NOW()`, `CURDATE()` и `CURTIME()`

Функция `NOW()` используется для получения текущей даты и времени. Она не принимает никаких аргументов и возвращает текущую дату и время в локальном часовом поясе, например, в том, который используется в операционной системе.

Результатом приведенного ниже запроса:

```sql
SELECT NOW();
```

может являться:

```
+---------------------+
| NOW()               |
+---------------------+
| 2023-06-27 10:14:48 |
+---------------------+
```

Похожим образом себя ведут функции `CURDATE()` и `CURTIME()` за тем исключением, что они возвращают текущую дату и текущее время соответственно.

Результатом приведенного ниже запроса:

```sql
SELECT CURTIME(),
       CURDATE();
```

может являться:

```
+-----------+------------+
| CURTIME() | CURDATE()  |
+-----------+------------+
| 10:23:15  | 2023-06-27 |
+-----------+------------+
```

<hr>

[Содержание](#содержание)

## Функции `UTC_TIMESTAMP()`, `UTC_DATE()` и `UTC_TIME()`

Функция `UTC_TIMESTAMP()` используется для получения текущей даты и времени. Она не принимает никаких аргументов и возвращает текущую дату и время в UTC, то есть в нулевом часовом поясе.

Результатом приведенного ниже запроса:

```sql
SELECT UTC_TIMESTAMP();
```

может являться:

```
+---------------------+
| UTC_TIMESTAMP()     |
+---------------------+
| 2023-06-28 05:44:53 |
+---------------------+
```

Похожим образом себя ведут функции `UTC_DATE()` и `UTC_TIME()` за тем исключением, что они возвращают текущую дату и текущее время соответственно.

Результатом приведенного ниже запроса:

```sql
SELECT UTC_DATE(),
       UTC_TIME();
```

может являться:

```
+------------+------------+
| UTC_DATE() | UTC_TIME() |
+------------+------------+
| 2023-10-17 | 13:57:34   |
+------------+------------+
```

Во время работы с датой и временем рекомендуется использовать именно функции `UTC_TIMESTAMP()`, `UTC_DATE()` и `UTC_TIME()`, а приведение к определенному часовому поясу при необходимости выполнять вручную.

<hr>

[Содержание](#содержание)

## Функция `MAKEDATE()`

Функция `MAKEDATE()` используется для создания даты. Она принимает два аргумента в следующем порядке:
+ `year` — год
+ `day` — номер дня в году

Функция возвращает дату, которая имеет порядковый номер `day` в году `year`.

Результатом приведенного ниже запроса:

```sql
SELECT MAKEDATE(2023, 1),
       MAKEDATE(2023, 255),
       MAKEDATE(2023, 365);
```

является:

```
+-------------------+---------------------+---------------------+
| MAKEDATE(2023, 1) | MAKEDATE(2023, 255) | MAKEDATE(2023, 365) |
+-------------------+---------------------+---------------------+
| 2023-01-01        | 2023-09-12          | 2023-12-31          |
+-------------------+---------------------+---------------------+
```

Если указанный номер дня в году больше количества дней в этом году, функция `MAKEDATE()` преобразует каждые 365-366 дней в полный год.

Результатом приведенного ниже запроса:

```sql
SELECT MAKEDATE(2023, 366),
       MAKEDATE(2023, 732);
```

является:

```
+---------------------+---------------------+
| MAKEDATE(2023, 366) | MAKEDATE(2023, 732) |
+---------------------+---------------------+
| 2024-01-01          | 2025-01-01          |
+---------------------+---------------------+
```

<hr>

[Содержание](#содержание)

## Функция `MAKETIME()`

Функция `MAKETIME()` используется для создания временного значения. Она принимает три аргумента в следующем порядке:
+ `hours` — часы
+ `minutes` — минуты
+ `seconds` — секунды

Функция возвращает временное значение, состоящее из `hours` часов, `minutes` минут и `seconds` секунд.

Результатом приведенного ниже запроса:

```sql
SELECT MAKETIME(12, 33, 1),
       MAKETIME(0, 1, 2),
       MAKETIME(21, 11, 42);
```

является:

```
+---------------------+-------------------+----------------------+
| MAKETIME(12, 33, 1) | MAKETIME(0, 1, 2) | MAKETIME(21, 11, 42) |
+---------------------+-------------------+----------------------+
| 12:33:01            | 00:01:02          | 21:11:42             |
+---------------------+-------------------+----------------------+
```

Функция `MAKETIME()` может обрабатывать значение часов больше, чем есть в сутках, но не может обрабатывать значение минут и секунд больше 59. Если количество минут или секунд больше 59, функция вернет значение `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT MAKETIME(222, 50, 11),
       MAKETIME(10, 60, 12),
       MAKETIME(5, 33, 79);
```

является:

```
+-----------------------+----------------------+---------------------+
| MAKETIME(222, 50, 11) | MAKETIME(10, 60, 12) | MAKETIME(5, 33, 79) |
+-----------------------+----------------------+---------------------+
| 222:50:11             | NULL                 | NULL                |
+-----------------------+----------------------+---------------------+
```

<hr>

[Содержание](#содержание)

## Примечания 6

**Примечание 1.** Если хотя бы один из аргументов, переданных в функции `MAKEDATE()` и `MAKETIME()`, являeтся значением `NULL`, функции вернут значение `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT MAKETIME(NULL, 1, 1),
       MAKETIME(1, NULL, 1),
       MAKETIME(1, 1, NULL),
       MAKEDATE(2023, NULL),
       MAKEDATE(NULL, 9);
```

является:

```
+----------------------+----------------------+----------------------+----------------------+-------------------+
| MAKETIME(NULL, 1, 1) | MAKETIME(1, NULL, 1) | MAKETIME(1, 1, NULL) | MAKEDATE(2023, NULL) | MAKEDATE(NULL, 9) |
+----------------------+----------------------+----------------------+----------------------+-------------------+
| NULL                 | NULL                 | NULL                 | NULL                 | NULL              |
+----------------------+----------------------+----------------------+----------------------+-------------------+
```

<hr>

[Содержание](#содержание)

## Функция `TIME_TO_SEC()` и `SEC_TO_TIME()`

Функция `TIME_TO_SEC()` используется для преобразования временного значения в секунды. Она принимает в качестве аргумента временное значение, преобразует его в количество секунд и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT TIME_TO_SEC('00:00:25'),
       TIME_TO_SEC('00:01:30'),
       TIME_TO_SEC('01:00:00');
```

является:

```
+-------------------------+-------------------------+-------------------------+
| TIME_TO_SEC('00:00:25') | TIME_TO_SEC('00:01:30') | TIME_TO_SEC('01:00:00') |
+-------------------------+-------------------------+-------------------------+
| 25                      | 90                      | 3600                    |
+-------------------------+-------------------------+-------------------------+
```

Похожим образом себя ведет функция `SEC_TO_TIME()` за тем исключением, что она выполняет обратное преобразование — количество секунд во временное значение.

Результатом приведенного ниже запроса:

```sql
SELECT SEC_TO_TIME(25),
       SEC_TO_TIME(90),
       SEC_TO_TIME(3600);
```

является:

```
+-----------------+-----------------+-------------------+
| SEC_TO_TIME(25) | SEC_TO_TIME(90) | SEC_TO_TIME(3600) |
+-----------------+-----------------+-------------------+
| 00:00:25        | 00:01:30        | 01:00:00          |
+-----------------+-----------------+-------------------+
```

<hr>

[Содержание](#содержание)

## Функции `TO_DAYS()` и `TO_SECONDS()`

Функция `TO_DAYS()` используется для преобразования даты в количество дней. Она принимает в качестве аргумента дату, преобразует ее в количество дней и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT TO_DAYS('2023-04-01'),
       TO_DAYS('0001-01-01'),
       TO_DAYS('0000-01-01');
```

является:

```
+-----------------------+-----------------------+-----------------------+
| TO_DAYS('2023-04-01') | TO_DAYS('0001-01-01') | TO_DAYS('0000-01-01') |
+-----------------------+-----------------------+-----------------------+
| 738976                | 366                   | 1                     |
+-----------------------+-----------------------+-----------------------+
```

Обратите внимание, что отсчет количества дней начинается с нулевого года.

Похожим образом себя ведет функция `TO_SECONDS()`, за тем исключением, что она преобразует дату в количество секунд, а не дней.

Результатом приведенного ниже запроса:

```sql
SELECT TO_SECONDS('2023-04-01'),
       TO_SECONDS('0001-01-01'),
       TO_SECONDS('0000-01-01');
```

является:

```
+--------------------------+--------------------------+--------------------------+
| TO_SECONDS('2023-04-01') | TO_SECONDS('0001-01-01') | TO_SECONDS('0000-01-01') |
+--------------------------+--------------------------+--------------------------+
| 63847526400              | 31622400                 | 86400                    |
+--------------------------+--------------------------+--------------------------+
```

<hr>

[Содержание](#содержание)

## Функция `LAST_DAY()`

Функция `LAST_DAY()` используется для замены дня на последний день месяца. Она принимает в качестве аргумента дату, заменяет в ней день на последний день месяца этой даты и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT LAST_DAY('2023-02-14'),
       LAST_DAY('2023-03-14'),
       LAST_DAY('2023-04-14');
```

является:

```
+------------------------+------------------------+------------------------+
| LAST_DAY('2023-02-14') | LAST_DAY('2023-03-14') | LAST_DAY('2023-04-14') |
+------------------------+------------------------+------------------------+
| 2023-02-28             | 2023-03-31             | 2023-04-30             |
+------------------------+------------------------+------------------------+
```

## Примечания 6.2

**Примечание 1.** Функции `TIME_TO_SEC()`, `SEC_TO_TIME()`, `TO_DAYS()`, `TO_SECONDS()` и `LAST_DAY()` при вызове с аргументом `NULL` возвращают значение `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT TIME_TO_SEC(NULL),
       SEC_TO_TIME(NULL),
       TO_DAYS(NULL),
       TO_SECONDS(NULL),
       LAST_DAY(NULL);
```

является:

```
+-------------------+-------------------+---------------+------------------+----------------+
| TIME_TO_SEC(NULL) | SEC_TO_TIME(NULL) | TO_DAYS(NULL) | TO_SECONDS(NULL) | LAST_DAY(NULL) |
+-------------------+-------------------+---------------+------------------+----------------+
| NULL              | NULL              | NULL          | NULL             | NULL           |
+-------------------+-------------------+---------------+------------------+----------------+
```

<hr>

[Содержание](#содержание)

# 4.7 Функции даты и времени. Часть 2

Урок посвящен функциям, предназначенным для обработки даты и времени.

## Функции `DATE()` и `TIME()`

Функция `DATE()` используется для получения даты из даты и времени. Она принимает в качестве аргумента дату и время, извлекает из него дату и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT DATE('2023-10-20 12:30:00'),
       DATE('2023-12-31 10:00:20');
```

является:

```
+-----------------------------+-----------------------------+
| DATE('2023-10-20 12:30:00') | DATE('2023-12-31 10:00:20') |
+-----------------------------+-----------------------------+
| 2023-10-20                  | 2023-12-31                  |
+-----------------------------+-----------------------------+
```

Если аргументом функции `DATE()` является дата без времени, функция вернет ее в исходном виде.

Результатом приведенного ниже запроса:

```sql
SELECT DATE('2023-10-20');
```

является:

```
+--------------------+
| DATE('2023-10-20') |
+--------------------+
| 2023-10-20         |
+--------------------+
```

Похожим образом себя ведет функция `TIME()` за тем исключением, что она извлекает временное значение, а не дату.

Результатом приведенного ниже запроса:

```sql
SELECT TIME('2023-10-20 12:30:00'),
       TIME('2023-12-31 10:00:20'),
       TIME('12:30:00');
```

является:

```
+-----------------------------+-----------------------------+------------------+
| TIME('2023-10-20 12:30:00') | TIME('2023-12-31 10:00:20') | TIME('12:30:00') |
+-----------------------------+-----------------------------+------------------+
| 12:30:00                    | 10:00:20                    | 12:30:00         |
+-----------------------------+-----------------------------+------------------+
```

<hr>

[Содержание](#содержание)

## Функции `HOUR()`, `MINUTE()`, `SECOND()` и `MICROSECOND()`

Функция `HOUR()` используется для определения количества часов во времени. Она принимает в качестве аргумента временное значение, извлекает из него часы и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT HOUR('12:30:10'),
       HOUR('18:20:00');
```

является:

```
+------------------+------------------+
| HOUR('12:30:10') | HOUR('18:20:00') |
+------------------+------------------+
| 12               | 18               |
+------------------+------------------+
```

Похожим образом себя ведут функции `MINUTE()`, `SECOND()` и `MICROSECOND()` за тем исключением, что они извлекают минуты, секунды и микросекунды соответственно.

Результатом приведенного ниже запроса:

```sql
SELECT MINUTE('12:30:10.1415'),
       SECOND('12:30:10.1415'),
       MICROSECOND('12:30:10.1415');
```

является:

```
+-------------------------+-------------------------+------------------------------+
| MINUTE('12:30:10.1415') | SECOND('12:30:10.1415') | MICROSECOND('12:30:10.1415') |
+-------------------------+-------------------------+------------------------------+
| 30                      | 10                      | 141500                       |
+-------------------------+-------------------------+------------------------------+
```

<hr>

[Содержание](#содержание)

## Функции `YEAR()`, `MONTH()` и `DAY()`

Функция `YEAR()` используется для извлечения значения года из даты. Она принимает в качестве аргумента дату, извлекает из нее год и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT YEAR('2023-10-20'),
       YEAR('2027-12-31');
```

является:

```
+--------------------+--------------------+
| YEAR('2023-10-20') | YEAR('2027-12-31') |
+--------------------+--------------------+
| 2023               | 2027               |
+--------------------+--------------------+
```

Похожим образом себя ведут функции `MONTH()` и `DAY()` за тем исключением, что они извлекают месяц и день соответственно.

Результатом приведенного ниже запроса:

```sql
SELECT MONTH('2023-10-20'),
       DAY('2023-10-20');
```

является:

```
+---------------------+-------------------+
| MONTH('2023-10-20') | DAY('2023-10-20') |
+---------------------+-------------------+
| 10                  | 20                |
+---------------------+-------------------+
```

<hr>

[Содержание](#содержание)

## Функция `DAYOFYEAR()`

Функция `DAYOFYEAR()` используется для вычисления номера дня в году (от 1 до 366) на основе даты. Она принимает в качестве аргумента дату, определяет, какой по счету день в году соответствует переданной дате, и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT DAYOFYEAR('2023-01-01'),
       DAYOFYEAR('2023-02-01'),
       DAYOFYEAR('2023-12-31');
```

является:

```
+-------------------------+-------------------------+-------------------------+
| DAYOFYEAR('2023-01-01') | DAYOFYEAR('2023-02-01') | DAYOFYEAR('2023-12-31') |
+-------------------------+-------------------------+-------------------------+
| 1                       | 32                      | 365                     |
+-------------------------+-------------------------+-------------------------+
```

<hr>

[Содержание](#содержание)

## Функция `WEEK()`
Функция `WEEK()` используется для вычисления номера недели в году на основе даты. Она принимает в качестве аргумента дату, определяет, какая по счету неделя в году соответствует переданной дате, и возвращает полученный результат.

Результатом приведенного ниже запроса:

```sql
SELECT WEEK('2023-01-01'),
       WEEK('2023-01-08'),
       WEEK('2023-12-31');
```

является:

```
+--------------------+--------------------+--------------------+
| WEEK('2023-01-01') | WEEK('2023-01-08') | WEEK('2023-12-31') |
+--------------------+--------------------+--------------------+
| 1                  | 2                  | 53                 |
+--------------------+--------------------+--------------------+
```

Функция `WEEK()` имеет несколько режимов работы, например, она может считать неделю от понедельника или воскресенья. Подробнее с возможностями данной функции можно ознакомиться по [ссылке](https://docs-python.ru/packages/klient-bd-mysql/funktsii-bd-mysql-raboty-datoi-vremenem/#WEEK).

<hr>

[Содержание](#содержание)

## Функция `WEEKDAY()`

Функция `WEEKDAY()` используется для вычисления номера дня недели (от 0 до 6) на основе даты. Она принимает в качестве аргумента дату, определяет день недели, который соответствует переданной дате, и возвращает его номер.

Результатом приведенного ниже запроса:

```sql
SELECT WEEKDAY('2023-10-16'),      -- понедельник
       WEEKDAY('2023-10-17'),      -- вторник
       WEEKDAY('2023-10-18'),      -- среда
       WEEKDAY('2023-10-23');      -- понедельник
```

является:

```
+-----------------------+-----------------------+-----------------------+-----------------------+
| WEEKDAY('2023-10-16') | WEEKDAY('2023-10-17') | WEEKDAY('2023-10-18') | WEEKDAY('2023-10-23') |
+-----------------------+-----------------------+-----------------------+-----------------------+
| 0                     | 1                     | 2                     | 0                     |
+-----------------------+-----------------------+-----------------------+-----------------------+
```

<hr>

[Содержание](#содержание)

## Функция `QUARTER()`

Функция `QUARTER()` используется для вычисления номера квартала (от 1 до 4) на основе даты. Она принимает в качестве аргумента дату, определяет квартал, в котором находится переданная дата, и возвращает его номер.

Результатом приведенного ниже запроса:

```sql
SELECT QUARTER('2023-01-01'),      -- январь
       QUARTER('2023-04-01'),      -- апрель
       QUARTER('2023-07-01'),      -- июль
       QUARTER('2023-10-01');      -- октябрь
```

является:

```
+-----------------------+-----------------------+-----------------------+-----------------------+
| QUARTER('2023-01-01') | QUARTER('2023-04-01') | QUARTER('2023-07-01') | QUARTER('2023-10-01') |
+-----------------------+-----------------------+-----------------------+-----------------------+
| 1                     | 2                     | 3                     | 4                     |
+-----------------------+-----------------------+-----------------------+-----------------------+
```

Квартал — четвертая часть года. 1 квартал включает январь, февраль, март, 2 — апрель, май, июнь, 3 — июль, август, сентябрь, 4 — октябрь, ноябрь, декабрь.

<hr>

[Содержание](#содержание)

## Функция `DAYNAME()`
Функция `DAYNAME()` используется для вычисления названия дня недели на основе даты. Она принимает в качестве аргумента дату, определяет день недели, который соответствует переданной дате, и возвращает его полное название.

Результатом приведенного ниже запроса:

```sql
SELECT DAYNAME('2023-10-16'),      -- понедельник
       DAYNAME('2023-10-17'),      -- вторник
       DAYNAME('2023-10-18');      -- среда
```

является:

```
+-----------------------+-----------------------+-----------------------+
| DAYNAME('2023-10-16') | DAYNAME('2023-10-17') | DAYNAME('2023-10-18') |
+-----------------------+-----------------------+-----------------------+
| Monday                | Tuesday               | Wednesday             |
+-----------------------+-----------------------+-----------------------+
```

<hr>

[Содержание](#содержание)

## Функция `MONTHNAME()`

Функция `MONTHNAME()` используется для определения названия месяца на основе даты. Она принимает в качестве аргумента дату и возвращает полное название ее месяца.

Результатом приведенного ниже запроса:

```sql
SELECT MONTHNAME('2023-01-01'),    -- январь
       MONTHNAME('2023-04-01'),    -- апрель
       MONTHNAME('2023-07-01');    -- июль
```

является:

```
+-------------------------+-------------------------+-------------------------+
| MONTHNAME('2023-01-01') | MONTHNAME('2023-04-01') | MONTHNAME('2023-07-01') |
+-------------------------+-------------------------+-------------------------+
| January                 | April                   | July                    |
+-------------------------+-------------------------+-------------------------+
```

<hr>

[Содержание](#содержание)

## Примечания 7

**Примечание 1.** Функции, предназначенные в большей степени для работы только с датой или только с временем, могут использоваться для работы с датой и временем.

Результатом приведенного ниже запроса:

```sql
SELECT HOUR('2023-10-20 12:30:00'),
       YEAR('2023-10-20 12:30:00'),
       DAYNAME('2023-10-20 12:30:00');
```

является:

```
+-----------------------------+-----------------------------+--------------------------------+
| HOUR('2023-10-20 12:30:00') | YEAR('2023-10-20 12:30:00') | DAYNAME('2023-10-20 12:30:00') |
+-----------------------------+-----------------------------+--------------------------------+
| 12                          | 2023                        | Friday                         |
+-----------------------------+-----------------------------+--------------------------------+
```

**Примечание 2.** В MySQL временные значения ограничены диапазоном [-838:59:59; 838:59:59].

Результатом приведенного ниже запроса:

```sql
SELECT TIME('400:00:00'),
       TIME('900:00:00'),
       TIME('-400:00:00'),
       TIME('-900:00:00');
```

является:

```
+-------------------+-------------------+--------------------+--------------------+
| TIME('400:00:00') | TIME('900:00:00') | TIME('-400:00:00') | TIME('-900:00:00') |
+-------------------+-------------------+--------------------+--------------------+
| 400:00:00         | 838:59:59         | -400:00:00         | -838:59:59         |
+-------------------+-------------------+--------------------+--------------------+
```

С причинами использования именно такого диапазона можно ознакомиться по [ссылке](https://habr.com/ru/companies/flant/articles/526712/).

**Примечание 3.** В MySQL имеется специальная переменная `lc_time_names`, которая управляет локализацией. Она определяет, как будут отображаться названия дней недели и месяцев при использовании таких функций, как `DAYNAME()` и `MONTHNAME()`.

Переменная `lc_time_names` может принимать различные значения в зависимости от того, какая локализация необходима: например, `'ru_RU'` — русская, `'en_US'` — английская. Изменение ее значения выполняется с помощью следующей конструкции:

```sql
SET lc_time_names = <языковая локаль>;
```

Результатом приведенного ниже запроса:

```sql
SET lc_time_names = 'ru_RU';

SELECT DAYNAME('2023-10-20'),
       MONTHNAME('2023-10-20');
```

в Windows 11 является:

```
+-----------------------+-------------------------+
| DAYNAME('2023-10-20') | MONTHNAME('2023-10-20') |
+-----------------------+-------------------------+
| Пятница               | Октября                 |
+-----------------------+-------------------------+
```

С полным списком поддерживаемых языковых локалей можно ознакомиться по [ссылке](https://dev.mysql.com/doc/refman/8.0/en/locale-support.html).

**Примечание 4.** Если любой из функций, которые были рассмотрены в этом уроке, вместо даты, времени или даты и времени передать значение `NULL`, функции также вернут значение `NULL`.

<hr>

[Содержание](#содержание)

# 4.8 Функции даты и времени. Часть 3

<hr>

[Содержание](#содержание)

# 4.9 Функции даты и времени. Часть 4

<hr>

[Содержание](#содержание)

# 4.10 Дополнительные функции

<hr>

[Содержание](#содержание)

# 4.11 Условные конструкции

<hr>

[Содержание](#содержание)


<hr>

[Содержание](#содержание)