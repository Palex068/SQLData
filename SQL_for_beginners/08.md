# 8. Обновление, удаление и добавление данных

## Содержание

+ [8.1 Обновление данных](#81-обновление-данных)
    + [Обновление всех записей](#обновление-всех-записей)
    + [Обновление отдельных записей](#обновление-отдельных-записей)
    + [Обновление с вычисляемым значением](#обновление-с-вычисляемым-значением)
    + [Обновление с условной конструкцией](#обновление-с-условной-конструкцией)
    + [Обновление на основе данных из других таблиц](#обновление-на-основе-данных-из-других-таблиц)
    + [Ограничение обновляемых записей](#ограничение-обновляемых-записей)
    + [Обновление с сортировкой](#обновление-с-сортировкой)
+ [8.2 Удаление данных](#82-удаление-данных)
    + [Удаление данных](#удаление-данных)
        + [Удаление всех записей](#удаление-всех-записей)
        + [Удаление отдельных записей](#удаление-отдельных-записей)
        + [Сортировка и ограничение удаляемых записей](#сортировка-и-ограничение-удаляемых-записей)
    + [Удаление зависимых данных](#удаление-зависимых-данных)
+ [8.3 Добавление данных](#83-добавление-данных)
    + [Добавление одной записи](#добавление-одной-записи)
    + [Добавление нескольких записей](#добавление-нескольких-записей)
    + [Добавление вычисляемых значений](#добавление-вычисляемых-значений)
    + [Добавление с помощью ключевого слова `SET`](#добавление-с-помощью-ключевого-слова-set)
    + [Добавление данных из других таблиц](#добавление-данных-из-других-таблиц)

[Оглавление](/SQL_for_beginners/README.MD)

# 8.1 Обновление данных

Урок посвящен различным способам обновления табличных данных.

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из двух таблиц и содержит информацию о книгах, размещенных в некотором интернет-магазине.

Первая таблица. Информация об авторах книг располагается в таблице `Authors`, которая имеет следующий вид:

```
+----+-----------------+
| id | author          |
+----+-----------------+
| 1  | Stephen King    |
| 2  | Chuck Palahniuk |
| 3  | Jerome Salinger |
+----+-----------------+
```

Первое поле этой таблицы содержит идентификатор автора, второе — имя и фамилию.

Вторая таблица. Информация о размещенных в магазине книгах располагается в таблице `Books`, которая имеет следующий вид:

```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 7.99  | 1      |
| 2  | Fight Club             | 2         | 9.99  | 19     |
| 3  | The Catcher in the Rye | 3         | 3.49  | 11     |
| 4  | The Green Mile         | 1         | 15.99 | 6      |
| 5  | Haunted                | 2         | 13.99 | 1      |
+----+------------------------+-----------+-------+--------+
```

Первое поле этой таблицы содержит идентификатор книги, второе — название, третье — идентификатор автора, четвертое — цену в долларах, пятое — доступное для покупки количество.

Схема базы данных

![08](/SQL_for_beginners/img/08_01.svg)

Скрипт для создания таблиц `Authors` и `Books`

```sql
-- Создание таблицы Authors
DROP TABLE IF EXISTS Authors;
CREATE TABLE Authors
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    author    VARCHAR(40)
);

INSERT INTO Authors (author)
VALUES ('Stephen King'),
       ('Chuck Palahniuk'),
       ('Jerome Salinger');

-- Создание таблицы Books
DROP TABLE IF EXISTS Books;
CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author_id INT,
    price     DECIMAL(10, 2),
    amount    INT DEFAULT 0
);

INSERT INTO Books (title, author_id, price, amount)
VALUES ('The Shining', 1, 7.99, 1),
       ('Fight Club', 2, 9.99, 19),
       ('The Catcher in the Rye', 3, 3.49, 11),
       ('The Green Mile', 1, 15.99, 6),
       ('Haunted', 2, 13.99, 1);
```

<hr>

[Содержание](#содержание)

## Обновление данных

Наиболее часто используемым оператором при формировании запросов является `SELECT`, именно поэтому мы посвятили его изучению наибольшую часть курса. Однако помимо оператора `SELECT`, существуют еще три немаловажных оператора, которые предназначены для манипуляции содержащимися в таблицах данными:
+ обновление,
+ удаление и
+ добавление. 

В этом уроке мы познакомимся с оператором  `UPDATE`, целью которого является обновление табличных данных.

<hr>

[Содержание](#содержание)

### Обновление всех записей

Наиболее простой операцией обновления является изменение значения одного поля всех записей таблицы. В качестве примера такой операции напишем запрос, который устанавливает всем книгам одинаковую цену в 9.99 долларов.

После выполнения приведенного ниже запроса:

```sql
UPDATE Books
SET price = 9.99;
```

таблица Books будет иметь вид:

```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 9.99  | 1      |
| 2  | Fight Club             | 2         | 9.99  | 19     |
| 3  | The Catcher in the Rye | 3         | 9.99  | 11     |
| 4  | The Green Mile         | 1         | 9.99  | 6      |
| 5  | Haunted                | 2         | 9.99  | 1      |
+----+------------------------+-----------+-------+--------+
```

Теперь рассмотрим запрос выше несколько подробнее. Он начинается с оператора `UPDATE`, после которого указывается название таблицы, подлежащей обновлению. В нашем случае это таблица `Books`. Затем используется ключевое слово `SET`, с помощью которого для поля определяется новое значение. В данном случае выполняется изменение значения поля `price` на значение 9.99.

В рамках одной операции обновления можно изменять значение не только одного поля, но и нескольких. Для этого после ключевого слова `SET` нужно перечислить через запятую все изменяемые поля и их новые значения. Например, дополнив запрос выше, мы можем изменить не только цену всех книг, но и их количество, скажем, на значение 50.

После выполнения приведенного ниже запроса:

```sql
UPDATE Books
SET price = 9.99,
    amount = 50;
```

таблица Books будет иметь вид:

```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 9.99  | 50     |
| 2  | Fight Club             | 2         | 9.99  | 50     |
| 3  | The Catcher in the Rye | 3         | 9.99  | 50     |
| 4  | The Green Mile         | 1         | 9.99  | 50     |
| 5  | Haunted                | 2         | 9.99  | 50     |
+----+------------------------+-----------+-------+--------+
```

Если значение поля в какой-либо записи совпадает с обновляемым значением, оно не будет обновлено. Например, значение поля `price` в записи с идентификатором 2 уже имеет значение 9.99, поэтому при выполнении запроса будет обновлено не пять, а четыре записи.

<hr>

[Содержание](#содержание)

### Обновление отдельных записей

Изменение всех записей таблицы требуется довольно редко, гораздо чаще необходимо обновить значения нескольких определенных записей или одной конкретной записи. Выполняется это с помощью того же оператора `WHERE`, который указывается после ключевого слова `SET` и определяет условия отбора записей, подлежащих обновлению.

В качестве примера использования оператора `WHERE` напишем запрос, который устанавливает всем книгам, доступным в единственном экземпляре, цену в 1.99 долларов.

После выполнения приведенного ниже запроса:

```sql
UPDATE Books
SET price = 1.99
WHERE amount = 1;
```

таблица Books будет иметь вид:

```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 1.99  | 1      |
| 2  | Fight Club             | 2         | 9.99  | 19     |
| 3  | The Catcher in the Rye | 3         | 3.49  | 11     |
| 4  | The Green Mile         | 1         | 15.99 | 6      |
| 5  | Haunted                | 2         | 1.99  | 1      |
+----+------------------------+-----------+-------+--------+
```

Как видно из обновленной таблицы `Books`, значение поля `price` изменили лишь те записи, значение поля amount которых равняется 1, поскольку именно это условие было использовано при обновлении.

<hr>

[Содержание](#содержание)

### Обновление с вычисляемым значением

В качестве нового значения поля допускается использовать не только константные значения, но и разного рода выражения. Примером использования подобных выражений может служить запрос, который устанавливает всем книгам скидку в 10%.

После выполнения приведенного ниже запроса:

```sql
UPDATE Books
SET price = price * 0.9;
```

таблица Books будет иметь вид:

```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 7.19  | 1      |
| 2  | Fight Club             | 2         | 8.99  | 19     |
| 3  | The Catcher in the Rye | 3         | 3.14  | 11     |
| 4  | The Green Mile         | 1         | 14.39 | 6      |
| 5  | Haunted                | 2         | 12.59 | 1      |
+----+------------------------+-----------+-------+--------+
```

В данном запросе всем записям таблицы в качестве значения поля `price` устанавливается текущее значение поля `price`, умноженное на 0.9, что соответствует 10 процентной скидке.

Выражения могут быть произвольной сложности и включать в себя как простые арифметические операции, так и вызовы различных функций. Например, мы можем дополнить выражение, используемое в запросе выше, функцией `ROUND()`, чтобы обнулить у полученных после умножения на 0.9 значений поля `price` дробную часть.

После выполнения приведенного ниже запроса:

```sql
UPDATE Books
SET price = ROUND(price * 0.9);
```

таблица Books будет иметь вид:

```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 7.00  | 1      |
| 2  | Fight Club             | 2         | 9.00  | 19     |
| 3  | The Catcher in the Rye | 3         | 3.00  | 11     |
| 4  | The Green Mile         | 1         | 14.00 | 6      |
| 5  | Haunted                | 2         | 13.00 | 1      |
+----+------------------------+-----------+-------+--------+
```

<hr>

[Содержание](#содержание)

### Обновление с условной конструкцией

При обновлении таблицы можно пользоваться условными конструкциями. Они могут быть полезны в том случае, когда определенному значению нужно поставить в соответствие другое определенное значение.

В качестве примера использования условной конструкции напишем запрос, который устанавливает каждой книге цену, зависящую от ее доступного для покупки количества.

После выполнения приведенного ниже запроса:

```sql
UPDATE Books
SET price = CASE
                WHEN amount < 5 THEN price * 0.9
                WHEN amount BETWEEN 5 AND 10 THEN price * 0.7
                ELSE price * 0.5
            END;
```

таблица `Books` будет иметь вид:

```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 7.19  | 1      |
| 2  | Fight Club             | 2         | 5.00  | 19     |
| 3  | The Catcher in the Rye | 3         | 1.75  | 11     |
| 4  | The Green Mile         | 1         | 11.19 | 6      |
| 5  | Haunted                | 2         | 12.59 | 1      |
+----+------------------------+-----------+-------+--------+
```

Данный запрос изменяет значение поля `price` каждой записи в зависимости от значения поля amount. К примеру, если запись в качестве значения поля amount содержит число меньше 5, то значением поля `price` такой записи будет текущее значение поля `price`, умноженное на 0.9.

<hr>

[Содержание](#содержание)

### Обновление на основе данных из других таблиц

При обновлении данных одной таблицы допустимо пользоваться данными из других таблиц. Предположим, мы хотим установить всем книгам, принадлежащим автору `Stephen King`, скидку в 50%. Для решения такой задачи можно в блоке `WHERE` обратиться к таблице `Authors` посредством подзапроса с целью определения идентификатора необходимого нам автора.

После выполнения приведенного ниже запроса:

```sql
UPDATE Books
SET price = price * 0.5
WHERE author_id = (SELECT id
                   FROM Authors
                   WHERE author = 'Stephen King');
```

таблица `Books` будет иметь вид:

```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 4.00  | 1      |
| 2  | Fight Club             | 2         | 9.99  | 19     |
| 3  | The Catcher in the Rye | 3         | 3.49  | 11     |
| 4  | The Green Mile         | 1         | 8.00  | 6      |
| 5  | Haunted                | 2         | 13.99 | 1      |
+----+------------------------+-----------+-------+--------+
```

Также предложенная задача может быть решена с помощью соединения таблиц `Books` и `Authors`. Суть использования соединения при обновлении записей таблицы заключается в наделении каждой обновляемой записи дополнительной информацией, которая затем может использоваться для вычисления нового значения записи или для определения того, нужно обновлять запись или нет. В нашем случае соединение позволяет указать имя и фамилию автора каждой книги, чтобы затем пользоваться этой информацией при отборе обновляемых записей.

После выполнения приведенного ниже запроса:

```sql
UPDATE Books INNER JOIN Authors ON Books.author_id = Authors.id
SET Books.price = Books.price * 0.5
WHERE Authors.author = 'Stephen King';
```

таблица `Books` будет иметь вид:

```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 4.00  | 1      |
| 2  | Fight Club             | 2         | 9.99  | 19     |
| 3  | The Catcher in the Rye | 3         | 3.49  | 11     |
| 4  | The Green Mile         | 1         | 8.00  | 6      |
| 5  | Haunted                | 2         | 13.99 | 1      |
+----+------------------------+-----------+-------+--------+
```

В примере выше выполняется соединение таблиц `Books` и `Authors` с условием `Books.author_id = Authors.id`, результатом которого является следующая таблица:

```
+----+------------------------+-----------+-------+--------+----+-----------------+
| id | title                  | author_id | price | amount | id | author          |
+----+------------------------+-----------+-------+--------+----+-----------------+
| 1  | The Shining            | 1         | 7.99  | 1      | 1  | Stephen King    |
| 2  | Fight Club             | 2         | 9.99  | 19     | 2  | Chuck Palahniuk |
| 3  | The Catcher in the Rye | 3         | 3.49  | 11     | 3  | Jerome Salinger |
| 4  | The Green Mile         | 1         | 15.99 | 6      | 1  | Stephen King    |
| 5  | Haunted                | 2         | 13.99 | 1      | 2  | Chuck Palahniuk |
+----+------------------------+-----------+-------+--------+----+-----------------+
```

Затем выполняется изменение значения поля `price` записей таблицы `Books`, однако для определения того, должна быть изменена запись или нет, используется значение поля `author` из результата соединения таблиц `Books` и `Authors`: если значением поля `author` является строка `Stephen King`, запись изменяется, в противном случае запись игнорируется.

<hr>

[Содержание](#содержание)

### Ограничение обновляемых записей

Ключевое слово `LIMIT`, используемое для ограничения количества извлекаемых записей, также может использоваться для ограничения количества обновляемых записей. В качестве примера использования данного ключевого слова напишем запрос, который увеличивает цену первой книги в таблице `Books` на 2 доллара.

После выполнения приведенного ниже запроса:

```sql
UPDATE Books
SET price = price + 2
LIMIT 1;
```

таблица `Books` будет иметь вид:

```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 9.99  | 1      |
| 2  | Fight Club             | 2         | 9.99  | 19     |
| 3  | The Catcher in the Rye | 3         | 3.49  | 11     |
| 4  | The Green Mile         | 1         | 15.99 | 6      |
| 5  | Haunted                | 2         | 13.99 | 1      |
+----+------------------------+-----------+-------+--------+
```

При обновлении данных ключевое слово `OFFSET`  совместно с ключевым словом `LIMIT` использовать нельзя.

<hr>

[Содержание](#содержание)

### Обновление с сортировкой

Оператор `ORDER BY` может использоваться совместно с оператором `UPDATE` для определения порядка, в котором будут обновляться записи. На первый взгляд может показаться, что нам неважно, какие записи будут обновлены первыми, а какие последними, однако в некоторых ситуациях важно определить очередность их изменения.

Например, необходимость определения порядка обновления записей может возникнуть в случае изменения значений поля, являющегося первичным ключом. Известно, что значения первичного ключа должны быть уникальными, однако при их обновлении некоторые значения могут совпасть, что приведет к ошибке.

Результатом приведенного ниже запроса:

```sql
UPDATE Books
SET id = id + 1;
```

является ошибка:

```
ERROR 1062: Duplicate entry '2' for key 'Books.PRIMARY'
```

В запросе выше мы пытаемся сдвинуть идентификаторы всех книг на одно значение вперед, однако в результате получаем ошибку. Так происходит по той причине, что обновление записей выполняется последовательно, начиная с первой. Поэтому после увеличения идентификатора первой книги на единицу, он становится равным 2, результатом чего является то, что в таблице `Books` находятся две записи (первая и вторая), имеющие в качестве значения первичного ключа число 2.

Чтобы избежать подобного поведения, можно воспользоваться оператором `ORDER BY` и выполнять обновление записей, начиная с последней.

После выполнения приведенного ниже запроса:

```sql
UPDATE Books
SET id = id + 1
ORDER BY id DESC;
```

таблица `Books` будет иметь вид:

```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 2  | The Shining            | 1         | 7.99  | 1      |
| 3  | Fight Club             | 2         | 9.99  | 19     |
| 4  | The Catcher in the Rye | 3         | 3.49  | 11     |
| 5  | The Green Mile         | 1         | 15.99 | 6      |
| 6  | Haunted                | 2         | 13.99 | 1      |
+----+------------------------+-----------+-------+--------+
```

В данном запросе значения поля `id` обновляются в обратном порядке: сперва последняя запись изменяет значение с 5 на 6, затем предпоследняя — с 4 на 5, и так далее. В результате никакие два значения первичного ключа при обновлении не совпадают и запрос выполняется успешно.

<hr>

[Содержание](#содержание)

## Примечания 1

**Примечание 1.** Оператор `UPDATE` поддерживает дополнительное ключевое слово `IGNORE`, которое позволяет не прерывать процесс обновления данных даже при возникновении ошибок. Например, если при обновлении выполняется изменение первичного ключа, которое приводит к появлению дубликатов, такая операция просто игнорируется.

После выполнения приведенного ниже запроса:

```sql
UPDATE IGNORE Books
SET id = id + 1;
```

таблица `Books` будет иметь вид:

```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 7.99  | 1      |
| 2  | Fight Club             | 2         | 9.99  | 19     |
| 3  | The Catcher in the Rye | 3         | 3.49  | 11     |
| 4  | The Green Mile         | 1         | 15.99 | 6      |
| 6  | Haunted                | 2         | 13.99 | 1      |
+----+------------------------+-----------+-------+--------+
```

В примере выше первые четыре попытки изменения значение поля `id` были проигнорированы.

**Примечание 2.** Результатом запроса, обновляющего данные таблицы, не является таблица. Поэтому, если после обновления данных необходимо тут же их получить, можно использовать дополнительный извлекающий запрос.

Результатом приведенного ниже запроса:

```sql
UPDATE Books
SET price = 9.99,
    amount = 50;

SELECT *
FROM Books;
```

является:

```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 9.99  | 50     |
| 2  | Fight Club             | 2         | 9.99  | 50     |
| 3  | The Catcher in the Rye | 3         | 9.99  | 50     |
| 4  | The Green Mile         | 1         | 9.99  | 50     |
| 5  | Haunted                | 2         | 9.99  | 50     |
+----+------------------------+-----------+-------+--------+
```

Обратите внимание, что обновляющий запрос отделяется от извлекающего запроса точкой с запятой (`;`).

**Примечание 3.** Каждое поле таблицы может обладать рядом свойств, которые определяются при создании таблицы. Одним из таких свойств является запрет на хранение значения `NULL`. Если поле обладает данным свойством и не может содержать значение `NULL`, то при попытке добавить в него `NULL` путем изменения любого из имеющихся в поле значений произойдет ошибка.

Например, поле `id` таблицы `Authors` является первичным ключом, которое может содержать исключительно уникальные целочисленные значения, поэтому если мы попытаемся изменить хотя бы одно значение в этом поле на `NULL`, то получим ошибку.

Результатом приведенного ниже запроса:

```sql
UPDATE Authors
SET id = NULL
LIMIT 1;
```

является ошибка:

```
ERROR 1048: Column 'id' cannot be null
```

Однако если после оператора `UPDATE` указать ключевое слово `IGNORE`, то при попытке изменения значения поля, не поддерживающего `NULL`, на `NULL`, значение поля будет изменено на значение по умолчанию в зависимости от типа поля. Например, для числового поля таким значением по умолчанию является `0`, для строкового `''`, для даты — `0000-00-00`.

Результатом приведенного ниже запроса:

```sql
UPDATE IGNORE Authors
SET id = NULL
LIMIT 1;

SELECT *
FROM Authors;
```

является:

```
+----+-----------------+
| id | author          |
+----+-----------------+
| 0  | Stephen King    |
| 2  | Chuck Palahniuk |
| 3  | Jerome Salinger |
+----+-----------------+
```

**Примечание 4.** Каждое поле таблицы может иметь значение по умолчанию, которое определяется при создании таблицы. Если поле имеет значение по умолчанию, то при изменении значений этого поля им можно воспользоваться с помощью ключевого слова `DEFAULT`.

Например, поле `amount` таблицы `Books` имеет значение по умолчанию, равное `0`. Если во время изменения значений этого поля мы укажем не что-то конкретное, а ключевое слово `DEFAULT`, то будет использовано значение `0`.

Результатом приведенного ниже запроса:

```sql
UPDATE Books
SET amount = DEFAULT;

SELECT *
FROM Books;
```

является:

```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 7.99  | 0      |
| 2  | Fight Club             | 2         | 9.99  | 0      |
| 3  | The Catcher in the Rye | 3         | 3.49  | 0      |
| 4  | The Green Mile         | 1         | 15.99 | 0      |
| 5  | Haunted                | 2         | 13.99 | 0      |
+----+------------------------+-----------+-------+--------+
```

**Примечание 5.** При обновлении данных таблицы на основе данных из других таблиц с помощью соединения нельзя использовать сортировку и оператор `LIMIT`.

Результатом приведенного ниже запроса:

```sql
UPDATE Books INNER JOIN Authors ON Books.author_id = Authors.id
SET Books.price = Books.price * 0.5
WHERE Authors.author = 'Stephen King'
ORDER BY Books.id;
```

является ошибка:

```
ERROR 1221: Incorrect usage of UPDATE and ORDER BY
```

Результатом приведенного ниже запроса:

```sql
UPDATE Books INNER JOIN Authors ON Books.author_id = Authors.id
SET Books.price = Books.price * 0.5
WHERE Authors.author = 'Stephen King'
LIMIT 1;
```

является ошибка:

```
ERROR 1221: Incorrect usage of UPDATE and LIMIT
```

**Примечание 6.** При обновлении данных таблицы на основе данных из других таблиц с помощью подзапроса в подзапросе нельзя обращаться к обновляемой таблице.

Результатом приведенного ниже запроса:

```sql
UPDATE Books
SET price = price * 0.5
WHERE price = (SELECT MIN(price)
               FROM Books);
```

является ошибка:

```
ERROR 1093: You can't specify target table 'Books' for update in FROM clause
```

<hr>

[Содержание](#содержание)

# 8.2 Удаление данных

Урок посвящен различным способам удаления табличных данных.

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из двух таблиц и содержит информацию о книгах, размещенных в некоторой электронной библиотеке.

Первая таблица. Информация об авторах книг располагается в таблице `Authors`, которая имеет следующий вид:

```
+----+-----------------+
| id | author          |
+----+-----------------+
| 1  | Stephen King    |
| 2  | Chuck Palahniuk |
| 3  | Jerome Salinger |
+----+-----------------+
```

Первое поле этой таблицы содержит идентификатор автора, второе — имя и фамилию.

Вторая таблица. Информация о размещенных в библиотеке книгах располагается в таблице `Books`, которая имеет следующий вид:

```
+----+------------------------+-----------+
| id | title                  | author_id |
+----+------------------------+-----------+
| 1  | The Shining            | 1         |
| 2  | Fight Club             | 2         |
| 3  | The Catcher in the Rye | 3         |
| 4  | The Green Mile         | 1         |
| 5  | Haunted                | 2         |
+----+------------------------+-----------+
```

Первое поле этой таблицы содержит идентификатор книги, второе — название, третье — идентификатор автора.

Схема базы данных

![08](/SQL_for_beginners/img/08_02.svg)

Скрипт для создания таблиц `Authors` и `Books`

```sql
-- Создание таблицы Authors
DROP TABLE IF EXISTS Authors;
CREATE TABLE Authors
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    author    VARCHAR(40)
);

INSERT INTO Authors (author)
VALUES ('Stephen King'),
       ('Chuck Palahniuk'),
       ('Jerome Salinger');

-- Создание таблицы Books
DROP TABLE IF EXISTS Books;
CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author_id INT,
    FOREIGN KEY (author_id) REFERENCES Authors(id)
);

INSERT INTO Books (title, author_id)
VALUES ('The Shining', 1),
       ('Fight Club', 2),
       ('The Catcher in the Rye', 3),
       ('The Green Mile', 1),
       ('Haunted', 2);
```

<hr>

[Содержание](#содержание)

## Удаление данных

Для удаления данных из таблицы предназначен оператор `DELETE`. Его можно использовать двумя способами:
+ для удаления определенных записей
+ для удаления всех записей

<hr>

[Содержание](#содержание)

### Удаление всех записей

Наиболее простой операцией удаления является удаление абсолютно всех записей таблицы. В качестве примера такой операции рассмотрим запрос, который полностью очищает таблицу `Books`.

После выполнения приведенного ниже запроса:

```sql
DELETE FROM Books;
```

таблица `Books` не будет содержать ни одной записи.

Как видно из примера выше, при написании удаляющего запроса необходимо указать оператор `DELETE`, а затем ключевое слово `FROM` и название таблицы, из которой должны быть удалены данные.

Оператор `DELETE` не требует указания названий полей, потому что он всегда удаляет записи целиком.

<hr>

[Содержание](#содержание)

### Удаление отдельных записей

Удаление всех записей таблицы требуется крайне редко, и в большинстве случаев оператор `DELETE` используется совместно с оператором `WHERE` для определения условий отбора записей, подлежащих удалению.

В качестве примера использования оператора `WHERE` напишем запрос, который удаляет данные о книге под названием `Fight Club`.

После выполнения приведенного ниже запроса:

```sql
DELETE FROM Books
WHERE title = 'Fight Club';
```

таблица `Books` будет иметь вид:

```
+----+------------------------+-----------+
| id | title                  | author_id |
+----+------------------------+-----------+
| 1  | The Shining            | 1         |
| 3  | The Catcher in the Rye | 3         |
| 4  | The Green Mile         | 1         |
| 5  | Haunted                | 2         |
+----+------------------------+-----------+
```

При удалении данных из одной таблицы допустимо пользоваться данными из других таблиц. Например, мы можем написать запрос, который удаляет данные о всех книгах за авторством `Chuck Palahniuk`.

После выполнения приведенного ниже запроса:

```sql
DELETE FROM Books
WHERE author_id = (SELECT id
                   FROM Authors
                   WHERE author = 'Chuck Palahniuk');
```

таблица `Books` будет иметь вид:

```
+----+------------------------+-----------+
| id | title                  | author_id |
+----+------------------------+-----------+
| 1  | The Shining            | 1         |
| 3  | The Catcher in the Rye | 3         |
| 4  | The Green Mile         | 1         |
+----+------------------------+-----------+
```

В примере выше для удаления книг определенного автора используется подзапрос, однако аналогичное удаление может быть выполнено и с помощью соединения. Как и в случае с обновлением записей, соединение при удалении позволяет наделить записи дополнительной информацией и удобно их отфильтровать. Для того чтобы воспользоваться соединением, необходимо после названия таблицы, записи которой требуют удаления, указать ключевое слово `USING`, а затем предоставить выражение, выполняющее соединение.

После выполнения приведенного ниже запроса:

```sql
DELETE FROM Books
USING Books INNER JOIN Authors ON Books.author_id = Authors.id
WHERE Authors.author = 'Chuck Palahniuk';
```

таблица Books будет иметь вид:

```
+----+------------------------+-----------+
| id | title                  | author_id |
+----+------------------------+-----------+
| 1  | The Shining            | 1         |
| 3  | The Catcher in the Rye | 3         |
| 4  | The Green Mile         | 1         |
+----+------------------------+-----------+
```

Данный запрос функционально повторяет предыдущий запрос и также удаляет данные о всех книгах за авторством `Chuck Palahniuk`. Однако при определении того, нужно удалить запись или нет, запрос использует не исходные записи, а их дополненные вспомогательной информацией эквиваленты из соединения таблиц `Books` и `Authors`:

```
+----+------------------------+-----------+----+-----------------+
| id | title                  | author_id | id | author          |
+----+------------------------+-----------+----+-----------------+
| 1  | The Shining            | 1         | 1  | Stephen King    |
| 4  | The Green Mile         | 1         | 1  | Stephen King    |
| 2  | Fight Club             | 2         | 2  | Chuck Palahniuk |
| 5  | Haunted                | 2         | 2  | Chuck Palahniuk |
| 3  | The Catcher in the Rye | 3         | 3  | Jerome Salinger |
+----+------------------------+-----------+----+-----------------+
```

Если запись в качестве значения поля `author` имеет строку `Chuck Palahniuk`, она удаляется, в противном случае игнорируется.

<hr>

[Содержание](#содержание)

### Сортировка и ограничение удаляемых записей

При удалении данных допустимо использование операторов `ORDER BY` и `LIMIT` для определения порядка удаления записей и ограничения количества удаляемых записей соответственно. К примеру, сочетание этих операторов позволяет написать запрос, который удаляет данные о самой последней книге.

После выполнения приведенного ниже запроса:

```sql
DELETE FROM Books
ORDER BY id DESC
LIMIT 1;
```

таблица Books будет иметь вид:

```
+----+------------------------+-----------+
| id | title                  | author_id |
+----+------------------------+-----------+
| 1  | The Shining            | 1         |
| 2  | Fight Club             | 2         |
| 3  | The Catcher in the Rye | 3         |
| 4  | The Green Mile         | 1         |
+----+------------------------+-----------+
```

Данный запрос сортирует записи в порядке убывания значений поля `id` и ограничивает количество удаляемых записей одной записью, что в результате приводит к удалению последней записи таблицы.

Оператор `DELETE` удаляет из таблицы отдельные записи или даже все записи за один раз, но он никогда не удаляет саму таблицу.

<hr>

[Содержание](#содержание)

## Удаление зависимых данных

Практически всегда база данных состоит из большого количества таблиц, которые определенным образом связаны между собой с помощью внешних ключей. Поэтому закономерно может произойти ситуация, при которой выполняется попытка удаления записи, от значений которой зависят другие записи.

Вернемся к рассмотрению нашей базы данных. В таблице `Books` хранятся данные о книгах. Для каждой книги определен собственный автор, однако подробные данные об этих авторах находятся не в таблице `Books`, а в таблице `Authors`. Сама же таблица `Books` лишь ссылается на эти данные посредством внешнего ключа — поля `author_id`.

Теперь предположим, что мы хотим удалить информацию о каком-либо авторе из таблицы `Authors`. Если книги этого автора содержатся в таблице `Books`, то такое удаление может привести к нарушению целостности данных, так как в таблице `Books` будет существовать книга с неизвестным автором.

К счастью, при использовании внешних ключей СУБД запрещает удаление записей, которые обеспечивают корректность отношений между таблицами, и при попытке выполнить подобное удаление сообщает об ошибке.

Результатом приведенного ниже запроса:

```sql
DELETE FROM Authors
WHERE author = 'Jerome Salinger';
```

является ошибка:

```
ERROR 1451: Cannot delete or update a parent row: a foreign key constraint fails 
```

Запрос выше пытается удалить из таблицы `Authors` запись с данными об авторе `Jerome Salinger`, однако операция завершается с ошибкой, поскольку в таблице `Books` содержится запись, которая ссылается на удаляемые данные.

Для того чтобы корректно удалить данные, от которых могут зависеть другие данные, сперва необходимо избавиться от всех потенциальных зависимостей или убедиться, что таких зависимостей нет. В нашем случае для удаления информации об авторе `Jerome Salinger` сначала нужно удалить информацию обо всех принадлежащих ему книгах.

После выполнения приведенного ниже запроса:

```sql
DELETE FROM Books
WHERE author_id = (SELECT id
                   FROM Authors
                   WHERE author = 'Jerome Salinger');

DELETE FROM Authors
WHERE author = 'Jerome Salinger';
```

таблица `Books` будет иметь вид:

```
+----+----------------+-----------+
| id | title          | author_id |
+----+----------------+-----------+
| 1  | The Shining    | 1         |
| 2  | Fight Club     | 2         |
| 4  | The Green Mile | 1         |
| 5  | Haunted        | 2         |
+----+----------------+-----------+
```

таблица `Authors` будет иметь вид:

```
+----+-----------------+
| id | author          |
+----+-----------------+
| 1  | Stephen King    |
| 2  | Chuck Palahniuk |
+----+-----------------+
```

Здесь сперва выполняется обращение к таблице `Books`, из которой удаляются все данные о книгах, автором которых является `Jerome Salinger`, а затем происходит обращение к таблице `Authors`, из которой уже удаляются данные о самом авторе.

СУБД запрещает удалять зависимые данные только в том случае, если эта зависимость явно определена. Если между таблицами не существует никакой связи, СУБД не будет следить за целостностью данных в таких таблицах.

<hr>

[Содержание](#содержание)

## Примечания 2

**Примечание 1.** Оператор `DELETE` поддерживает дополнительное ключевое слово `IGNORE`, которое позволяет не прерывать процесс удаления данных даже при возникновении ошибок. Например, если выполняется попытка удаления записи, от значений которой зависят другие записи, такая операция просто игнорируется.

После выполнения приведенного ниже запроса:

```sql
DELETE IGNORE FROM Authors
WHERE author = 'Jerome Salinger';
```

таблица `Authors` будет иметь вид:

```
+----+-----------------+
| id | author          |
+----+-----------------+
| 1  | Stephen King    |
| 2  | Chuck Palahniuk |
| 3  | Jerome Salinger |
+----+-----------------+
```

**Примечание 2.** Если необходимо удалить все записи таблицы, рекомендуется использовать оператор `TRUNCATE`, а не `DELETE`, поскольку первый выполняет операцию очистки таблицы гораздо быстрее.

После выполнения приведенного ниже запроса:

```sql
TRUNCATE Books
```

таблица `Books` не будет содержать ни одной записи.

**Примечание 3.** При удалении данных из таблиц на основе данных из других таблиц с помощью соединения нельзя использовать сортировку.

Результатом приведенного ниже запроса:

```sql
DELETE FROM Books
USING Books INNER JOIN Authors ON Books.author_id = Authors.id
WHERE Authors.author = 'Chuck Palahniuk'
ORDER BY Books.id;
```

является ошибка:

```
ERROR 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'ORDER BY Books.id' at line 4
```

<hr>

[Содержание](#содержание)

# 8.3 Добавление данных

Урок посвящен различным способам добавления табличных данных.

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем `Books`, которая содержит информацию о книгах, размещенных в некотором онлайн-магазине:

```
+----+------------------------+-----------------+-------+
| id | title                  | author          | price |
+----+------------------------+-----------------+-------+
| 1  | The Shining            | Stephen King    | 7.99  |
| 2  | Fight Club             | Chuck Palahniuk | 9.99  |
| 3  | The Catcher in the Rye | J.D. Salinger   | 3.49  |
| 4  | The Green Mile         | Stephen King    | 15.99 |
| 5  | Haunted                | Chuck Palahniuk | 13.99 |
+----+------------------------+-----------------+-------+
```

Первое поле этой таблицы содержит идентификатор книги, второе — название, третье — данные об авторе, четвертое — цену в долларах.

Скрипт для создания таблицы `Books`

```sql
DROP TABLE IF EXISTS Books;
CREATE TABLE Books
(
    id     INT PRIMARY KEY,
    title  VARCHAR(40),
    author VARCHAR(40),
    price  DECIMAL(10, 2) DEFAULT 0
);

INSERT INTO Books (id, title, author, price)
VALUES (1, 'The Shining', 'Stephen King', 7.99),
       (2, 'Fight Club', 'Chuck Palahniuk', 9.99),
       (3, 'The Catcher in the Rye', 'J.D. Salinger', 3.49),
       (4, 'The Green Mile', 'Stephen King', 15.99),
       (5, 'Haunted', 'Chuck Palahniuk', 13.99);
```

## Добавление данных

Для добавления данных в таблицу предназначен оператор `INSERT`. Его можно использовать двумя способами:
+ для добавления одной записи
+ для добавления нескольких записей

<hr>

[Содержание](#содержание)

### Добавление одной записи

Наиболее простым способом применения оператора `INSERT` является добавление в таблицу одной записи. Для этого нужно указать название таблицы, в которую должна быть добавлена запись, а затем перечислить все значения этой записи.

В качестве примера добавления одной записи в таблицу рассмотрим запрос, который добавляет в таблицу Books информацию о книге под названием `Animal Farm` за авторством `George Orwell`.

После выполнения приведенного ниже запроса:

```sql
INSERT INTO Books
VALUES (6, 'Animal Farm', 'George Orwell', NULL);
```

таблица `Books` будет иметь вид:

```
+----+------------------------+-----------------+-------+
| id | title                  | author          | price |
+----+------------------------+-----------------+-------+
| 1  | The Shining            | Stephen King    | 7.99  |
| 2  | Fight Club             | Chuck Palahniuk | 9.99  |
| 3  | The Catcher in the Rye | J.D. Salinger   | 3.49  |
| 4  | The Green Mile         | Stephen King    | 15.99 |
| 5  | Haunted                | Chuck Palahniuk | 13.99 |
| 6  | Animal Farm            | George Orwell   | NULL  |
+----+------------------------+-----------------+-------+
```

Запрос выше начинается с оператора `INSERT`, после которого следуют ключевое слово `INTO` и название таблицы, в которую выполняется добавление записи. Затем используется ключевое слово `VALUES` для указания значений добавляемой записи. Они должны быть заключены в круглые скобки и перечислены через запятую, причем для каждого поля обязательно должно быть указано какое-либо значение. Также при перечислении значений добавляемой записи должен соблюдаться их порядок, поскольку первое значение будет использовано в качестве значения первого поля, второе — в качестве значения второго поля, и так далее.

Если при добавлении записи в таблицу для какого-либо ее поля нет соответствующего значения, следует использовать значение `NULL`.

Предложенный способ добавления записей в таблицу довольно прост, но не вполне безопасен, так как он чувствителен к порядку, в котором поля определены в таблице. Поэтому существует более безопасный способ применения оператора `INSERT`, который требует, чтобы для каждого значения было указано поле, в которое это значение должно быть добавлено.

После выполнения приведенного ниже запроса:

```sql
INSERT INTO Books (id, title, author, price)
VALUES (6, 'Animal Farm', 'George Orwell', NULL);
```

таблица Books будет иметь вид:

```
+----+------------------------+-----------------+-------+
| id | title                  | author          | price |
+----+------------------------+-----------------+-------+
| 1  | The Shining            | Stephen King    | 7.99  |
| 2  | Fight Club             | Chuck Palahniuk | 9.99  |
| 3  | The Catcher in the Rye | J.D. Salinger   | 3.49  |
| 4  | The Green Mile         | Stephen King    | 15.99 |
| 5  | Haunted                | Chuck Palahniuk | 13.99 |
| 6  | Animal Farm            | George Orwell   | NULL  |
+----+------------------------+-----------------+-------+
```

В данном примере, как и в примере выше, добавляются данные о книге `Animal Farm`, но на этот раз имена полей явно указаны в круглых скобках после имени таблицы. Поэтому, когда запись добавляется в таблицу, СУБД устанавливает соответствие каждого элемента в списке имен полей с соответствующим элементом в списке значений. Первый элемент в списке значений соответствует первому указанному имени поля, второй элемент — второму указанному имени поля, и так далее.

При указании имен полей в явном виде, значения, перечисленные после ключевого слова `VALUES`, должны соответствовать им в том же самом порядке, причем он не обязательно должен совпадать с порядком следования полей в самой таблице. 

После выполнения приведенного ниже запроса:

```sql
INSERT INTO Books (id, price, author, title)
VALUES (6, 5.99, 'George Orwell', 'Animal Farm');
```

таблица `Books` будет иметь вид:

```
+----+------------------------+-----------------+-------+
| id | title                  | author          | price |
+----+------------------------+-----------------+-------+
| 1  | The Shining            | Stephen King    | 7.99  |
| 2  | Fight Club             | Chuck Palahniuk | 9.99  |
| 3  | The Catcher in the Rye | J.D. Salinger   | 3.49  |
| 4  | The Green Mile         | Stephen King    | 15.99 |
| 5  | Haunted                | Chuck Palahniuk | 13.99 |
| 6  | Animal Farm            | George Orwell   | 5.99  |
+----+------------------------+-----------------+-------+
```

Запрос выше вновь добавляет в таблицу `Books` данные о книге `Animal Farm`, но делает это в другом порядке. Поскольку имена столбцов указываются явно, добавление данных выполняется корректно.

Как правило, оператор `INSERT` не используется без явного указания имен полей. Благодаря этому значительно возрастает вероятность того, что запрос будет выполнен правильно, даже если в таблице произойдут изменения.

<hr>

[Содержание](#содержание)

### Добавление нескольких записей

Один запрос с оператором `INSERT` может использоваться как для добавления одной записи, так и нескольких. Если требуется добавить сразу несколько записей, то после ключевого слова `VALUES` необходимо через запятую указать значения для каждой из них.

Например, в рамках одного запроса мы можем добавить данные о книге `Animal Farm`, а также дополнительно добавить информацию о книге `Lord of the Flies`.

После выполнения приведенного ниже запроса:

```sql
INSERT INTO Books (id, title, author, price)
VALUES (6, 'Animal Farm', 'George Orwell', NULL),
       (7, 'Lord of the Flies', 'William Golding', 5.99);
```

таблица `Books` будет иметь вид:

```
+----+------------------------+-----------------+-------+
| id | title                  | author          | price |
+----+------------------------+-----------------+-------+
| 1  | The Shining            | Stephen King    | 7.99  |
| 2  | Fight Club             | Chuck Palahniuk | 9.99  |
| 3  | The Catcher in the Rye | J.D. Salinger   | 3.49  |
| 4  | The Green Mile         | Stephen King    | 15.99 |
| 5  | Haunted                | Chuck Palahniuk | 13.99 |
| 6  | Animal Farm            | George Orwell   | NULL  |
| 7  | Lord of the Flies      | William Golding | 5.99  |
+----+------------------------+-----------------+-------+
```

<hr>

[Содержание](#содержание)

### Добавление вычисляемых значений

В качестве значений добавляемой записи можно использовать не только константные значения, но и результаты арифметических операций, а также возвращаемые значения различных функций.

Предположим, нам необходимо добавить информацию о книге `Animal Farm`, цена которой равна `9.99` долларов, однако при добавлении книги ее цену нужно указать со скидкой  в `40%`. Для решения такой задачи достаточно умножить исходную цену на `0.6`, что и будет соответствовать требуемой скидке.

После выполнения приведенного ниже запроса:

```sql
INSERT INTO Books (id, title, author, price)
VALUES (6, 'Animal Farm', 'George Orwell', 9.99 * 0.6);
```

таблица Books будет иметь вид:

```
+----+------------------------+-----------------+-------+
| id | title                  | author          | price |
+----+------------------------+-----------------+-------+
| 1  | The Shining            | Stephen King    | 7.99  |
| 2  | Fight Club             | Chuck Palahniuk | 9.99  |
| 3  | The Catcher in the Rye | J.D. Salinger   | 3.49  |
| 4  | The Green Mile         | Stephen King    | 15.99 |
| 5  | Haunted                | Chuck Palahniuk | 13.99 |
| 6  | Animal Farm            | George Orwell   | 5.99  |
+----+------------------------+-----------------+-------+
```

Также мы можем дополнительно воспользоваться функцией `ROUND()`, чтобы обнулить дробную часть у цены, полученной после применения скидки.

После выполнения приведенного ниже запроса:

```sql
INSERT INTO Books (id, title, author, price)
VALUES (6, 'Animal Farm', 'George Orwell', ROUND(9.99 * 0.6));
```

таблица Books будет иметь вид:

```
+----+------------------------+-----------------+-------+
| id | title                  | author          | price |
+----+------------------------+-----------------+-------+
| 1  | The Shining            | Stephen King    | 7.99  |
| 2  | Fight Club             | Chuck Palahniuk | 9.99  |
| 3  | The Catcher in the Rye | J.D. Salinger   | 3.49  |
| 4  | The Green Mile         | Stephen King    | 15.99 |
| 5  | Haunted                | Chuck Palahniuk | 13.99 |
| 6  | Animal Farm            | George Orwell   | 6.00  |
+----+------------------------+-----------------+-------+
```

<hr>

[Содержание](#содержание)

### Добавление с помощью ключевого слова `SET`

Обычно при использовании оператора `INSERT` отдельно указываются поля и отдельно значения, однако существует еще один способ применения этого оператора, при котором поля и их значения располагаются рядом друг с другом и связываются знаком равенства. Синтаксически это очень похоже на использование оператора `UPDATE`, поскольку в данном случае также применяется ключевое слово `SET`.

После выполнения приведенного ниже запроса:

```sql
INSERT INTO Books
SET id = 6,
    title = 'Animal Farm',
    author = 'George Orwell',
    price = 9.99;
```

таблица `Books` будет иметь вид:

```
+----+------------------------+-----------------+-------+
| id | title                  | author          | price |
+----+------------------------+-----------------+-------+
| 1  | The Shining            | Stephen King    | 7.99  |
| 2  | Fight Club             | Chuck Palahniuk | 9.99  |
| 3  | The Catcher in the Rye | J.D. Salinger   | 3.49  |
| 4  | The Green Mile         | Stephen King    | 15.99 |
| 5  | Haunted                | Chuck Palahniuk | 13.99 |
| 6  | Animal Farm            | George Orwell   | 9.99  |
+----+------------------------+-----------------+-------+
```

Как видно из примера выше, сперва, как и прежде, мы указываем выражение `INSERT INTO` и название таблицы, в которую выполняется добавление записи, а затем ключевое слово `SET`, после которого определяем значение для каждого поля добавляемой записи.

Сочетание операторов `INSERT` и `SET` позволяет добавить в таблицу лишь одну запись.

<hr>

[Содержание](#содержание)

### Добавление данных из других таблиц

Предположим, в нашей базе данных появилась дополнительная таблица под названием `NewBooks`, которая хранит информацию о двух различных книгах и имеет следующий вид:

```
+----+-------------------+-----------------+-------+
| id | title             | author          | price |
+----+-------------------+-----------------+-------+
| 6  | Animal Farm       | George Orwell   | 9.99  |
| 7  | Lord of the Flies | William Golding | 5.99  |
+----+-------------------+-----------------+-------+
```

Скрипт для создания таблицы `NewBooks`

```sql
DROP TABLE IF EXISTS NewBooks;
CREATE TABLE NewBooks
(
    id     INT PRIMARY KEY,
    title  VARCHAR(40),
    author VARCHAR(40),
    price  DECIMAL(10, 2) DEFAULT 0
);

INSERT INTO NewBooks (id, title, author, price)
VALUES (6, 'Animal Farm', 'George Orwell', 9.99),
       (7, 'Lord of the Flies', 'William Golding', 5.99);
```

Если нам требуется перенести эту информацию в основную таблицу `Books`, то сделать это можно сочетанием операторов `INSERT` и `SELECT` путем извлечения данных из таблицы `NewBooks` с последующим их добавлением в таблицу `Books`.

После выполнения приведенного ниже запроса:

```sql
INSERT INTO Books (id, title, author, price)
SELECT id, title, author, price
FROM NewBooks;
```

таблица `Books` будет иметь вид:

```
+----+------------------------+-----------------+-------+
| id | title                  | author          | price |
+----+------------------------+-----------------+-------+
| 1  | The Shining            | Stephen King    | 7.99  |
| 2  | Fight Club             | Chuck Palahniuk | 9.99  |
| 3  | The Catcher in the Rye | J.D. Salinger   | 3.49  |
| 4  | The Green Mile         | Stephen King    | 15.99 |
| 5  | Haunted                | Chuck Palahniuk | 13.99 |
| 6  | Animal Farm            | George Orwell   | 9.99  |
| 7  | Lord of the Flies      | William Golding | 5.99  |
+----+------------------------+-----------------+-------+
```

В данном примере сначала выполняется извлекающий запрос, который возвращает все записи таблицы `NewBooks`. Затем каждая запись добавляется в таблицу `Books`. Важно заметить, что извлекающий запрос должен возвращать таблицу, количество полей которой совпадает с количеством имен полей, указанных после оператора `INSERT`, причем названия полей в возвращаемой извлекающим запросом таблице значения не имеют, так как их сопоставление происходит лишь с учетом порядка.

Извлекающий запрос, используемый при добавлении данных из других таблиц, является полноценным запросом, поэтому может иметь произвольную сложность.

Можно заметить, что в таблице `NewBooks` идентификаторы книг имеют значения 6 и 7. Сделано это для того, чтобы при переносе записей из таблицы `NewBooks` в таблицу `Books` не возникало совпадений между значениями поля `id`, поскольку оно является первичным ключом.

Однако на практике первичные ключи могут и будут совпадать, поэтому теперь рассмотрим задачу несколько сложнее, при которой идентификаторы книг в таблице `NewBooks` имеют более привычные значения 1 и 2:

```
+----+-------------------+-----------------+-------+
| id | title             | author          | price |
+----+-------------------+-----------------+-------+
| 1  | Animal Farm       | George Orwell   | 9.99  |
| 2  | Lord of the Flies | William Golding | 5.99  |
+----+-------------------+-----------------+-------+
```

Если мы вновь попытаемся перенести данные с помощью предыдущего запроса, то столкнемся с ошибкой, поскольку произойдет попытка добавить в таблицу `Books` запись, идентификатор которой совпадает с идентификатором уже имеющейся в таблице записи.

Результатом приведенного ниже запроса:

```sql
INSERT INTO Books (id, title, author, price)
SELECT id, title, author, price
FROM NewBooks;
```

является ошибка:

```
ERROR 1062: Duplicate entry '1' for key 'Books.PRIMARY'
```

Для решения данной задачи нам необходимо для каждой добавляемой записи определять новое значение поля `id`. Несложно догадаться, что таким значением является сумма максимального значения поля `id` таблицы `Books` и текущего значения поля `id` добавляемой записи. Максимальное значение поля `id` таблицы Books мы можем вычислить с помощью подзапроса, а текущее значение поля `id` добавляемой записи нам доступно и так.

После выполнения приведенного ниже запроса:

```sql
INSERT INTO Books (id, title, author, price)
SELECT (SELECT MAX(id)
        FROM Books) + NewBooks.id,
        title, author, price
FROM NewBooks;
```

таблица `Books` будет иметь вид:

```
+----+------------------------+-----------------+-------+
| id | title                  | author          | price |
+----+------------------------+-----------------+-------+
| 1  | The Shining            | Stephen King    | 7.99  |
| 2  | Fight Club             | Chuck Palahniuk | 9.99  |
| 3  | The Catcher in the Rye | J.D. Salinger   | 3.49  |
| 4  | The Green Mile         | Stephen King    | 15.99 |
| 5  | Haunted                | Chuck Palahniuk | 13.99 |
| 6  | Animal Farm            | George Orwell   | 9.99  |
| 7  | Lord of the Flies      | William Golding | 5.99  |
+----+------------------------+-----------------+-------+
```

Здесь, например, первая добавляемая запись в качестве нового значения поля `id` имеет число 6, поскольку максимальным значением поля `id` таблицы `Books` является число 5, а текущим значением поля `id` добавляемой записи является число 1.

Следует заметить, что пример выше является учебным, и на практике явно работать со значениями первичного ключа и следить за их уникальностью обычно не нужно, поскольку подобным может заниматься сама СУБД. Чаще всего поле, являющееся первичным ключом, определяют как целочисленное и самозаполняющееся. При добавлении первой записи значение такого поля автоматически принимается равным 1, при добавлении второй записи — 2, и так далее. Подробнее об этом будет рассказано в следующем модуле, посвященном созданию таблиц.

<hr>

[Содержание](#содержание)

## Примечания 3

**Примечание 1.** Если поле имеет значение по умолчанию, то при добавлении записи значение для такого поля, как и само поле, можно не указывать. К примеру, поле `price` таблицы `Books` имеет значение по умолчанию, равное 0. Если во время добавления записи мы опустим это поле, то в качестве значения поля `price` будет использовано число 0.

После выполнения приведенного ниже запроса:

```sql
INSERT INTO Books (id, title, author)
VALUES (6, 'Animal Farm', 'George Orwell');
```

таблица Books будет иметь вид:

```
+----+------------------------+-----------------+-------+
| id | title                  | author          | price |
+----+------------------------+-----------------+-------+
| 1  | The Shining            | Stephen King    | 7.99  |
| 2  | Fight Club             | Chuck Palahniuk | 9.99  |
| 3  | The Catcher in the Rye | J.D. Salinger   | 3.49  |
| 4  | The Green Mile         | Stephen King    | 15.99 |
| 5  | Haunted                | Chuck Palahniuk | 13.99 |
| 6  | Animal Farm            | George Orwell   | 0.00  |
+----+------------------------+-----------------+-------+
```

В примере выше выполняется добавление записи с явным указанием полей `id`, `title` и `author`, а также приводятся значения для этих полей. Поэтому при добавлении записи эти три поля примут соответствующие им значения, в то время как неуказанное поле `price` примет значение по умолчанию, равное 0.

Несмотря на определенное удобство, рекомендуется не опираться на значения по умолчанию при добавлении записи и определять значение для каждого поля явно. 

**Примечание 2.** Оператор `INSERT` поддерживает дополнительное ключевое слово `IGNORE`, которое позволяет не прерывать процесс добавления данных даже при возникновении ошибок. Например, если выполняется попытка добавления записи, значение первичного ключа которой совпадает со значением первичного ключа уже имеющейся в таблице записи, такая операция просто игнорируется.

После выполнения приведенного ниже запроса:

```sql
INSERT IGNORE INTO Books (id, title, author, price)
VALUES (1, 'Animal Farm', 'George Orwell', 9.99),
       (6, 'Lord of the Flies', 'William Golding', 5.99);
```

таблица `Books` будет иметь вид:

```
+----+------------------------+-----------------+-------+
| id | title                  | author          | price |
+----+------------------------+-----------------+-------+
| 1  | The Shining            | Stephen King    | 7.99  |
| 2  | Fight Club             | Chuck Palahniuk | 9.99  |
| 3  | The Catcher in the Rye | J.D. Salinger   | 3.49  |
| 4  | The Green Mile         | Stephen King    | 15.99 |
| 5  | Haunted                | Chuck Palahniuk | 13.99 |
| 6  | Lord of the Flies      | William Golding | 5.99  |
+----+------------------------+-----------------+-------+
```

Во время выполнения запроса выше игнорируется добавление первой записи, потому что в таблице Books уже имеется книга с идентификатором 1.

**Примечание 3.** В SQL существует оператор `REPLACE`, который работает как `INSERT` и `UPDATE` одновременно: запись добавляется в таблицу, если значение ее первичного ключа уникально. Если же оно совпадает со значением первичного ключа другой записи, то добавляемая запись заменяет эту другую запись.

После выполнения приведенного ниже запроса:

```sql
REPLACE INTO Books (id, title, author, price)
VALUES (1, 'Animal Farm', 'George Orwell', 9.99),
       (6, 'Lord of the Flies', 'William Golding', 5.99);
```

таблица `Books` будет иметь вид:

```
+----+------------------------+-----------------+-------+
| id | title                  | author          | price |
+----+------------------------+-----------------+-------+
| 1  | Animal Farm            | George Orwell   | 9.99  |
| 2  | Fight Club             | Chuck Palahniuk | 9.99  |
| 3  | The Catcher in the Rye | J.D. Salinger   | 3.49  |
| 4  | The Green Mile         | Stephen King    | 15.99 |
| 5  | Haunted                | Chuck Palahniuk | 13.99 |
| 6  | Lord of the Flies      | William Golding | 5.99  |
+----+------------------------+-----------------+-------+
```

В данном примере из двух записей в таблицу `Books` добавляется только вторая, в то время как первая добавляемая запись заменяет первую запись таблицы, так как их значения первичного ключа совпадают.

<hr>

[Содержание](#содержание)