# 6. Подзапросы

## Содержание

+ [6.1 Подзапросы. Часть 1](#61-подзапросы-часть-1)
    + [Подзапросы](#подзапросы)
    + [Подзапросы с одним полем и одной записью](#подзапросы-с-одним-полем-и-одной-записью)
    + [Подзапросы с одним полем и несколькими записями](#подзапросы-с-одним-полем-и-несколькими-записями)
        + [Ключевое слово `ALL`](#ключевое-слово-all)
        + [Ключевое слово `ANY`](#ключевое-слово-any)
+ [6.2 Подзапросы. Часть 2](#62-подзапросы-часть-2)
    + [Некоррелированные подзапросы](#некоррелированные-подзапросы)
    + [Коррелированные подзапросы](#коррелированные-подзапросы)
    + [Подзапросы с несколькими полями](#подзапросы-с-несколькими-полями)
+ [6.3 Подзапросы. Часть 3](#63-подзапросы-часть-3)
    + [Подзапросы при работе с несколькими таблицами](#подзапросы-при-работе-с-несколькими-таблицами)
+ [6.4 Решение задач](#64-решение-задач)

[Оглавление](/SQL_for_beginners/README.MD)

# 6.1 Подзапросы. Часть 1

Урок посвящен подзапросам и примерам их использования.

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем `Books`, которая содержит информацию о десяти различных книгах, размещенных в некотором интернет-магазине:

```
+----+------------------------------------------+---------------------+-------+
| id | title                                    | author              | price |
+----+------------------------------------------+---------------------+-------+
| 1  | The Shining                              | Stephen King        | 7.99  |
| 2  | Fight Club                               | Chuck Palahniuk     | 9.99  |
| 3  | The Catcher in the Rye                   | J.D. Salinger       | 3.49  |
| 4  | The Green Mile                           | Stephen King        | 15.99 |
| 5  | The Great Gatsby                         | F. Scott Fitzgerald | 7.99  |
| 6  | The Lord of the Rings                    | J.R.R. Tolkien      | 19.99 |
| 7  | It                                       | Stephen King        | 12.99 |
| 8  | The Silmarillion                         | J.R.R. Tolkien      | 11.99 |
| 9  | Haunted                                  | Chuck Palahniuk     | 13.99 |
| 10 | Harry Potter and the Prisoner of Azkaban | J.K. Rowling        | 9.99  |
+----+------------------------------------------+---------------------+-------+
```

Первое поле этой таблицы содержит идентификатор книги, второе — название, третье — данные об авторе, четвертое — цену книги в долларах.

Скрипт для создания таблицы `Books`

```sql
DROP TABLE IF EXISTS Books;
CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author    VARCHAR(30),
    price     DECIMAL(10, 2)
);

INSERT INTO Books (title, author, price)
VALUES ('The Shining', 'Stephen King', 7.99),
       ('Fight Club', 'Chuck Palahniuk', 9.99),
       ('The Catcher in the Rye', 'J.D. Salinger', 3.49),
       ('The Green Mile', 'Stephen King', 15.99),
       ('The Great Gatsby', 'F. Scott Fitzgerald', 7.99),
       ('The Lord of the Rings', 'J.R.R. Tolkien', 19.99),
       ('It', 'Stephen King', 12.99),
       ('The Silmarillion', 'J.R.R. Tolkien', 11.99),
       ('Haunted', 'Chuck Palahniuk', 13.99),
       ('Harry Potter and the Prisoner of Azkaban', 'J.K. Rowling', 9.99);
```

<hr>

[Содержание](#содержание)

## Подзапросы

До сих пор во всех наших запросах мы обращались к таблице и единожды извлекали из нее необходимые данные. Мы могли дополнительно фильтровать или сортировать их, но в любом случае извлечение записей из таблицы выполнялось лишь один раз. Однако в рамках одного запроса данные из таблицы могут извлекаться несколько раз, и для выполнения таких вспомогательных операций извлечения используются подзапросы.

**Подзапрос** — это запрос, вложенный в другой запрос. Подзапрос всегда заключен в круглые скобки и обычно выполняется перед основным запросом. Подзапросы являются обычными запросами, и для них не предусмотрен какой-либо отдельный синтаксис, поэтому для составления подзапросов достаточно уметь составлять обычные запросы.

<hr>

[Содержание](#содержание)

## Подзапросы с одним полем и одной записью

При изучении агрегатных функций было замечено, что их нельзя использовать для фильтрации записей, поэтому если мы захотим извлечь данные о книгах, чья стоимость превышает среднюю стоимость всех книг, то сделать это с помощью следующего запроса будет невозможно:

```sql
SELECT *
FROM Books
WHERE price > AVG(price);
```

поскольку его результатом является ошибка:

```
ERROR 1111: Invalid use of group function
```

Для решения данной задачи мы можем воспользоваться подзапросом, чтобы сперва вычислить среднюю стоимость книг, а затем выполнить сравнение с полученным значением.

Результатом приведенного ниже запроса:

```sql
SELECT *
FROM Books
WHERE price > (SELECT AVG(price)
               FROM Books);
```

является:

```
+----+-----------------------+-----------------+-------+
| id | title                 | author          | price |
+----+-----------------------+-----------------+-------+
| 4  | The Green Mile        | Stephen King    | 15.99 |
| 6  | The Lord of the Rings | J.R.R. Tolkien  | 19.99 |
| 7  | It                    | Stephen King    | 12.99 |
| 8  | The Silmarillion      | J.R.R. Tolkien  | 11.99 |
| 9  | Haunted               | Chuck Palahniuk | 13.99 |
+----+-----------------------+-----------------+-------+
```

Здесь в условии фильтрации значение поля `price` сравнивается с результатом подзапроса. Подзапрос обращается к таблице `Books` и вычисляет среднее арифметическое всех значений ее поля `price`. Таблица, получаемая в результате подзапроса, состоит из одной записи и одного поля, то есть содержит единственное значение, с которым и происходит последующее сравнение значения поля `price`.

Сравнение значения поля  `price` с таблицей возможно именно по той причине, что эта таблица содержит лишь одно значение, и СУБД использует это значение для выполнения операции сравнения. Если бы таблица содержала более одного значения, такая операция была бы невозможна.

Результатом приведенного ниже запроса:

```sql
SELECT *
FROM Books
WHERE price > (SELECT price
               FROM Books);
```

является ошибка:

```
ERROR 1242: Subquery returns more than 1 row
```

Подзапросы могут использоваться не только для фильтрации записей, но и для фильтрации групп. Таким примером может быть запрос, извлекающий данные об авторах, средняя стоимость книг которых превышает среднюю стоимость всех книг.

Результатом приведенного ниже запроса:

```sql
SELECT author, AVG(price) AS avg_price
FROM Books
GROUP BY author
HAVING AVG(price) > (SELECT AVG(price)
                     FROM Books);
```

является:

```
+-----------------+--------------------+
| author          | avg_price          |
+-----------------+--------------------+
| Stephen King    | 12.323333104451498 |
| Chuck Palahniuk | 11.989999771118164 |
| J.R.R. Tolkien  | 15.989999771118164 |
+-----------------+--------------------+
```

Здесь записи сперва группируются по полю `author`, а затем фильтруются. Для фильтрации используется подзапрос, который, как и выше, обращается к таблице `Books` и вычисляет среднее арифметическое всех значений ее поля `price`. Группа попадает в результирующую таблицу, если среднее значение ее поля `price` больше среднего значения поля `price` всей таблицы, в противном случае группа отбрасывается.

Подзапросы при фильтрации позволяют вычислять различные значения на основе данных из всей таблицы (минимум, максимум, среднее значение) и использовать их в условиях фильтрации.

<hr>

[Содержание](#содержание)

## Подзапросы с одним полем и несколькими записями

Как было сказано выше, сравнение одиночного значения с таблицей возможно только в том случае, если эта таблица состоит из одного поля и одной записи, то есть содержит единственное значение. Однако с помощью ключевых слов ALL и ANY можно выполнять сравнение с таблицей, содержащей одно поле и произвольное количество записей, то есть сравнивать одиночное значение с набором значений.

<hr>

[Содержание](#содержание)

### Ключевое слово `ALL`

При использовании ключевого слова `ALL` условие в операции сравнения должно быть истинно для всех значений, которые возвращаются подзапросом. Например, с помощью данного ключевого слова мы можем составить запрос, извлекающий данные о книгах, цена которых больше, чем у каждой книги за авторством `Chuck Palahniuk`.

Результатом приведенного ниже запроса:

```sql
SELECT title, author, price
FROM Books
WHERE price > ALL (SELECT price
                   FROM Books
                   WHERE author = 'Chuck Palahniuk');
```

является:

```
+-----------------------+----------------+-------+
| title                 | author         | price |
+-----------------------+----------------+-------+
| The Green Mile        | Stephen King   | 15.99 |
| The Lord of the Rings | J.R.R. Tolkien | 19.99 |
+-----------------------+----------------+-------+
```

В данном примере подзапрос возвращает таблицу, состоящую из одного поля `price` и двух записей, поскольку в таблице `Books` содержатся две книги, принадлежащие автору `Chuck Palahniuk`:

+-------+
| price |
+-------+
| 9.99  |
| 13.99 |
+-------+
Сравнение значения поля `price` с этой таблицей выполняется путем его последовательного сравнения с каждым значением таблицы: сначала выполняется сравнение `price > 9.99`, затем — `price > 13.99`. Если результатом обеих операций сравнения является истина, запись попадает в результирующую таблицу, если же хотя бы один результат является ложным, запись отбрасывается.

Фактически запрос выше эквивалентен следующему запросу:

```sql
SELECT title, author, price
FROM Books
WHERE price > 9.99 AND price > 13.99;
```

<hr>

[Содержание](#содержание)

### Ключевое слово `ANY`

При использовании ключевого слова `ANY` условие в операции сравнения должно быть истинно хотя бы для одного из значений, которые возвращаются подзапросом. Например, с помощью данного ключевого слова мы можем составить запрос для извлечения данных о книгах, цена которых меньше, чем хотя бы у одной книги за авторством `Chuck Palahniuk`.

Результатом приведенного ниже запроса:

```sql
SELECT title, author, price
FROM Books
WHERE price < ANY (SELECT price
                   FROM Books
                   WHERE author = 'Chuck Palahniuk');
```

является:

```
+------------------------------------------+---------------------+-------+
| title                                    | author              | price |
+------------------------------------------+---------------------+-------+
| The Shining                              | Stephen King        | 7.99  |
| Fight Club                               | Chuck Palahniuk     | 9.99  |
| The Catcher in the Rye                   | J.D. Salinger       | 3.49  |
| The Great Gatsby                         | F. Scott Fitzgerald | 7.99  |
| It                                       | Stephen King        | 12.99 |
| The Silmarillion                         | J.R.R. Tolkien      | 11.99 |
| Harry Potter and the Prisoner of Azkaban | J.K. Rowling        | 9.99  |
+------------------------------------------+---------------------+-------+
```

В данном примере подзапрос возвращает таблицу, состоящую из одного поля `price` и двух записей:

```
+-------+
| price |
+-------+
| 9.99  |
| 13.99 |
+-------+
```

Сравнение значения поля `price` с этой таблицей выполняется путем его последовательного сравнения с каждым значением таблицы: сначала выполняется сравнение `price < 9.99`, затем — `price < 13.99`. Если результатом хотя бы одной операции сравнения является истина, запись попадает в результирующую таблицу, если же все результаты являются ложными, запись отбрасывается.

Фактически запрос выше эквивалентен следующему запросу:

```sql
SELECT title, author, price
FROM Books
WHERE price < 9.99 OR price < 13.99;
```

У ключевого слова `ANY` имеется аналог в виде ключевого слова `SOME`. По своему действию оба этих ключевых слова идентичны, поэтому применять можно любое из них.

<hr>

[Содержание](#содержание)

## Примечания 1

**Примечание 1.** Так как результатом подзапроса является таблица, она может быть указана после ключевого слова `FROM`. В таком случае основной запрос будет работать с той таблицей, которую вернул подзапрос.

Результатом приведенного ниже запроса:

```sql
SELECT *
FROM (SELECT title, author, price
      FROM Books) AS BooksCopy;
```

является:

```
+------------------------------------------+---------------------+-------+
| title                                    | author              | price |
+------------------------------------------+---------------------+-------+
| The Shining                              | Stephen King        | 7.99  |
| Fight Club                               | Chuck Palahniuk     | 9.99  |
| The Catcher in the Rye                   | J.D. Salinger       | 3.49  |
| The Green Mile                           | Stephen King        | 15.99 |
| The Great Gatsby                         | F. Scott Fitzgerald | 7.99  |
| The Lord of the Rings                    | J.R.R. Tolkien      | 19.99 |
| It                                       | Stephen King        | 12.99 |
| The Silmarillion                         | J.R.R. Tolkien      | 11.99 |
| Haunted                                  | Chuck Palahniuk     | 13.99 |
| Harry Potter and the Prisoner of Azkaban | J.K. Rowling        | 9.99  |
+------------------------------------------+---------------------+-------+
```

Обратите внимание, что при использовании подзапроса совместно с ключевым словом `FROM` ему необходимо присвоить псевдоним, в противном случае при выполнении запроса произойдет ошибка. 

Результатом приведенного ниже запроса:

```sql
SELECT *
FROM (SELECT title, author, price
      FROM Books);
```

является ошибка:

```
ERROR 1248: Every derived table must have its own alias
```

**Примечание 2.** Если результатом подзапроса является таблица с единственным значением, то это значение может быть извлечено с помощью оператора `SELECT`, например, как обычное число.

Результатом приведенного ниже запроса:

```sql
SELECT (SELECT SUM(price)
        FROM Books) AS total;
```

является:

```
+--------------------+
| total              |
+--------------------+
| 114.39999794960022 |
+--------------------+
```

**Примечание 3.** Если результатом подзапроса является пустая таблица, она приравнивается к значению `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT (SELECT title
        FROM Books
        WHERE id = 121) AS title;
```

является:

```
+-------+
| title |
+-------+
| NULL  |
+-------+
```

В данном случае подзапрос пытается вернуть запись из таблицы `Books`, значение поля `id` которой равняется `121`, однако в таблице нет такой записи, поэтому подзапрос возвращает пустую таблицу, которая основным запросом трактуется как значение `NULL`.

<hr>

[Содержание](#содержание)

# 6.2 Подзапросы. Часть 2

Урок посвящен коррелированным подзапросам и примерам их использования.

## Используемая база данных 2

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем `Books`, которая содержит информацию о десяти различных книгах, размещенных на некотором агрегаторе с системой оценок:

```
+----+------------------------------------------+---------------------+--------------+------------+
| id | title                                    | author              | critic_score | user_score |
+----+------------------------------------------+---------------------+--------------+------------+
| 1  | The Shining                              | Stephen King        | 39           | 51         |
| 2  | Fight Club                               | Chuck Palahniuk     | 99           | 99         |
| 3  | The Catcher in the Rye                   | J.D. Salinger       | 99           | 89         |
| 4  | The Green Mile                           | Stephen King        | 73           | 84         |
| 5  | The Great Gatsby                         | F. Scott Fitzgerald | 87           | 87         |
| 6  | The Lord of the Rings                    | J.R.R. Tolkien      | 39           | 51         |
| 7  | It                                       | Stephen King        | 39           | 75         |
| 8  | The Silmarillion                         | J.R.R. Tolkien      | 90           | 64         |
| 9  | Haunted                                  | Chuck Palahniuk     | 52           | 59         |
| 10 | Harry Potter and the Prisoner of Azkaban | J.K. Rowling        | 66           | 89         |
+----+------------------------------------------+---------------------+--------------+------------+
```

Первое поле этой таблицы содержит идентификатор книги, второе — название, третье — данные об авторе, четвертое — оценку критиков, пятое — оценку пользователей.

Скрипт для создания таблицы `Books`

```sql
DROP TABLE IF EXISTS Books;
CREATE TABLE Books
(
    id           INT PRIMARY KEY AUTO_INCREMENT,
    title        VARCHAR(40),
    author       VARCHAR(30),
    critic_score INT,
    user_score   INT
);

INSERT INTO Books (title, author, critic_score, user_score)
VALUES ('The Shining', 'Stephen King', 39, 51),
       ('Fight Club', 'Chuck Palahniuk', 99, 99),
       ('The Catcher in the Rye', 'J.D. Salinger', 99, 89),
       ('The Green Mile', 'Stephen King', 73, 84),
       ('The Great Gatsby', 'F. Scott Fitzgerald', 87, 87),
       ('The Lord of the Rings', 'J.R.R. Tolkien', 39, 51),
       ('It', 'Stephen King', 39, 75),
       ('The Silmarillion', 'J.R.R. Tolkien', 90, 64),
       ('Haunted', 'Chuck Palahniuk', 52, 59),
       ('Harry Potter and the Prisoner of Azkaban', 'J.K. Rowling', 66, 89);
```

<hr>

[Содержание](#содержание)

## Некоррелированные подзапросы

Подзапросы, рассмотренные в предыдущем уроке, были независимыми. Они могли выполняться автономно от основного запроса, и перед тем как их результат будет использоваться в основном запросе, мы могли посмотреть, что они возвращают. Такие подзапросы называются некоррелированными.

В качестве примера использования некоррелированного подзапроса напишем запрос, извлекающий данные о книгах, которые имеют минимальную оценку критиков.

Результатом приведенного ниже запроса:

```sql
SELECT title, critic_score
FROM Books
WHERE critic_score = (SELECT MIN(critic_score)
                      FROM Books);
```

является:

```
+-----------------------+--------------+
| title                 | critic_score |
+-----------------------+--------------+
| The Shining           | 39           |
| The Lord of the Rings | 39           |
| It                    | 39           |
+-----------------------+--------------+
```

Здесь подзапрос используется для вычисления наименьшего значения поля `critic_score`, то есть для определения минимальной оценки критиков. Результатом данного подзапроса является таблица с единственным значением — числом `39`. Оно фиксировано и остается неизменным во время выполнения всего основного запроса.

Другими словами, запрос выше мы можем записать в следующем виде:

```sql
SELECT title, critic_score
FROM Books
WHERE critic_score = 39;
```

Аналогичным образом поступает и СУБД, если какой-либо запрос включает в себя некоррелированный подзапрос. Перед тем как приступить к выполнению основного запроса, она единожды определяет результат подзапроса, а затем лишь использует его. Таким образом, обработка запроса, содержащего некоррелированный подзапрос, происходит в два этапа:
+ выполняется подзапрос, определяется его результат
+ полностью выполняется основной запрос с использованием результата подзапроса

<hr>

[Содержание](#содержание)

## Коррелированные подзапросы

Несмотря на то что некоррелированный подзапрос является достаточно мощным инструментом, он может справиться не с любой задачей. Предположим, нам требуется написать запрос, извлекающий данные о книгах, пользовательская оценка которых больше, чем у предыдущей книги в таблице, то есть у книги с идентификатором на один меньше.

Схематически необходимый запрос мы можем показать следующим образом:

```sql
SELECT title, user_score
FROM Books
WHERE user_score > <оценка предыдущей книги>;
```

Проблема данной задачи заключается в том, что для ее решения нам необходимо, чтобы для каждой записи справа от знака > располагалось соответствующее именно ей значение (оценка книги с идентификатором на один меньше), а не какое-либо фиксированное значение.

Реализовать это можно с помощью **коррелированного** подзапроса. Он используется в том случае, когда для каждой записи, анализируемой основным запросом, подзапрос должен вернуть результат, зависящий от значений в этой записи. Иными словами, коррелированный подзапрос отвечает на вопрос, ответ на который зависит от обрабатываемой основным запросом записи.

С применением коррелированного подзапроса мы можем показать необходимый нам запрос более точно, однако по-прежнему схематически:

```sql
SELECT title, user_score
FROM Books
WHERE user_score > (SELECT user_score
                    FROM Books
                    WHERE <поле id внутренней таблицы> = <поле id внешней таблицы> - 1);
```

Проблема, возникающая на данном этапе проектирования запроса, связана с именованием полей. Поскольку коррелированный подзапрос, помимо значений полей собственной таблицы, использует значения полей таблицы, принадлежащей основному запросу, должна быть возможность различать эти поля, если они имеют одинаковые названия.

Для этого при обращении к полю явно указывают название таблицы, например, `Books.id` (поле `id` таблицы `Books`). Если и основной запрос, и подзапрос обращаются к одной и той же таблице, то одной из таблиц дают псевдоним.

Теперь мы можем показать окончательный вариант необходимого нам запроса:

```sql
SELECT title, user_score
FROM Books
WHERE user_score > (SELECT user_score
                    FROM Books AS InnerBooks
                    WHERE id = Books.id - 1);
```

результатом которого является:

```
+------------------------------------------+------------+
| title                                    | user_score |
+------------------------------------------+------------+
| Fight Club                               | 99         |
| The Great Gatsby                         | 87         |
| It                                       | 75         |
| Harry Potter and the Prisoner of Azkaban | 89         |
+------------------------------------------+------------+
```

Итак, основной запрос здесь извлекает записи из таблицы `Books`, а также фильтрует их с помощью подзапроса. Значение подзапроса не вычисляется единожды, а определяется для каждой рассматриваемой основным запросом записи отдельно, поскольку оно напрямую зависит от этой записи.

Например, если основной запрос рассматривает следующую запись:

```
+----+----+--------------+----+----+
| 7  | It | Stephen King | 39 | 75 |
+----+----+--------------+----+----+
```

то в подзапросе значение `Books.id` на данный момент равняется `7` и выполнение подзапроса происходит с учетом именно этого значения, вследствие чего подзапросом возвращается таблица, содержащая значение поля `user_score` той записи, значение поля `id` которой равняется `7 - 1 = 6`:

+------------+
| user_score |
+------------+
| 51         |
+------------+

Далее в основном запросе выполняется сравнение значения поля `user_score` рассматриваемой записи со значением, которое вернул подзапрос для этой записи: `75 > 51`. Так как результатом этого сравнения является истина, рассматриваемая запись попадает в результирующую таблицу.

Таким образом, коррелированный подзапрос выполняется для каждой записи отдельно (сперва для первой, затем для второй и так далее) и для каждой записи возвращает результат, полученный на основе ее значений.

<hr>

[Содержание](#содержание)

## Подзапросы с несколькими полями

При сравнении некоторого значения с результатом подзапроса требуется, чтобы этим результатом была таблица из одного поля и одной записи или из одного поля и нескольких записей. Однако SQL позволяет сравнивать не только одиночные значения, но и пары значений. В подобных случаях используются подзапросы, возвращающие таблицы из нескольких полей.

В качестве примера использования такого подзапроса напишем запрос, извлекающий данные о книгах, которые имеют минимальный рейтинг и от критиков, и от пользователей.

Результатом приведенного ниже запроса:

```sql
SELECT title, critic_score, user_score
FROM Books
WHERE (critic_score, user_score) = (SELECT MIN(critic_score), MIN(user_score)
                                    FROM Books);
```

является:

```
+-----------------------+--------------+------------+
| title                 | critic_score | user_score |
+-----------------------+--------------+------------+
| The Shining           | 39           | 51         |
| The Lord of the Rings | 39           | 51         |
+-----------------------+--------------+------------+
```

Подзапрос в данном запросе возвращает таблицу из двух полей, первое из которых содержит минимальное значение поля `critic_score`, второе — минимальное значение поля `user_score`:

```
+-------------------+-----------------+
| MIN(critic_score) | MIN(user_score) |
+-------------------+-----------------+
| 39                | 51              |
+-------------------+-----------------+
```

Затем основной запрос выполняет фильтрацию путем парного сравнения значений записи с полученными подзапросом минимальными значениями. Запись попадает в результирующую таблицу, если ее значение поля `critic_score` равняется минимальному значению этого же поля (`39`) и если ее значение поля `user_score` равняется минимальному значению этого же поля (`51`).

Фактически запрос выше эквивалентен следующему запросу:

```sql
SELECT title, critic_score, user_score
FROM Books
WHERE critic_score = 39 AND user_score = 51;
```

Если с результатом подзапроса сравнивается не одно поле, а несколько, эти поля должны быть заключены в скобки.

<hr>

[Содержание](#содержание)

## Примечания 2

**Примечание 1.** Обращение к полю с явным указанием таблицы (например, `Books.id`) является лишь обращением по полному имени. Полные имена применяются в тех случаях, когда может возникнуть неопределенность в именовании полей, к примеру, когда поле подзапроса сравнивается с полем основного запроса и эти поля имеют одинаковые имена.

Полными именами можно пользоваться всегда, однако большой нужды в этом нет, поскольку в рамках запроса обращение все равно будет происходить к полям той таблицы, чье имя или псевдоним указаны после ключевого слова `FROM`.

Например, приведенные ниже запросы функционально полностью идентичны:

```sql
SELECT title
FROM Books;

SELECT Books.title
FROM Books;

SELECT title
FROM Books AS B;

SELECT B.title
FROM Books AS B;
```

**Примечание 2.** Если таблице присвоен псевдоним, то и обращение к полям этой таблицы по полному имени должно происходить только с помощью данного псевдонима.

Результатом приведенного ниже запроса:

```sql
SELECT B.title
FROM Books AS B
WHERE B.author = 'J.R.R. Tolkien';
```

является:

```
+-----------------------+
| title                 |
+-----------------------+
| The Lord of the Rings |
| The Silmarillion      |
+-----------------------+
```

Попытка обратиться к полям таблицы по полному имени с использованием ее исходного имени приведет к ошибке.

Результатом приведенного ниже запроса:

```sql
SELECT Books.title
FROM Books AS B
WHERE Books.author = 'J.R.R. Tolkien'
```

является ошибка:

```
ERROR 1054: Unknown column 'Books.title' in 'field list'
```

**Примечание 3.** Если подзапрос возвращает таблицу из одного поля и нескольких записей, то помимо сравнения некоторого значения с этой таблицей с помощью ключевых слов `ALL` и `ANY`, можно выполнить проверку на вхождение с помощью оператора `IN`.

К примеру, мы можем написать запрос, извлекающий данные о книгах, оценка критиков которых совпадает с оценкой критиков предыдущей или последней перед предыдущей книги, то есть книги с идентификатором на один или два меньше.

Результатом приведенного ниже запроса:

```sql
SELECT title, critic_score
FROM Books
WHERE critic_score IN (SELECT critic_score
                       FROM Books AS InnerBooks
                       WHERE id = (Books.id - 1) OR id = Books.id - 2);
```

является:

+------------------------+--------------+
| title                  | critic_score |
+------------------------+--------------+
| The Catcher in the Rye | 99           |
| It                     | 39           |
+------------------------+--------------+
**Примечание 4.** Использование коррелированных подзапросов может вызвать проблемы с производительностью, так как коррелированный подзапрос выполняется для каждой записи основного запроса отдельно.

<hr>

[Содержание](#содержание)

# 6.3 Подзапросы. Часть 3

##  Используемая база данных
Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из трех таблиц и содержит информацию о книгах, размещенных в некоторой электронной библиотеке. Также база данных включает информацию о пользователях библиотеки и арендованных ими книгах.

Первая таблица. Информация о размещенных в библиотеке книгах располагается в таблице Books, которая имеет следующий вид:

+----+------------------------------------------+-----------------+
| id | title                                    | author          |
+----+------------------------------------------+-----------------+
| 1  | Fight Club                               | Chuck Palahniuk |
| 2  | The Green Mile                           | Stephen King    |
| 3  | The Lord of the Rings                    | J.R.R. Tolkien  |
| 4  | It                                       | Stephen King    |
| 5  | Harry Potter and the Prisoner of Azkaban | J.K. Rowling    |
+----+------------------------------------------+-----------------+
Первое поле этой таблицы содержит идентификатор книги, второе — название, третье — информацию об авторе.

Вторая таблица. Информация о пользователях библиотеки располагается в таблице Users, которая имеет следующий вид:

+----+---------+-------------+
| id | name    | surname     |
+----+---------+-------------+
| 1  | Keanu   | Reeves      |
| 2  | Matthew | McConaughey |
| 3  | Thomas  | Hanks       |
+----+---------+-------------+
Первое поле этой таблицы содержит идентификатор пользователя, второе — имя, третье — фамилию.

Третья таблица. Информация об аренде книг, то есть о том, какой пользователь какую книгу взял почитать, располагается в таблице BooksRental, которая имеет следующий вид:

+----+---------+---------+
| id | book_id | user_id |
+----+---------+---------+
| 1  | 5       | 1       |
| 2  | 1       | 3       |
| 3  | 2       | 3       |
| 4  | 4       | 2       |
| 5  | 4       | 1       |
+----+---------+---------+
Первое поле этой таблицы содержит идентификатор аренды, второе — идентификатор арендованной книги, третье — идентификатор пользователя, арендовавшего книгу. Например, вторая запись таблицы BooksRental говорит о том, что пользователь с идентификатором 3 взял почитать книгу с идентификатором 1, то есть пользователь Thomas Hanks арендовал книгу Fight Club.

Схема базы данных

В этом уроке впервые используется несколько таблиц, между которыми существует определенная связь, поэтому здесь и далее будет предоставляться схема базы данных, которая наглядно показывает эти связи. Связи между таблицами будут изучены в следующем модуле.

![06](/SQL_for_beginners/img/06_01.svg)

Скрипт для создания таблиц `Books`, `Users` и `BooksRental`

```sql
DROP TABLE IF EXISTS BooksRental;
DROP TABLE IF EXISTS Users;
DROP TABLE IF EXISTS Books;

-- Создание таблицы Books
CREATE TABLE Books
(
    id     INT PRIMARY KEY AUTO_INCREMENT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (title, author)
VALUES ('Fight Club', 'Chuck Palahniuk'),
       ('The Green Mile', 'Stephen King'),
       ('The Lord of the Rings', 'J.R.R. Tolkien'),
       ('It', 'Stephen King'),
       ('Harry Potter and the Prisoner of Azkaban', 'J.K. Rowling');

-- Создание таблицы Users
CREATE TABLE Users
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(30),
    surname VARCHAR(30)
);

INSERT INTO Users (name, surname)
VALUES ('Keanu', 'Reeves'),
       ('Matthew', 'McConaughey'),
       ('Thomas', 'Hanks');

-- Создание таблицы BooksRental
CREATE TABLE BooksRental
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    book_id INT,
    user_id INT
);

INSERT INTO BooksRental (book_id, user_id)
VALUES (5, 1),
       (1, 3),
       (2, 3),
       (4, 2),
       (4, 1);
```

<hr>

[Содержание](#содержание)

## Подзапросы при работе с несколькими таблицами

До текущего момента во всех примерах и задачах мы использовали базы данных, состоящие лишь из одной таблицы. Однако на практике базы данных включают куда большее количество таблиц. Мы довольно подробно изучили способы извлечения и обработки информации из одной таблицы, поэтому в этом уроке приступим к работе с несколькими таблицами одновременно.

Предположим, что нам необходимо извлечь данные о том, сколько пользователей взяли почитать книгу под названием `It`. Нужная нам информация содержится в таблице `BooksRental`, однако получить ее сразу мы не можем, поскольку нам неизвестен идентификатор искомой книги. Поэтому сперва нам необходимо обратиться к таблице `Books` и определить идентификатор книги под названием `It`, а затем, используя полученный идентификатор, извлечь из таблицы `BooksRental` все записи, связанные с нужной книгой, и посчитать их количество.

Результатом приведенного ниже запроса:

```sql
SELECT COUNT(*) AS num_of_users
FROM BooksRental
WHERE book_id = (SELECT id
                 FROM Books
                 WHERE title = 'It');
```

является:

```
+--------------+
| num_of_users |
+--------------+
| 2            |
+--------------+
```

Здесь подзапрос сначала извлекает из таблицы Books идентификатор книги под названием `It`:

```
+----+
| id |
+----+
| 4  |
+----+
```

Затем основной запрос извлекает из таблицы `BooksRental` те записи, значение поля `book_id` которых равняется идентификатору, полученному подзапросом (`4`), и выполняет их подсчет.

Фактически запрос выше эквивалентен следующему запросу:

```sql
SELECT COUNT(*) AS num_of_users
FROM BooksRental
WHERE book_id = 4;
```

Работа с несколькими таблицами практически не отличается от работы с одной таблицей. Разница заключается лишь в том, что для извлечения нужной информации из таблицы необходимо пользоваться данными не из этой же таблицы, а из других.

Теперь рассмотрим более сложную задачу. Представим, что нам необходимо извлечь данные о пользователях, которые взяли почитать книгу под названием `It`. Как и в прошлом случае, начать следует с определения идентификатора искомой книги. Затем, используя полученный идентификатор книги, необходимо узнать идентификаторы пользователей, которые арендовали данную книгу. После определения идентификаторов необходимых нам пользователей остается лишь получить всю требуемую информацию о них.

Результатом приведенного ниже запроса:

```sql
SELECT name, surname
FROM Users
WHERE id IN (SELECT user_id                           -- второй подзапрос
             FROM BooksRental
             WHERE book_id = (SELECT id               -- первый подзапрос
                              FROM Books
                              WHERE title = 'It'));
```

является:

```
+---------+-------------+
| name    | surname     |
+---------+-------------+
| Keanu   | Reeves      |
| Matthew | McConaughey |
+---------+-------------+
```

В данном примере сначала первый подзапрос извлекает из таблицы `Books` идентификатор книги под названием `It`:

```
+----+
| id |
+----+
| 4  |
+----+
```

После этого второй подзапрос извлекает из таблицы `BooksRental` поле `user_id`, при этом оставляя только те записи, значение поля `book_id` которых равняется полученному предыдущим подзапросом идентификатору (`4`):

```
+---------+
| user_id |
+---------+
| 2       |
| 1       |
+---------+
```

Наконец основной запрос извлекает из таблицы `Users` те записи, значение поля `id` которых содержится в полученной вторым подзапросом таблице, то есть равняется 2 или 1.

Фактически запрос выше эквивалентен следующему запросу:

```sql
SELECT name, surname
FROM Users
WHERE id IN (2, 1);
```

Некоррелированные подзапросы, если их несколько, всегда обрабатываются начиная с самого вложенного, то есть в направлении изнутри наружу.

В качестве заключительного примера извлечем данные о пользователях и о количестве книг, арендованных каждым из них. Данные о пользователях мы можем получить из таблицы `Users`, данные об арендованных книгах — из таблицы `BooksRental`. Поэтому, по сути, нам требуется лишь извлекать все записи из таблицы `Users` и при извлечении каждой записи дополнительно обращаться к таблице `BooksRental`.

Результатом приведенного ниже запроса:

```sql
SELECT name, surname,
      (SELECT COUNT(*)
       FROM BooksRental
       WHERE user_id = Users.id) AS num_of_books
FROM Users;
```

является:

```
+---------+-------------+--------------+
| name    | surname     | num_of_books |
+---------+-------------+--------------+
| Keanu   | Reeves      | 2            |
| Matthew | McConaughey | 1            |
| Thomas  | Hanks       | 2            |
+---------+-------------+--------------+
```

Подзапрос в данном примере отличается от предыдущих тем, что он является коррелированным, а также тем, что он используется в качестве вычисляемого поля. Поскольку запрос коррелированный, он выполняется для каждой извлекаемой основным запросом записи отдельно.

Например, если основной запрос извлекает следующую запись:

```
+---------+---------+-------------+
| 2       | Matthew | McConaughey |
+---------+---------+-------------+
```

то в подзапросе значение `Users.id` на данный момент равняется `2`, и выполнение подзапроса происходит с учетом именно этого значения, вследствие чего подзапросом возвращается количество записей в таблице `BooksRental`, значение поля `user_id` которых равняется `2`:

```
+----------+
| COUNT(*) |
+----------+
| 1        |
+----------+
```

Далее это значение присваивается извлекаемой основным запросом записи в качестве его значения поля `num_of_books`. Аналогичный алгоритм выполняется для всех остальных записей, извлекаемых основным запросом, для определения их значений поля `num_of_books`.

<hr>

[Содержание](#содержание)

# 6.4 Решение задач


<hr>

[Содержание](#содержание)