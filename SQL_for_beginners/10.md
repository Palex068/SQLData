# 10. Пользовательские функции и хранимые процедуры

## Содержание

+ [10.1 Переменные](#101-переменные)
    + [Переменные](#переменные)
    + [Пользовательские переменные](#пользовательские-переменные)
        + [Присвоение переменным данных из таблиц](#присвоение-переменным-данных-из-таблиц)
    + [Системные переменные](#системные-переменные)
+ [10.2 Пользовательские функции. Часть 1](#102-пользовательские-функции-часть-1)
    + [Пользовательские функции](#пользовательские-функции)
    + [Создание пользовательских функций](#создание-пользовательских-функций)
    + [Примеры использования пользовательских функций](#примеры-использования-пользовательских-функций)
        + [Числовые пользовательские функции](#числовые-пользовательские-функции)
        + [Строковые пользовательские функции](#строковые-пользовательские-функции)
        + [Пользовательские функции для работы с датой](#пользовательские-функции-для-работы-с-датой)
        + [Пользовательские функции с использованием запросов](#пользовательские-функции-с-использованием-запросов)
    + [Локальные переменные внутри пользовательских функций](#локальные-переменные-внутри-пользовательских-функций)
+ [10.3 Пользовательские функции. Часть 2](#103-пользовательские-функции-часть-2)
    + [Условная конструкция `IF-ELSEIF-ELSE`](#условная-конструкция-if-elseif-else)
        + [Примеры использования конструкции `IF-ELSEIF-ELSE`](#примеры-использования-конструкции-if-elseif-else)
    + [Цикл `WHILE`](#цикл-while)
        + [Примеры использования цикла WHILE](#примеры-использования-цикла-while)
+ [10.4 Хранимые процедуры](#104-хранимые-процедуры)

[Оглавление](/SQL_for_beginners/README.MD)

# 10.1 Переменные

Урок посвящен пользовательским и системным переменным.

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем `Books`, которая содержит информацию о десяти различных книгах, размещенных в некотором интернет-магазине:

```
+----+------------------------------------------+---------------------+-------+
| id | title                                    | author              | price |
+----+------------------------------------------+---------------------+-------+
| 1  | The Shining                              | Stephen King        | 7.99  |
| 2  | Fight Club                               | Chuck Palahniuk     | 9.99  |
| 3  | The Catcher in the Rye                   | J.D. Salinger       | 3.49  |
| 4  | The Green Mile                           | Stephen King        | 15.99 |
| 5  | The Great Gatsby                         | F. Scott Fitzgerald | 7.99  |
| 6  | The Lord of the Rings                    | J.R.R. Tolkien      | 19.99 |
| 7  | It                                       | Stephen King        | 12.99 |
| 8  | The Silmarillion                         | J.R.R. Tolkien      | 11.99 |
| 9  | Haunted                                  | Chuck Palahniuk     | 13.99 |
| 10 | Harry Potter and the Prisoner of Azkaban | J.K. Rowling        | 9.99  |
+----+------------------------------------------+---------------------+-------+
```

Первое поле этой таблицы содержит идентификатор книги, второе — название, третье — данные об авторе, четвертое — цену книги в долларах.

Скрипт для создания таблицы `Books`

```sql
DROP TABLE IF EXISTS Books;
CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author    VARCHAR(30),
    price     DECIMAL(10, 2)
);

INSERT INTO Books (title, author, price)
VALUES ('The Shining', 'Stephen King', 7.99),
       ('Fight Club', 'Chuck Palahniuk', 9.99),
       ('The Catcher in the Rye', 'J.D. Salinger', 3.49),
       ('The Green Mile', 'Stephen King', 15.99),
       ('The Great Gatsby', 'F. Scott Fitzgerald', 7.99),
       ('The Lord of the Rings', 'J.R.R. Tolkien', 19.99),
       ('It', 'Stephen King', 12.99),
       ('The Silmarillion', 'J.R.R. Tolkien', 11.99),
       ('Haunted', 'Chuck Palahniuk', 13.99),
       ('Harry Potter and the Prisoner of Azkaban', 'J.K. Rowling', 9.99);
```

<hr>

[Содержание](#содержание)

## Переменные

**Переменная** в программировании — это именованная область памяти, которая хранит определенные данные и позволяет неоднократно к ним обращаться. С помощью переменных можно сохранять значения, полученные во время промежуточных вычислений, выполнять операции с этими значениями и передавать их между различными частями программы.

Каждая переменная имеет **уникальное имя**, по которому к ней можно обращаться. Конкретные данные, которые хранятся в переменной, называют **значением** переменной.

Многие языки программирования поддерживают работу с переменными, и SQL не является исключением. В SQL выделяют два типа переменных:
+ **системные** и
+ **пользовательские**. 

Системные переменные используются для хранения технической информации и для настройки различных аспектов работы СУБД. Примером системной переменной является переменная `version`, с помощью которой можно узнать версию установленной СУБД.

Пользовательские переменные, в отличие от системных, определяются программистом, а не СУБД, и используются при составлении запросов для определенных целей. Например, они могут хранить значения, полученные во время выполнения промежуточных запросов, или различного вида константные значения, которые часто повторяются в запросах.

<hr>

[Содержание](#содержание)

## Пользовательские переменные

Создание пользовательской переменной и присвоение ей значения выполняется с помощью операторов `SET` и `:=`. Сначала следует оператор `SET`, а затем между оператором `:=` указываются имя переменной и ее значение.

В результате выполнения приведенного ниже запроса:

```sql
SET @variable := 1;
```

будет создана пользовательская переменная с именем `variable` и значением `1`.

Обратите внимание, что перед именем пользовательской переменной располагается знак `@`. Его необходимо использовать при создании любой пользовательской переменной и при каждом обращении к ней, поскольку он подсказывает СУБД о том, что следующее за знаком `@` имя следует расценивать исключительно как имя пользовательской переменной, а не поля, таблицы или какого-либо другого объекта.

Имя пользовательской переменной может включать буквенно-цифровые символы, точку (`.`), нижнее подчеркивание (`_`) и знак доллара (`$`). Максимальное количество символов в имени переменной равняется `64`.

Чтобы воспользоваться пользовательской переменной после ее определения достаточно обратиться к ней по ее имени.

Результатом приведенного ниже запроса:

```sql
SET @variable := 1;
    
SELECT @variable;
```

является:

```
+-----------+
| @variable |
+-----------+
| 1         |
+-----------+
```

Значением пользовательской переменной необязательно должно быть явно определенное значение, это может быть результат некоторого вычисления или возвращаемое значение функции.

Результатом приведенного ниже запроса:

```sql
SET @variable := SQRT(2);
    
SELECT @variable;
```

является:

```
+--------------------+
| @variable          |
+--------------------+
| 1.4142135623730951 |
+--------------------+
```

Пользовательские переменные нечувствительны к регистру, поэтому, например, к переменной с именем `variable` можно обратиться как с использованием имени `variable`, так и `Variable` или `VARIABLE`. 

Результатом приведенного ниже запроса:

```sql
SET @variable := 1;
    
SELECT @variable, @Variable, @VARIABLE;
```

является:

```
+-----------+-----------+-----------+
| @variable | @Variable | @VARIABLE |
+-----------+-----------+-----------+
| 1         | 1         | 1         |
+-----------+-----------+-----------+
```

Внутри одного блока `SET` можно определить как одну пользовательскую переменную, так и несколько. Во втором случае достаточно перечислить определение каждой переменной через запятую.

В результате выполнения приведенного ниже запроса:

```sql
SET @variable1 := 1,
    @variable2 := 2;
```

будут созданы пользовательские переменные с именами `variable1` и `variable2` и значениями 1 и 2 соответственно.

Пользовательские переменные могут участвовать в математических выражениях, операциях сравнения, передаваться функциям в качестве аргументов и использоваться в контексте запроса как любые другие значения.

Результатом приведенного ниже запроса:

```sql
SET @min_price := 7.99,
    @max_price := 9.99;
    
SELECT title, price
FROM Books
WHERE price BETWEEN @min_price AND @max_price;
```

является:

```
+------------------------------------------+-------+
| title                                    | price |
+------------------------------------------+-------+
| The Shining                              | 7.99  |
| Fight Club                               | 9.99  |
| The Great Gatsby                         | 7.99  |
| Harry Potter and the Prisoner of Azkaban | 9.99  |
+------------------------------------------+-------+
```

Запрос выше извлекает данные о тех книгах, цена которых заключена между 7.99 и 9.99 долларами, при этом левая граница цены определяется переменной `@min_price`, а правая — `@max_price`. В данном случае использование пользовательских переменных удобно тем, что при необходимости изменить правую или левую границу цены будет достаточно изменить значение соответствующей переменной, не изменяя при этом сам извлекающий запрос.

<hr>

[Содержание](#содержание)

### Присвоение переменным данных из таблиц

Значением пользовательской переменной может являться не только вычисляемое значение, но и результат выполнения запроса.

Результатом приведенного ниже запроса:

```sql
SET @min_price := (SELECT MIN(price)
                   FROM Books);
    
SELECT @min_price;
```

является: 

```
+------------+
| @min_price |
+------------+
| 3.49       |
+------------+
```

В примере выше определяется переменная `@min_price`, которой в качестве значения присваивается минимальное значение поля `price` таблицы `Books`. Обратите внимание, что если при определении значения пользовательской переменной используется запрос, то он должен быть заключен в круглые скобки.

Запрос, определяющий значение пользовательской переменной всегда должен возвращать одиночное значение (одно поле и одна запись), в противном случае произойдет ошибка.

Результатом приведенного ниже запроса:

```sql
SET @min_price := (SELECT price
                   FROM Books);
    
SELECT @min_price;
```

является ошибка:

```
ERROR 1242: Subquery returns more than 1 row
```

Определить пользовательскую переменную можно прямо внутри извлекающего запроса в блоке оператора `SELECT` без использования ключевого слова `SET`.

Результатом приведенного ниже запроса:

```sql
SELECT MIN(price) INTO @min_price
FROM Books;

SELECT @min_price;
```

является:

```
+------------+
| @min_price |
+------------+
| 3.49       |
+------------+
```

Внутри одного блока `SELECT` можно определить как одну пользовательскую переменную, так и несколько.

Результатом приведенного ниже запроса:

```sql
SELECT MIN(price), MAX(price) INTO @min_price, @max_price
FROM Books;

SELECT @min_price, @max_price;
```

является:

```
+------------+------------+
| @min_price | @max_price |
+------------+------------+
| 3.49       | 19.99      |
+------------+------------+
```

Обратите внимание на то, что при определении пользовательских переменных с помощью оператора `SELECT`, запрос всегда должен возвращать одну запись, в противном случае произойдет ошибка.

Результатом приведенного ниже запроса:

```sql
SELECT price INTO @min_price
FROM Books;

SELECT @min_price;
```

является ошибка:

```
ERROR 1172: Result consisted of more than one row
```

<hr>

[Содержание](#содержание)

## Системные переменные

Системные переменные используются для хранения технической информации и настройки параметров СУБД в соответствии с требованиями конкретного пользователя или приложения. Например, уже упомянутая ранее системная переменная `version` используется для получения версии установленной СУБД, а, скажем, переменная sort_buffer_size определяет размер [буфера](https://ru.wikipedia.org/wiki/Буфер_(информатика)), выделяемого при выполнении операций сортировки.

Как и в случае с пользовательскими переменными, при обращении к системным переменным используется специальный префикс из двух знаков `@`, который подсказывает СУБД о том, что следующее за знаками имя следует воспринимать исключительно как имя системной переменной.

Результатом приведенного ниже запроса:

```sql
SELECT @@version;
```

является (может отличаться): 

```
+-----------+
| @@version |
+-----------+
| 8.0.27    |
+-----------+
```

Запрос выше обращается к системной переменной с именем `version` и извлекает ее значение.

Системные переменные делятся на два вида:
+ **глобальные** и
+ **сессионные**. 

Глобальные переменные определяет администратор базы данных. Такие переменные создаются во время запуска базы данных, и для всех пользователей, которые в будущем подключатся к ней для работы, значения глобальных переменных будут равны и изменить их они не смогут.

Сессионные переменные создаются во время каждого подключения к базе данных, и их значения пользователям изменять допускается. Важно понимать, что сессионные переменные создаются для каждого подключения отдельно, и если один пользователь изменит значение сессионной переменной, то у других пользователей оно не изменится.

С полным списком системных переменных и их описанием можно ознакомиться по [ссылке](https://vds-admin.ru/mysql/sistemnye-peremennye-mysql-servera-fail-mycnf#time_format).

Обладая правами администратора, с системной переменной можно работать как глобально, так и сессионно. Чтобы определить значение глобальной переменной, при обращении к ней перед именем необходимо указать префикс `global.`.

В результате выполнения приведенного ниже запроса:

```sql
SET @@global.sort_buffer_size := 262146;
```

значение глобальной переменной `sort_buffer_size` будет равняться `262146`.

При изменении глобальной переменной префикс `global`. необходим по той причине, что по умолчанию обращение происходит к сессионной переменной, и если, например, в запросе выше данный префикс убрать, то значение переменной `@@sort_buffer_size` будет изменено лишь в рамках сессии, даже если запрос выполняется администратором.

В результате выполнения приведенного ниже запроса:

```sql
SET @@sort_buffer_size := 262146;
```

значение сессионной переменной `sort_buffer_size` будет равняться `262146`.

Указать, что обращение происходит именно к сессионной переменной, можно не только опустив префикс `global.`, но и добавив префикс `session.`.

В результате выполнения приведенного ниже запроса:

```sql
SET @@session.sort_buffer_size := 262146;
```

значение сессионной переменной `sort_buffer_size` будет равняться `262146`.

Используя префиксы `global.` и `session.`, можно получить как глобальное значение системной переменной, так и сессионное. 

Результатом приведенного ниже запроса:

```sql
SET @@session.sort_buffer_size := 262146;

SELECT @@global.sort_buffer_size,     -- глобальное значение
       @@session.sort_buffer_size;    -- сессионное значение
```

является:

```
+---------------------------+----------------------------+
| @@global.sort_buffer_size | @@session.sort_buffer_size |
+---------------------------+----------------------------+
| 262144                    | 262146                     |
+---------------------------+----------------------------+
```

<hr>

[Содержание](#содержание)

## Примечания 1

**Примечание 1.** Попытка определить пользовательскую переменную, имя которой совпадает с именем существующей переменной, приведет к переопределению переменной, а не к ошибке.

Результатом приведенного ниже запроса:

```sql
SET @variable := 1;
SET @variable := 2;

SELECT @variable;
```

является:

```
+-----------+
| @variable |
+-----------+
| 2         |
+-----------+
```

**Примечание 2.** Пользовательские переменные нельзя использовать в блоке оператора `LIMIT` для ограничения количества извлекаемых записей.

Результатом приведенного ниже запроса:

```sql
SET @limitvalue := 5;

SELECT *
FROM Books
LIMIT @limitvalue;
```

является ошибка:

```
ERROR 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '@limitvalue' at line 3
```

**Примечание 3.** Пользовательская переменная, определенная одним пользователем, не видна другим пользователям. Другими словами, пользовательская переменная является специфичной для сессии.

**Примечание 4.** Значением пользовательской переменной может быть значение из ограниченного набора типов данных: целое число, число с плавающей точкой, число с фиксированной точкой, строка или значение `NULL`. Если переменной присваивается значение иного типа, например, дата, то оно автоматически будет преобразовано в строковое.

**Примечание 5.** При определении пользовательской переменной с помощью ключевого слова `SET` допустимо использовать оператор `=`.

В результате выполнения приведенного ниже запроса:

```sql
SET @variable = 1;
```

будет создана пользовательская переменная с именем `variable` и значением `1`.

<hr>

[Содержание](#содержание)


# 10.2 Пользовательские функции. Часть 1

Урок посвящен пользовательским функциям и примерам их использования.

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем `Math`, которая содержит информацию об оценках студентов за итоговый экзамен по математике:

```
+----+--------+----------+-------+
| id | name   | surname  | grade |
+----+--------+----------+-------+
| 1  | Flash  | Thompson | 2     |
| 2  | Peter  | Parker   | 5     |
| 3  | Mary   | Jane     | 2     |
| 4  | Gwen   | Stacy    | 4     |
| 5  | Harry  | Osborn   | 5     |
| 6  | Ben    | Reilly   | 1     |
| 7  | Miles  | Morales  | 5     |
| 8  | John   | Jameson  | 1     |
| 9  | Curtis | Connors  | 4     |
| 10 | Edward | Brock    | 3     |
+----+--------+----------+-------+
```

Первое поле этой таблицы содержит идентификатор студента, второе — имя, третье — фамилию, четвертое — оценку по пятибалльной шкале.

Скрипт для создания таблицы `Math`

```sql
DROP TABLE IF EXISTS Math;
CREATE TABLE Math
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(20),
    surname VARCHAR(20),
    grade   INT
);

INSERT INTO Math (name, surname, grade)
VALUES ('Flash', 'Thompson', 2),
       ('Peter', 'Parker', 5),
       ('Mary', 'Jane', 2),
       ('Gwen', 'Stacy', 4),
       ('Harry', 'Osborn', 5),
       ('Ben', 'Reilly', 1),
       ('Miles', 'Morales', 5),
       ('John', 'Jameson', 1),
       ('Curtis', 'Connors', 4),
       ('Edward', 'Brock', 3);
```

<hr>

[Содержание](#содержание)

## Пользовательские функции

В SQL реализовано множество полезных функций, с помощью которых можно выполнять практически любые манипуляции с данными:
+ переводить числа из одной системы счисления в другую,
+ объединять несколько строковых значений,
+ получать отдельные компоненты даты и времени, и так далее. 

Однако на этом возможности SQL не заканчиваются, поскольку язык позволяет создавать свои функции и самостоятельно определять их логику.

Функции, которые не являются встроенными, а определены пользователем, называются **пользовательскими**.

Пользовательские функции могут быть применимы для решения совершенно разных задач. Например, если внутри какого-либо запроса приходится выполнять объемные математические вычисления, то будет целесообразно определить собственную функцию и выполнять их внутри нее, поскольку подобное решение приведет к визуальному упрощению исходного запроса.

В зависимости от поведения, пользовательские функции делятся на два вида: 
+ **детерминированные** и
+ **недетерминированные**. 

Если функция при одних и тех же входных данных возвращает один и тот же результат, ее называют детерминированной. Если же при одних и тех же входных данных функция может вернуть разные результаты, ее называют недетерминированной.

Примером детерминированной пользовательской функции может являться функция, которая выполняет сложение двух чисел, недетерминированной — функция, которая возводит число в случайную степень.

<hr>

[Содержание](#содержание)

## Создание пользовательских функций

Общий шаблон для создания пользовательской функции имеет следующий вид:

```sql
DELIMITER //
CREATE FUNCTION <имя функции>(<имя 1 параметра и его тип>, <имя 2 параметра и его тип>, ...)
RETURNS <тип возвращаемого значения>
<вид функции: детерминированная или недетерминированная>
BEGIN
    <тело функции>;
    RETURN <возвращаемое значение>;
END //
DELIMITER ;
```

Несложно заметить, что создание пользовательской функции похоже на создание триггера, поскольку начинается с того же ключевого слова `DELIMITER`, с помощью которого выполняется изменение разделителя на двойной слеш (`//`). Далее следует оператор `CREATE FUNCTION`, после которого указывается имя функции. Затем в скобках через запятую выполняется определение каждого параметра функции, которое включает его имя и тип данных.

Практически каждая функция работает с определенными значениями, которые передаются ей при вызове. Для того чтобы внутри функции обращаться к этим значениям, используются обычные переменные, которые и называют параметрами.

Например, если часть, определяющая параметры функции, выглядит следующим образом:

```sql
(x INT, y INT)
```

то это говорит о том, что функция принимает два целочисленных аргумента, первый из которых внутри функции доступен по имени `x`, второй — по имени `y`.

Типы данных, указанные рядом с параметрами функции, необязательно должны совпадать с типами фактических значений, которые будут переданы в функцию, но должны быть совместимы.

После определения имени функции и всех ее параметров следует ключевое слово `RETURNS`, за которым указывается тип возвращаемого функцией значения. Затем определяется вид функции: детерминированная или недетерминированная. Если функция является детерминированной, указывается ключевое слово `DETERMINISTIC`, если недетерминированной — `NOT DETERMINISTIC`.

Если используется пара ключевых слов `NOT DETERMINISTIC`, обязательно нужно пояснить, почему функция является недетерминированной. Если функция работает с информацией, хранящейся в таблицах базы данных, после `NOT DETERMINISTIC` с новой строки необходимо добавить `READS SQL DATA`. Если функция не обращается к таблицам базы данных, но при этом выполняет вычисления со случайным результатом, после `NOT DETERMINISTIC` с новой строки необходимо добавить `NO SQL`.

Например, если часть, определяющая вид функции, выглядит следующим образом:

```sql
NOT DETERMINISTIC
READS SQL DATA
```

то это говорит о том, что функция является недетерминированной, потому что работает с информацией, хранящейся в таблицах базы данных, которая всегда может измениться.

Внутрь последующего блока `BEGIN END` помещается тело функции, которое и определяет ее поведение. Тело функции может включать вычисления на основе переданных аргументов, определения вспомогательных переменных, а также обращения к таблицам базы данных. Следом за телом функции внутри блока `BEGIN END` располагаются оператор `RETURN` и возвращаемое значение функции. Следует заметить, что возвращаемое функцией значение должно быть одиночным, а также иметь тип данных, совместимый с тем, что был указан после ключевого слова `RETURNS`. Завершается создание функции обновленным разделителем `//` и возвратом к стандартному разделителю в виде символа `;`.

<hr>

[Содержание](#содержание)

## Примеры использования пользовательских функций

Для лучшего понимания синтаксиса создания пользовательских функций рассмотрим несколько примеров. Обратим внимание на функции, которые выполняют различные вычисления с числами, строками, датами, а также на те функции, что дополнительно обращаются к таблицам базы данных.

<hr>

[Содержание](#содержание)

### Числовые пользовательские функции

**Пример 1.** Создадим пользовательскую функцию `IS_EVEN()` для определения того, является ли число четным. Функция будет принимать в качестве аргумента целое число и возвращать число `1`, если оно является четным, или 0 в противном случае.

Результатом приведенного ниже запроса:

```sql
DELIMITER //
CREATE FUNCTION IS_EVEN(number INT)
RETURNS INT
DETERMINISTIC
BEGIN
    RETURN IF(number MOD 2 = 0, 1, 0);
END //
DELIMITER ;

SELECT IS_EVEN(10),
       IS_EVEN(15);
```

является:

```
+-------------+-------------+
| IS_EVEN(10) | IS_EVEN(15) |
+-------------+-------------+
| 1           | 0           |
+-------------+-------------+
```

Итак, в данном примере создается пользовательская функция с именем `IS_EVEN`. Как видно из определения, она принимает в качестве аргумента одно целочисленное значение, для обращения к которому внутри функции используется имя `number`. Тип возвращаемого значения функции также является целочисленным. Внутри тела функции переданное значение делится с остатком на `2`, и если остаток от деления равен нулю, функция возвращает единицу, характеризуя значение как четное, в противном случае функция возвращает ноль.

Завершается пример вызовом функции `IS_EVEN()` с четным и нечетным аргументами. Для первого аргумента, как и положено, функция возвращает единицу, для второго — ноль.

**Пример 2.** Создадим пользовательскую функцию `VECTOR_ABS()` для вычисления модуля вектора. Функция будет принимать в качестве аргументов целочисленные координаты вектора по осям $x$ и $y$ и возвращать его модуль.

Результатом приведенного ниже запроса:

```sql
DELIMITER //
CREATE FUNCTION VECTOR_ABS(x INT, y INT)
RETURNS FLOAT
DETERMINISTIC
BEGIN
    RETURN SQRT(POW(x, 2) + POW(y, 2));
END //
DELIMITER ;

SELECT VECTOR_ABS(3, 4),
       VECTOR_ABS(6, 8);
```

является:

```
+------------------+------------------+
| VECTOR_ABS(3, 4) | VECTOR_ABS(6, 8) |
+------------------+------------------+
| 5.0              | 10.0             |
+------------------+------------------+
```

<hr>

[Содержание](#содержание)

### Строковые пользовательские функции

Пример. Создадим пользовательскую функцию `CAPITALIZE()` для записи строки с заглавной буквы. Функция будет принимать в качестве аргумента строку, переводить ее первый символ в верхний регистр, а все остальные — в нижний, и возвращать полученный результат.

Результатом приведенного ниже запроса:

```sql
DELIMITER //
CREATE FUNCTION CAPITALIZE(string TEXT)
RETURNS TEXT
DETERMINISTIC
BEGIN
    RETURN CONCAT(UPPER(LEFT(string, 1)), LOWER(SUBSTRING(string, 2)));
END //
DELIMITER ;

SELECT CAPITALIZE('beegeek'),
       CAPITALIZE('BeeGeek'),
       CAPITALIZE('BEEGEEK');
```

является:

```
+-----------------------+-----------------------+-----------------------+
| CAPITALIZE('beegeek') | CAPITALIZE('BeeGeek') | CAPITALIZE('BEEGEEK') |
+-----------------------+-----------------------+-----------------------+
| Beegeek               | Beegeek               | Beegeek               |
+-----------------------+-----------------------+-----------------------+
```

<hr>

[Содержание](#содержание)

### Пользовательские функции для работы с датой

**Пример.** Создадим пользовательскую функцию `NEXT_DAY()` для получения следующего дня. Функция будет принимать в качестве аргумента дату, прибавлять к ней `1` день и возвращать полученный результат.

Результатом приведенного ниже запроса:

```sql
DELIMITER //
CREATE FUNCTION NEXT_DAY(day DATE)
RETURNS DATE
DETERMINISTIC
BEGIN
    RETURN day + INTERVAL 1 DAY;
END //
DELIMITER ;

SELECT NEXT_DAY('2023-10-10'),
       NEXT_DAY('2023-12-31');
```

является:

```
+------------------------+------------------------+
| NEXT_DAY('2023-10-10') | NEXT_DAY('2023-12-31') |
+------------------------+------------------------+
| 2023-10-11             | 2024-01-01             |
+------------------------+------------------------+
```

<hr>

[Содержание](#содержание)

### Пользовательские функции с использованием запросов

Пример. Создадим пользовательскую функцию `STUDENTS_WITH_GRADE()` для определения количества студентов в таблице `Math`, имеющих определенную оценку. Функция будет принимать в качестве аргумента оценку по пятибалльной шкале, вычислять количество студентов, оценка которых совпадает с переданной, и возвращать полученный результат.

Результатом приведенного ниже запроса:

```sql
DELIMITER //
CREATE FUNCTION STUDENTS_WITH_GRADE(score INT)
RETURNS INT
NOT DETERMINISTIC
READS SQL DATA
BEGIN
    RETURN (SELECT COUNT(*)
            FROM Math
            WHERE grade = score);
END //
DELIMITER ;

SELECT STUDENTS_WITH_GRADE(4),
       STUDENTS_WITH_GRADE(5);
```

является:

```
+------------------------+------------------------+
| STUDENTS_WITH_GRADE(4) | STUDENTS_WITH_GRADE(5) |
+------------------------+------------------------+
| 2                      | 3                      |
+------------------------+------------------------+
```

Функция `STUDENTS_WITH_GRADE()` отличается от всех предыдущих тем, что ее возвращаемое значение определяется путем выполнения запроса, который обращается к таблице `Math` и определяет, сколько в ней записей удовлетворяют определенному условию. Обратите внимание, что если возвращаемое значение функции вычисляется с помощью запроса, то он должен быть заключен в круглые скобки, а его результатом должно быть одиночное значение (одна запись и одно поле).

Отдельного комментария требуют параметры функции, которые используются внутри запроса. Несмотря на то что параметры не предваряются символом `@`, конфликтов имен не происходит. Например, в нашем случае параметр `score` СУБД воспринимает исключительно как параметр, а не как имя поля.

Если параметр и поле имеют одно и то же имя, то при обращении по этому имени внутри запроса обращение будет выполнено к параметру, а не к полю. Для явного обращения к полю достаточно использовать его полное имя.

<hr>

[Содержание](#содержание)

## Локальные переменные внутри пользовательских функций

Если тело пользовательской функции достаточно непростое и включает несколько этапов, то для хранения результатов промежуточных вычислений можно использовать дополнительно определенные локальные переменные. Поведение локальных переменных несколько похоже на поведение пользовательских переменных, поскольку значения им присваиваются с помощью той же связки операторов `SET` и `:=`. Однако локальные переменные имеют важную особенность: перед тем, как им присвоить значение, их необходимо определить.

Определение локальной переменной внутри функций выполняется с помощью оператора `DECLARE`, синтаксис использования которого имеет следующий вид:

```sql
DECLARE <имя переменной> <тип данных значения, хранимого в переменной>;
```

Например, создание целочисленной локальной переменной с именем `variable` внутри функции выполняется следующим образом:

```
DECLARE variable INT;
```

В качестве примера использования локальных переменных рассмотрим функцию `MIN_MAX_GRADE()`, которая определяет минимальную и максимальную оценку среди всех студентов в таблице `Math` и возвращает полученный результат в виде строки в следующем формате:

```
Lowest grade: <минимальная оценка>, Highest grade: <максимальная оценка>
```

Результатом приведенного ниже запроса:

```sql
DELIMITER //
CREATE FUNCTION MIN_MAX_GRADE()
RETURNS TEXT
NOT DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE min_grade INT;
    DECLARE max_grade INT;
    SET min_grade := (SELECT MIN(grade)
                      FROM Math);
    SET max_grade := (SELECT MAX(grade)
                      FROM Math);
    RETURN CONCAT('Lowest grade: ', min_grade, ', Highest grade: ', max_grade);
END //
DELIMITER ;

SELECT MIN_MAX_GRADE();
```

является:

```
+-----------------------------------+
| MIN_MAX_GRADE()                   |
+-----------------------------------+
| Lowest grade: 1, Highest grade: 5 |
+-----------------------------------+
```

В теле функции `MIN_MAX_GRADE()` используются две локальные переменные `min_grade` и `max_grade`, первая из которых используется для хранения минимальной оценки среди всех студентов, вторая — максимальной.

Обратите внимание, в отличие от пользовательских переменных, которые доступны в рамках всей сессии, локальные переменные доступны только в рамках функции, в которой они объявлены.

Объявление локальных переменных должно осуществляться раньше любых других операций в блоке `BEGIN END`. Другими словами, сначала необходимо объявить все переменные, а только потом выполнять вычисления, в противном случае произойдет ошибка.

Результатом приведенного ниже запроса:

```sql
DELIMITER //
CREATE FUNCTION MIN_MAX_GRADE()
RETURNS TEXT
NOT DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE min_grade INT;
    DECLARE max_grade INT;
    SET min_grade := (SELECT MIN(grade)
                      FROM Math);
    SET max_grade := (SELECT MAX(grade)
                      FROM Math);

    DECLARE result TEXT;
    SET result := CONCAT('Lowest grade: ', min_grade, ', Highest grade: ', max_grade);

    RETURN result;
END //
DELIMITER ;

SELECT MIN_MAX_GRADE();
```

является ошибка:

```
ERROR 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'DECLARE result TEXT; SET result := CONCAT('Lowest grade: ', min_grade, ', H' at line 13)
```

Если мы перенесем определение переменной `result` в начало блока `BEGIN END`, то запрос отработает без ошибок.

Результатом приведенного ниже запроса:

```sql
DELIMITER //
CREATE FUNCTION MIN_MAX_GRADE()
RETURNS TEXT
NOT DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE min_grade INT;
    DECLARE max_grade INT;
    DECLARE result TEXT;

    SET min_grade := (SELECT MIN(grade)
                      FROM Math);
    SET max_grade := (SELECT MAX(grade)
                      FROM Math);

    SET result := CONCAT('Lowest grade: ', min_grade, ', Highest grade: ', max_grade);

    RETURN result;
END //
DELIMITER ;

SELECT MIN_MAX_GRADE();
```

является:

```
+-----------------------------------+
| MIN_MAX_GRADE()                   |
+-----------------------------------+
| Lowest grade: 3, Highest grade: 5 |
+-----------------------------------+
```

<hr>

[Содержание](#содержание)

## Примечания 2

**Примечание 1.** Функции, создаваемые с помощью оператора `CREATE FUNCTION`, являются скалярными, то есть всегда возвращают единственное значение.

**Примечание 2.** При определении локальной переменной для нее можно указать значение по умолчанию, которое переменная примет сразу же после определения. Для этого после типа данных переменной необходимо указать ключевое слово `DEFAULT` и предоставить желаемое значение.

Например, создание целочисленной локальной переменной с именем `variable` и значением 0 выполняется следующим образом:

```sql
DECLARE variable INT DEFAULT 0
```

**Примечание 3.** Пользовательскую функцию можно дополнить строкой документации, которая полезна тем, что позволяет программисту сразу понять, что именно делает функция, не вдаваясь в подробности ее реализации. Для этого перед блоком `BEGIN END` необходимо указать ключевое слово `COMMENT`, а затем предоставить строку, содержащую краткое описание поведения функции.

Например, рассмотренная ранее функция `VECTOR_ABS()` может быть расширена кратким описанием следующим образом:

```sql
DELIMITER //
CREATE FUNCTION VECTOR_ABS(x INT, y INT)
RETURNS FLOAT
DETERMINISTIC
COMMENT 'Функция возвращает модуль двумерного вектора'
BEGIN
    RETURN SQRT(POW(x, 2) + POW(y, 2));
END //
DELIMITER ;

SELECT VECTOR_ABS(3, 4),
       VECTOR_ABS(6, 8);
```

**Примечание 4.** Пользовательская функция может быть удалена после создания. Для этого нужно воспользоваться оператором `DROP FUNCTION`, а затем указать имя удаляемой функции.

Например, запрос, который удаляет пользовательскую функцию `IS_EVEN()`, выглядит следующим образом:

```sql
DROP FUNCTION IS_EVEN;
```

**Примечание 5.** Пользовательские функции нечувствительны к регистру, поэтому, например, функцию с именем `IS_EVEN` можно вызвать как с использованием имени `IS_EVEN`, так и `is_EVEN` или `is_even`.

Результатом приведенного ниже запроса:

```sql
DELIMITER //
CREATE FUNCTION IS_EVEN(number INT)
RETURNS INT
DETERMINISTIC
BEGIN
    RETURN IF(number MOD 2 = 0, 1, 0);
END //
DELIMITER ;

SELECT IS_EVEN(10),
       is_EVEN(15),
       is_even(26);
```

является:

```
+-------------+-------------+-------------+
| IS_EVEN(10) | is_EVEN(15) | is_even(26) |
+-------------+-------------+-------------+
| 1           | 0           | 1           |
+-------------+-------------+-------------+
```

<hr>

[Содержание](#содержание)


# 10.3 Пользовательские функции. Часть 2

Урок посвящен условным конструкциям и циклам внутри пользовательских функций.

## Условная конструкция `IF-ELSEIF-ELSE`

Выбор определенного значения в зависимости от истинности некоторого условия является нередкой задачей, для решения которой достаточно воспользоваться функцией `IF()`, если условие для проверки всего одно, или же оператором `CASE`, если таких условий несколько. Однако если задача требует не просто выбрать значение, а выполнить какую-либо операцию, то ни функция `IF()`, ни оператор `CASE` решить ее не помогут.

При необходимости проверить одно или несколько условий и в зависимости от истинности одного из них выполнить ряд операций, скажем, присвоить значение переменной, используется условная конструкция `IF-ELSEIF-ELSE`. Синтаксис данной конструкции достаточно близок к синтаксису оператора `CASE` и по большому счету отличается лишь тем, что вместо возвращаемых значений в нем указываются целые операции.

Итак, синтаксис условной конструкции `IF-ELSEIF-ELSE` выглядит следующим образом:

```sql
IF <первое проверяемое условие> THEN
    <одна или несколько операций>;
ELSEIF <второе проверяемое условие> THEN
    <одна или несколько операций>;
ELSEIF <третье проверяемое условие> THEN
    <одна или несколько операций>;
...
ELSEIF <n-ое проверяемое условие> THEN
    <одна или несколько операций>;
ELSE <одна или несколько операций>;
END IF;
```

Конструкция начинается с ключевого слова `IF`, после которого указывается первое проверяемое условие. Следом располагается ключевое слово `THEN`, а затем одна или несколько операций, которые должны быть выполнены, если условие окажется истинным.

После блока с первым условием следуют блоки со вторым, третьим и всеми последующими условиями. Блок с каждым дополнительным условием начинается с ключевого слова `ELSEIF`, после которого указывается само условие. Следом за условием располагается все то же ключевое слово `THEN`, а затем одна или несколько операций, которые должны быть выполнены, если условие окажется истинным.

После блока с последним дополнительным условием указывается ключевое `ELSE`, а затем одна или несколько операций, которые должны быть выполнены, если ни одно рассмотренное условие не окажется истинным. Завершается условная конструкция парой ключевых слов `END IF`.

Блоки `ELSEIF`, а также блок `ELSE` являются необязательными и при необходимости могут быть опущены.

<hr>

[Содержание](#содержание)

### Примеры использования конструкции `IF-ELSEIF-ELSE`

**Пример 1.** Создадим пользовательскую функцию `IS_EVEN()` для определения того, является ли число четным. Функция будет принимать в качестве аргумента целое число и возвращать значение 1, если оно является четным, или 0 в противном случае.

Результатом приведенного ниже запроса:

```sql
DELIMITER //
CREATE FUNCTION IS_EVEN(number INT)
RETURNS INT
DETERMINISTIC
BEGIN
    DECLARE result INT;
    
    IF number MOD 2 = 0 THEN
        SET result := 1;
    ELSE
        SET result := 0;
    END IF;
    
    RETURN result;
END //
DELIMITER ;

SELECT IS_EVEN(10),
       IS_EVEN(15);
```

является:

```
+-------------+-------------+
| IS_EVEN(10) | IS_EVEN(15) |
+-------------+-------------+
| 1           | 0           |
+-------------+-------------+
```

В примере выше вновь предлагается функция `IS_EVEN()`, рассмотренная в прошлом уроке, однако в данном случае ее тело реализуется не с помощью функции `IF()`, а с помощью условной конструкции `IF-ELSEIF-ELSE`. Тело функции начинается с создания переменной `result`, которая используется для хранения результата работы функции. Значение переменной определяется с помощью условной конструкции: если число, переданное в функцию, является четным, условная конструкция присваивает переменной `result` значение `1`, в противном случае переменная принимает значение `0`. Завершается тело функции возвратом значения переменной `result`.

Условная конструкция `IF-ELSEIF-ELSE` внутри функции `IS_EVEN()` включает блоки `IF` и `ELSE`, однако несложно понять, что от блока `ELSE` можно избавиться, если сразу определить переменную `result` со значением `0`.

Результатом приведенного ниже запроса:

```sql
DELIMITER //
CREATE FUNCTION IS_EVEN(number INT)
RETURNS INT
DETERMINISTIC
BEGIN
    DECLARE result INT DEFAULT 0;
    
    IF number MOD 2 = 0 THEN
        SET result := 1;
    END IF;
    
    RETURN result;
END //
DELIMITER ;

SELECT IS_EVEN(10),
       IS_EVEN(15);
```

является: 

```
+-------------+-------------+
| IS_EVEN(10) | IS_EVEN(15) |
+-------------+-------------+
| 1           | 0           |
+-------------+-------------+
```

Здесь переменная `result` после создания принимает значение `0`. Если число, переданное в функцию `IS_EVEN()`, окажется четным, переменная изменит свое значение на `1`, в противном случае значение переменной останется неизменным и будет возвращено функцией в исходном виде.

Возврат значения с помощью оператора `RETURN` является операцией, поэтому она может быть использована в блоке какого-либо условия внутри условной конструкции `IF-ELSEIF-ELSE`. В случае с функцией `IS_EVEN()` это позволяет нам обойтись без использования переменной `result` и сразу выполнять возврат значения `1`, если переданное в функцию число является четным, или `0` в противном случае.

Результатом приведенного ниже запроса:

```sql
DELIMITER //
CREATE FUNCTION IS_EVEN(number INT)
RETURNS INT
DETERMINISTIC
BEGIN
    IF number MOD 2 = 0 THEN
        RETURN 1;
    END IF;
    
    RETURN 0;
END //
DELIMITER ;

SELECT IS_EVEN(10),
       IS_EVEN(15);
```

является: 

```
+-------------+-------------+
| IS_EVEN(10) | IS_EVEN(15) |
+-------------+-------------+
| 1           | 0           |
+-------------+-------------+
```

Обратите внимание, что тело функции может включать несколько операторов `RETURN`, однако нужно понимать, что после выполнения одного из них функция выполнит возврат значения и завершит работу, проигнорировав оставшиеся внутри тела операции.

**Пример 2.** Создадим пользовательскую функцию `ANALYSE()` для анализа числа. Функция будет принимать в качестве аргумента целое число и возвращать строку `Positive`, если оно является положительным, `Negative`, если отрицательным, и `Zero`, если число является нулем.

Результатом приведенного ниже запроса:

```sql
DELIMITER //
CREATE FUNCTION ANALYSE(number INT)
RETURNS TEXT
DETERMINISTIC
BEGIN
    IF number > 0 THEN
        RETURN 'Positive';
    ELSEIF number < 0 THEN
        RETURN 'Negative';
    ELSE
        RETURN 'Zero';
    END IF;
END //
DELIMITER ;

SELECT ANALYSE(5),
       ANALYSE(-10),
       ANALYSE(0);
```

является:

```
+------------+--------------+------------+
| ANALYSE(5) | ANALYSE(-10) | ANALYSE(0) |
+------------+--------------+------------+
| Positive   | Negative     | Zero       |
+------------+--------------+------------+
```

Пример выше демонстрирует полноценную условную конструкцию `IF-ELSEIF-ELSE` с блоками `IF`, `ELSEIF` и `ELSE`. Если переданное в функцию число является положительным, выполняется первое условие и функция возвращает строковое значение `Positive`. Если число является отрицательным, истинным становится второе условие и функция возвращает строковое значение `Negative`. В случае ложности обоих условий возвращаемым значением функции становится строка `Zero`.

<hr>

[Содержание](#содержание)

## Цикл `WHILE`

Циклы являются неотъемлемой частью практически любого языка программирования. Они позволяют повторять выполнение ряда операций до тех пор, пока истинно определенное условие. В SQL реализовано несколько видов циклов, однако мы рассмотрим наиболее важный из них — цикл `WHILE`.

Со всеми видами циклов, доступными в SQL, можно ознакомиться в статье по [ссылке](https://www.garb.ru/blog/cziklyi-v-mysql.html).

Итак, синтаксис цикла `WHILE` выглядит следующим образом:

```sql
WHILE <проверяемое условие> DO
    <тело цикла>;
END WHILE;
```

Как видно из шаблона, определение цикла начинается с ключевого слова `WHILE`, после которого указывается некоторое условие. Затем следуют ключевое слово `DO` и непосредственно тело цикла. Тело цикла представляет собой одну или несколько операций, выполнение которых и будет повторяться. Завершается определение цикла парой ключевых слов `END WHILE`.

Основная суть цикла `WHILE` заключается в том, что мы задаем некоторое условие и определяем тело цикла. Сначала происходит проверка условия, и если оно истинно, то тело цикла выполняется. Затем происходит повторная проверка условия, и если оно истинно, то тело цикла выполняется снова. Это повторяется до тех пор, пока проверяемое условие истинно. Если во время очередной проверки условие окажется ложным, цикл `WHILE` завершит свою работу.

<hr>

[Содержание](#содержание)

### Примеры использования цикла `WHILE`

**Пример 1.** Создадим пользовательскую функцию `CALCULATE_HOURS()` для подсчета количества часов. Функция будет принимать в качестве аргумента количество минут и возвращать целое количество часов, содержащееся в переданном количестве минут.

Результатом приведенного ниже запроса:

```sql
DELIMITER //
CREATE FUNCTION CALCULATE_HOURS(minutes INT)
RETURNS INT
DETERMINISTIC
BEGIN
    DECLARE result INT DEFAULT 0;                -- конечное количество часов
   
    WHILE minutes >= 60 DO                       -- проверяем, что количество минут больше или равно 60
        SET result := result + 1;                -- увеличиваем количество часов на единицу
        SET minutes := minutes - 60;             -- уменьшаем количество минут на 60 минут (1 час)
    END WHILE;
   
    RETURN result;
END //
DELIMITER ;

SELECT CALCULATE_HOURS(30),
       CALCULATE_HOURS(60),
       CALCULATE_HOURS(95),
       CALCULATE_HOURS(125);
```

является:

```
+---------------------+---------------------+---------------------+----------------------+
| CALCULATE_HOURS(30) | CALCULATE_HOURS(60) | CALCULATE_HOURS(95) | CALCULATE_HOURS(125) |
+---------------------+---------------------+---------------------+----------------------+
| 0                   | 1                   | 1                   | 2                    |
+---------------------+---------------------+---------------------+----------------------+
```

Тело функции `CALCULATE_HOURS()` начинается с определения переменной `result` со значением `0`, используемой для хранения итогового количества часов. Далее следует цикл `WHILE`, который увеличивает количество часов на единицу и уменьшает количество минут на `60` до тех пор, пока количество минут не окажется меньше `60`. Завершается тело функции возвратом вычисленного количества часов.

**Пример 2.** Создадим пользовательскую функцию `SUM_OF_DIGITS()` для суммирования цифр числа. Функция будет принимать в качестве аргумента неотрицательное целое число и возвращать сумму его цифр.

Результатом приведенного ниже запроса:

```sql
DELIMITER //
CREATE FUNCTION SUM_OF_DIGITS(number INT)
RETURNS INT
DETERMINISTIC
BEGIN
    DECLARE result INT DEFAULT 0;                -- конечная сумма
   
    WHILE number > 0 DO                          -- проверяем, что число больше нуля
        SET result := result + number MOD 10;    -- прибавляем последнюю цифру числа
        SET number := number DIV 10;             -- отсекаем последнюю цифру числа
    END WHILE;
   
    RETURN result;
END //
DELIMITER ;

SELECT SUM_OF_DIGITS(7),                        -- 7
       SUM_OF_DIGITS(91),                       -- 9 + 1
       SUM_OF_DIGITS(258),                      -- 2 + 5 + 8
       SUM_OF_DIGITS(2387);                     -- 2 + 3 + 8 + 7
```

является: 

```
+------------------+-------------------+--------------------+---------------------+
| SUM_OF_DIGITS(7) | SUM_OF_DIGITS(91) | SUM_OF_DIGITS(258) | SUM_OF_DIGITS(2387) |
+------------------+-------------------+--------------------+---------------------+
| 7                | 10                | 15                 | 20                  |
+------------------+-------------------+--------------------+---------------------+
```

**Пример 3.** Создадим пользовательскую функцию `SUM_UP_TO_N()` для суммирования чисел от `1` до `n`. Функция будет принимать в качестве аргумента целое число `n` и возвращать сумму всех целых чисел от `1` до `n` включительно.

Результатом приведенного ниже запроса:

```sql
DELIMITER //
CREATE FUNCTION SUM_UP_TO_N(n INT)
RETURNS INT
DETERMINISTIC
BEGIN
    DECLARE result INT DEFAULT 0;                -- конечная сумма
    DECLARE count INT DEFAULT 1;                 -- счетчик
   
    WHILE count <= n DO                          -- проверяем, что счетчик не больше n
        SET result := result + count;            -- прибавляем очередное натуральное число
        SET count := count + 1;                  -- увеличиваем счетчик на единицу
    END WHILE;
   
    RETURN result;
END //
DELIMITER ;

SELECT SUM_UP_TO_N(1),                          -- 1
       SUM_UP_TO_N(2),                          -- 1 + 2
       SUM_UP_TO_N(3),                          -- 1 + 2 + 3
       SUM_UP_TO_N(4),                          -- 1 + 2 + 3 + 4
       SUM_UP_TO_N(5);                          -- 1 + 2 + 3 + 4 + 5
```

является:

```
+----------------+----------------+----------------+----------------+----------------+
| SUM_UP_TO_N(1) | SUM_UP_TO_N(2) | SUM_UP_TO_N(3) | SUM_UP_TO_N(4) | SUM_UP_TO_N(5) |
+----------------+----------------+----------------+----------------+----------------+
| 1              | 3              | 6              | 10             | 15             |
+----------------+----------------+----------------+----------------+----------------+
```

<hr>

[Содержание](#содержание)

## Примечания 3

**Примечание 1.** SQL ориентирован на выполнение запросов, а не на вычисления, поэтому, несмотря на то что язык позволяет реализовывать сложные конструкции с помощью циклов и условий, рекомендуется избегать их применения ради поддержания оптимальной производительности.

**Примечание 2.** Условную конструкцию `IF-ELSEIF-ELSE` и цикл `WHILE` нельзя использовать вне функций.

**Примечание 3.** При необходимости условную конструкцию `IF-ELSEIF-ELSE` можно помещать внутрь цикла `WHILE`. Аналогичным образом можно поступать и наоборот, помещая цикл `WHILE` внутрь конструкции `IF-ELSEIF-ELSE`.

<hr>

[Содержание](#содержание)


# 10.4 Хранимые процедуры

<hr>

[Содержание](#содержание)
