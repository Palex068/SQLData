# 3  Основы языка SQL

## Содержание

+ [3.1 Типы данных](#31-типы-данных)
    + [Типы данных](#типы-данных)
    + [Строковые типы данных](#строковые-типы-данных)
    + [Числовые типы данных](#числовые-типы-данных)
    + [Типы данных даты и времени](#типы-данных-даты-и-времени)
+ [3.2 Извлечение данных](#32-извлечение-данных)
    + [Запросы и операторы](#запросы-и-операторы)
    + [Оператор SELECT](#оператор-select)
    + [Извлечение уникальных записей](#извлечение-уникальных-записей)
    + [Ограничение результатов запроса](#ограничение-результатов-запроса)
    + [Псевдонимы](#псевдонимы)
+ [3.3 Сортировка данных](#33-сортировка-данных)
    + [Оператор ORDER BY](#оператор-order-by)
+ [3.4 Фильтрация данных. Часть 1](#34-фильтрация-данных-часть-1)
    + [Оператор WHERE](#оператор-where)
    + [Операторы сравнения](#операторы-сравнения)
+ [3.5 Фильтрация данных. Часть 2](#35-фильтрация-данных-часть-2)
    + [Операторы AND и OR](#операторы-and-и-or)
    + [Оператор IN](#оператор-in)
    + [Оператор NOT](#оператор-not)
    + [Оператор NOT IN](#оператор-not-in)
+ [3.6 Фильтрация данных. Часть 3](#36-фильтрация-данных-часть-3)
    + [Метасимволы и оператор LIKE](#метасимволы-и-оператор-like)
    + [Регистрозависимость](#регистрозависимость)
+ [3.7 Создание вычисляемых полей](#37-создание-вычисляемых-полей)
    + [Вычисляемые поля]()
    + [Объединение значений полей]()
    + [Выполнение математических вычислений]()

# 3.1 Типы данных

Урок посвящен типам данных, используемым в MySQL.

## Типы данных

Типы данных играют ключевую роль в определении правил хранения и представления информации. Есть несколько причин, почему их использование является необходимым:
+ **Ограничение диапазона данных.** Типы данных позволяют определить, какие значения могут быть сохранены в определенных полях. Например, числовые поля могут принимать только числовые значения, что исключает возможность хранения текста в этих полях.
+ **Эффективное управление хранением данных.** Использование различных типов данных позволяет более компактно хранить информацию. Например, числовые значения и дата/время могут быть сохранены в более оптимизированном формате по сравнению со строковыми.
+ **Сортировка данных.** Множество типов данных позволяет определить собственные правила сравнения для каждого типа. Например, строковые значения сравниваются лексикографически, причем сравнение происходит посимвольно.

При проектировании таблиц необходимо обращать особое внимание на используемые типы данных. Некорректные типы данных могут существенно замедлить работу базы данных, а их изменение для уже имеющихся и заполненных полей может привести к потере данных.

<hr>

[Содержание](#содержание)

## Строковые типы данных

Строковые типы данных используются чаще всего. Значения, принадлежащие этим типам, обычно называют строками. К ним относятся хранимые в базах данных имена людей, их фамилии, названия городов и любая подобная текстовая информация.

В MySQL строковые значения всегда заключаются в одинарные или двойные кавычки.

Строки бывают двух видов: фиксированной и переменной длины. Строки фиксированной длины состоят из фиксированного количества символов. Например, мы можем разрешить ввод 30 символов в поле, в котором хранятся имена, или 12 символов в поле, предназначенном для хранения ИНН.

Строки переменной длины не имеют фиксированной длины и состоят ровно из того количества символов, сколько указано в них самих. Максимальное значение ограничивается конкретным типом данных.

Несмотря на то, что строки переменной длины обладают большей гибкостью и хранят столько символов, сколько необходимо, СУБД манипулирует строками фиксированной длины намного быстрее.

Существуют два основных строковых типа данных — `CHAR` и `VARCHAR`:
+ `CHAR(n)`, где n – число в диапазоне [0; 255], представляющее допустимую длину строки. Хранит строку фиксированной длины, которая задается на этапе создания таблицы. Если строка имеет длину меньше, чем n, то оставшиеся символы заполняются пробелами.
+ `VARCHAR(n)`, где n – число в диапазоне [0; 65535], представляющее допустимую длину строки. Хранит строку переменной длины, которая также задается на этапе создания таблицы. В отличие от CHAR, строка не заполняется пробелами, если ее длина меньше, чем n.

MySQL поддерживает два режима поведения при превышении указанной длины строки: строгий и нестрогий. При нестрогом режиме если длина строки превосходит значение n, указанное в `CHAR(n)` или `VARCHAR(n)`, то строка урезается до допустимой длины. В таблице ниже приведены примеры хранения строк разной длины для `CHAR(4)` и `VARCHAR(4)`.

Строка | CHAR(4) | VARCHAR(4)
-|-|-
'' | '    ' | ''
'bee' | 'bee ' | 'bee'
'geek' | 'geek' | 'geek'
'beegeek' | 'beeg' | 'beeg'

При строгом режиме вместо урезания строки возникает ошибка. MySQL по умолчанию использует строгий режим.

В отличие от типов данных `CHAR(n)` и `VARCHAR(n)`, где мы указываем максимальную длину строки (значение n), мы также можем использовать следующие типы данных:

Тип | Размер (в байтах) | Максимальное количество символов
-|-|-
`TINYTEXT` | $255$ | $255$
`TEXT` | $65535$ | $2^16 - 1$
`MEDIUMTEXT` | $16777215$ | $2^24 - 1$
`LONGTEXT` | $4294967295$ | $2^32 - 1$

Для этих типов не указывается максимальная длина, она ограничивается только самим типом данных.

<hr>

[Содержание](#содержание)

## Числовые типы данных

MySQL поддерживает все стандартные числовые типы данных SQL. Каждый из них рассчитан на хранение чисел определенного диапазона. Чем шире поддерживаемый диапазон, тем больше нужно места для хранения числа.

### Целые числа

Целые числа хранят только числа без дробной части. Они делятся на числа со знаком (`signed`) и числа без знака (`unsigned`). Типы `signed` позволяют хранить как положительные, так и отрицательные значения, а типы `unsigned` хранят только положительные числа, но поддерживают больший диапазон значений.

Тип | Размер (в байтах) | Диапазон signed | Диапазон unsigned
-|-|-|-
`TINYINT` | $1$ | [-128; 127] | [0; 255]
`SMALLINT` | $2$ | [-2^15; 2^15 - 1] | [0; 2^16 - 1]
`MEDIUMINT` | $3$ | [-2^23; 2^23 - 1] | [0; 2^24 - 1]
`INT` | $4$ | [-2^31; 2^31 - 1] | [0; 2^32 - 1]
`BIGINT` | $8$ | [-2^63; 2^63 - 1] | [0; 2^64 - 1]

Числа без знака могут быть полезны в том случае, когда необходимо хранить значения, которые заведомо не могут быть отрицательными (количество товара, возраст человека).

### Числа с плавающей точкой

Числа с плавающей точкой хранят приблизительные значения. Они не резервируют определенное количество бит для целочисленной или дробной частей, поэтому у всех значений в таблице количество цифр до и после запятой будет разным.

Тип | Размер (в байтах) | Диапазон
-|-|-
`FLOAT` | $4$ | [1.17 * 10^-38; 3.4 * 10^38]
`DOUBLE` | $8$ | [2.2 * 10^-308; 1.7 * 10^308]

### Числа с фиксированной точкой

Числа с фиксированной точкой используются для сохранения заданной точности. Такие числа резервируют определенное количество бит для целочисленной и дробной частей. Независимо от того, насколько большое или маленькое число, оно всегда будет использовать одно и то же количество бит для сохранения каждой части.

Числа с фиксированной точкой необходимы в случаях, когда важна точность, например, при работе с денежными средствами или научными и инженерными вычислениями.

В MySQL для хранения чисел с фиксированной точкой используются типы `DECIMAL(M, D)` и `NUMERIC(M, D)`. Эти типы являются синонимами, поэтому можно использовать любой из них. Диапазон значений задается параметрами M и D, где M – общее количество цифр, D – количество цифр, используемое для дробной части. Значение параметра M ограничено диапазоном [1; 65].

Например, `DECIMAL(5, 2)` означает, что в поле могут храниться числа, имеющие максимум 5 цифр, причем 2 из них отведены под десятичную часть. Другими словами, в этом поле могут храниться значения в диапазоне [-999.99; 999.99].

Если для типа `DECIMAL` не указать параметр D или сделать его равным нулю, значения будут округляться до целого числа по правилам математики. Например, 99.5 сохранится со значением 100, а 99.4 —  со значением 99.

<hr>

[Содержание](#содержание)

## Типы данных даты и времени

Все СУБД поддерживают типы данных, предназначенные для хранения значений даты и времени. Аналогично числовым типам, в большинстве СУБД имеется несколько типов данных даты и времени, каждый из которых имеет свой диапазон.

К основным типам данных даты и времени относятся:

Тип | Формат | Диапазон значений | Размер (в байтах)
-|-|-|-
`DATE` | YYYY-MM-DD | 1000-01-01 – 9999-12-31 | 3
`TIME` | HH:MM:SS | 00:00:00 – 23:59:59 | 3
`DATETIME` | YYYY-MM-DD HH:MM:SS | 1000-01-01 00:00:00 – 9999-12-31 23:59:59 | 8
`TIMESTAMP` | YYYY-MM-DD HH:MM:SS | 1970-01-01 00:00:00 – 2038-01-19 03:14:07 | 4
`YEAR` | YYYY | 1901 – 2155 | 1

### Типы данных DATETIME и TIMESTAMP

На первый взгляд типы `DATETIME` и `TIMESTAMP` очень похожи. Они предназначены для хранения даты и времени и имеют одинаковый формат. Но у них есть ряд отличий, с помощью которых можно определить, какой из этих типов следует использовать.

`DATETIME` хранит значения от `1000-01-01 00:00:00` до `9999-12-31 23:59:59` включительно и не зависит от временной зоны. Он всегда отображается ровно в таком виде, в котором был установлен и в котором хранится в базе данных. Другими словами, при изменении часового пояса отображение времени не изменится.

`TIMESTAMP` хранит информацию о том, сколько прошло секунд с начала эпохи, то есть с `1970-01-01 00:00:00`. При создании записи в поле, использующем этот тип данных, значение сохраняется по нулевому часовому поясу, а при выборке из базы данных отображается с учетом текущего часового пояса, который задается в настройках операционной системы, где работает MySQL, в глобальных настройках MySQL или в конкретной сессии.

### Способ задания значений

Значения полей, в которых используются типы данных `DATE`, `DATETIME` и `TIMESTAMP`, можно задать одним из следующих способов:
+ строка в формате `YYYY-MM-DD HH:MM:SS` или `YY-MM-DD HH:MM:SS` для указания даты и времени
+ строка в формате `YYYY-MM-DD` или в формате `YY-MM-DD` для указания только даты

При указании даты (тип данных `DATE`) допускается использовать любой знак пунктуации в качестве разделителя между частями даты. Также допустимо задавать дату и без разделительного знака. Например, следующие записи:

```sql
2023-06-14
2023.06.14
2023/06/14
20230614
230614
2023.06/14
2023/06.14
```

— абсолютно идентичны с точки зрения MySQL, однако при создании будут преобразованы в формат `2023-06-14`, поэтому будут храниться и отображаться именно в таком формате.

<hr>

[Содержание](#содержание)

## Тип данных NULL

Тип данных `NULL` — это специальное значение, которое используется в MySQL для обозначения отсутствия данных. Оно отличается от пустой строки или нулевого значения, так как в действительности означает полное отсутствие данных, в то время как ноль является допустимым числовым значением, а пустая строка — допустимой строкой нулевой длины.

Аналогом значения `NULL` в MySQL можно считать значение `None` в Python.

<hr>

[Содержание](#содержание)

## Примечания 1

**Примечание 1.** Одним из поддерживаемых MySQL типов данных является `ENUM` (перечисление). Поле таблицы с таким типом данных может содержать только те значения, которые были указаны для этого поля при создании таблицы. Например, если для поля, в котором хранится информация о половой принадлежности человека, указать тип данных `ENUM` со значениями `male` и `female`, то попытка установить какие-либо другие значения приведет к ошибке.

**Примечание 2.** В разных СУБД могут использоваться разные псевдонимы для типов данных. Например, в MySQL тип `INT` также может использоваться как `INTEGER`, а в `SQLite` — только как `INTEGER`, но не как `INT`.

**Примечание 3.** Некоторые данные (например, номера телефонов или почтовые индексы) содержат только числа, но это не значит, что они должны храниться в числовых полях. Например, если мы сохраним почтовый индекс 01234 в числовом поле, то сохранено будет число 1234, что приведет к потере первой цифры.

**Примечание 4.** Типы данных `VARCHAR` и `TEXT` кажутся похожими, как и типы `DATETIME` и `TIMESTAMP`, но у них есть свои различия. Ознакомиться с ними можно по [ссылке](https://andreyex.ru/bazy-dannyx/mariadb/raznitsa-mezhdu-varchar-i-text-v-mysql/).

**Примечание 5.** До версии MySQL 8.0.17 числа с плавающей точкой поддерживали диапазон unsigned, но он работал не так, как с целыми числами. Беззнаковый диапазон просто запрещал сохранять отрицательные значения, при этом максимальное значение не увеличивалось. Начиная с версии 8.0.17 использование unsigned не рекомендуется и считается устаревшим. В будущих версиях MySQL поддержку беззнакового диапазона для этого типа данных могут вовсе удалить.

<hr>

[Содержание](#содержание)

# 3.2 Извлечение данных

Урок посвящен извлечению информации из базы данных.

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем `Songs`, которая содержит информацию о пяти наиболее популярных песнях на некоторой площадке для прослушивания музыки:

```
+----+-------+----------------------+------------+---------+
| id | place | trackname            | artist     | streams |
+----+-------+----------------------+------------+---------+
| 1  | 4     | Crazy On You         | Heart      | 76338   |
| 2  | 3     | My Lover             | The Sounds | 99488   |
| 3  | 2     | Running up That Hill | Kate Bush  | 121495  |
| 4  | 5     | Thrill               | The Sounds | 49345   |
| 5  | 1     | Spent the Day in Bed | Morrissey  | 174994  |
+----+-------+----------------------+------------+---------+
```

Первое поле этой таблицы содержит уникальный идентификатор песни, второе — позицию песни в топе, третье — название песни, четвертое — псевдоним исполнителя или название группы, пятое — количество прослушиваний.

Скрипт для создания таблицы `Songs` + инструкция по установке и настройке MySQL

```sql
DROP TABLE IF EXISTS Songs;
CREATE TABLE Songs
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    place     INT,
    trackname VARCHAR(30),
    artist    VARCHAR(30),
    streams   INT
);

INSERT INTO Songs (place, trackname, artist, streams)
VALUES (4, 'Crazy On You', 'Heart', 76338),
       (3, 'My Lover', 'The Sounds', 99488),
       (2, 'Running up That Hill', 'Kate Bush', 121495),
       (5, 'Thrill', 'The Sounds', 49345),
       (1, 'Spent the Day in Bed', 'Morrissey', 174994);
```

Этот скрипт предназначен для того, чтобы выполнять запросы, указанные в лекции в качестве примеров, локально, то есть у себя на компьютере (или в онлайн-компиляторах). Операторы DROP, CREATE, INSERT и другие будут изучены позже в рамках этого курса. Перед тем как выполнять запросы, указанные в лекции, выполните все запросы этого скрипта в том порядке, в котором они указаны.

Инструкция по установке и настройке MySQL на свой компьютер доступна по [ссылке](https://timeweb.cloud/tutorials/mysql/kak-ustanovit-mysql-na-windows), дистрибутив MySQL доступен по [ссылке](https://dev.mysql.com/downloads/windows/installer/8.0.html).

Инструкция по работе с MySQL доступна по [ссылке](https://metanit.com/sql/mysql//1.3.php).

Онлайн-компиляторы MySQL доступны по [ссылке](https://www.mycompiler.io/new/mysql) и [ссылке](https://onecompiler.com/mysql).

<hr>

[Содержание](#содержание)

## Запросы и операторы

SQL-запрос представляет собой команду, которую мы отправляем базе данных для выполнения определенной задачи, целью которой может являться создание, изменение или извлечение данных. Каждый запрос состоит из операторов, определяющих необходимые действия, и различных выражений, например, логических или арифметических.

Операторы также называют ключевыми словами. Они представляют собой зарезервированные слова, которые имеют специальное значение и выполняют определенные функции в синтаксисе SQL. Операторы не могут использоваться в качестве имен таблиц, полей или других объектов базы данных.

Например, запрос ниже извлекает из таблицы `Songs` все записи, которые в качестве значения поля `streams` имеют целочисленное значение, превышающее 100000:

```sql
SELECT *
FROM Songs
WHERE streams > 100000;
```

Этот запрос состоит из ключевых слов `SELECT`, `FROM` и `WHERE`, а также выражения сравнения с числовым значением. Обратите внимание, что запрос завершается точкой с запятой (;), который символизирует конец операции. Дело в том, что SQL-запросы могут быть сложными и состоять из нескольких операций, и для разделения их друг от друга используется символ ;.

Например, запрос ниже создает таблицу с именем `Songs`, добавляет в нее две записи, а затем извлекает из созданной таблицы все содержимое:


```sql
CREATE TABLE Songs                               -- операция создания таблицы
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    trackname VARCHAR(30),
    artist    VARCHAR(30)
);                                               -- завершение операции

INSERT INTO Songs (trackname, artist)            -- операция наполнения таблицы
VALUES ('Crazy On You', 'Heart'),
       ('My Lover', 'The Sounds');               -- завершение операции

SELECT *                                         -- операция извлечения данных из таблицы
FROM Songs;                                      -- завершение операции
```

<hr>

[Содержание](#содержание)

## Оператор SELECT

Задачи, которые обычно приходится выполнять с базой данных, чаще всего сводятся к извлечению из нее необходимой информации. Это может быть получение конкретной записи, находящейся в одной из таблиц, или нескольких записей, удовлетворяющих определенным условиям. За все подобные задачи, связанные с извлечением данных, отвечает всего один оператор — `SELECT`.

Чтобы при помощи оператора `SELECT` извлечь данные из базы, нужно указать как минимум две вещи: что именно нужно извлечь и откуда. Начнем с простейшего запроса, который извлекает одно определенное поле таблицы.

Результатом приведенного ниже запроса:

```sql
SELECT trackname
FROM Songs;
```
является:

```
+----------------------+
| trackname            |
+----------------------+
| Crazy on You         |
| My Lover             |
| Running up That Hill |
| Thrill               |
| Spent the Day in Bed |
+----------------------+
```

Здесь оператор `SELECT` извлекает одно поле под названием `trackname` из таблицы `Songs`. Имя поля указывается сразу после ключевого слова `SELECT`, а ключевое слово `FROM` указывает на таблицу, из которой извлекаются данные. Также следует отметить, что этот запрос извлекает все записи таблицы, не выполняя никакой фильтрации.

Операторы нечувствительны к регистру, поэтому, например, записи `SELECT`, `select` и `Select` эквивалентны. Чаще всего разработчики применяют верхний регистр для операторов и нижний регистр для имен полей.

Для извлечения нескольких полей таблицы после оператора `SELECT` необходимо через запятую перечислить их имена.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist, streams
FROM Songs;
```
является:

```
+----------------------+------------+---------+
| trackname            | artist     | streams |
+----------------------+------------+---------+
| Crazy on You         | Heart      | 76338   |
| My Lover             | The Sounds | 99488   |
| Running up That Hill | Kate Bush  | 121495  |
| Thrill               | The Sounds | 49345   |
| Spent the Day in Bed | Morrissey  | 174994  |
+----------------------+------------+---------+
```

Следует заметить, что поля возвращаются именно в том порядке, в котором они указываются в самом запросе.

Результатом приведенного ниже запроса:

```sql
SELECT streams, artist, trackname
FROM Songs;
```

является:

```
+---------+------------+----------------------+
| streams | artist     | trackname            |
+---------+------------+----------------------+
| 76338   | Heart      | Crazy on You         |
| 99488   | The Sounds | My Lover             |
| 121495  | Kate Bush  | Running up That Hill |
| 49345   | The Sounds | Thrill               |
| 174994  | Morrissey  | Spent the Day in Bed |
+---------+------------+----------------------+
```

Помимо извлечения конкретных полей, с помощью оператора `SELECT` можно запросить все поля, не указывая каждое из них. Для этого вместо имен полей следует указать специальный групповой символ `*`.

Результатом приведенного ниже запроса:

```sql
SELECT *
FROM Songs;
```

является:

```
+----+----------+----------------------+------------+---------+
| id | place    | trackname            | artist     | streams |
+----+----------+----------------------+------------+---------+
| 1  | 4        | Crazy on You         | Heart      | 76338   |
| 2  | 3        | My Lover             | The Sounds | 99488   |
| 3  | 2        | Running up That Hill | Kate Bush  | 121495  |
| 4  | 5        | Thrill               | The Sounds | 49345   |
| 5  | 1        | Spent the Day in Bed | Morrissey  | 174994  |
+----+----------+----------------------+------------+---------+
```

Несмотря на то что групповой символ помогает сэкономить время, необходимое для перечисления всех нужных полей, используется он не так часто, так как извлечение ненужных полей обычно приводит к снижению производительности запроса. Однако есть одно преимущество в использовании группового символа: поскольку нет необходимости указывать точные имена полей, появляется возможность извлечь поля, имена которых неизвестны.

<hr>

[Содержание](#содержание)

## Извлечение уникальных записей

При извлечении одного или нескольких полей таблицы возвращаются все значения, содержащиеся в этих полях, однако такое поведение не всегда удобно. Например, поле может содержать повторяющиеся значения, тогда в результирующей таблице они также будут повторяться.

Результатом приведенного ниже запроса:

```sql
SELECT artist
FROM Songs;
```

является:

```
+------------+
| artist     |
+------------+
| Heart      |
| The Sounds |
| Kate Bush  |
| The Sounds |
| Morrissey  |
+------------+
```

Чтобы извлечь только уникальные записи, необходимо воспользоваться ключевым словом `DISTINCT`, которое указывается непосредственно перед именами полей.

Результатом приведенного ниже запроса:

```sql
SELECT DISTINCT artist
FROM Songs;
```

является:

```
+------------+
| artist     |
+------------+
| Heart      |
| The Sounds |
| Kate Bush  |
| Morrissey  |
+------------+
```

Важно отметить, что ключевое слово `DISTINCT` применяется ко всем полям, а не только к тому, перед которым оно стоит, поэтому при его использовании для двух и более полей одинаковыми будут считаться лишь те записи, которые имеют одинаковые значения по всем полям.

Результатом приведенного ниже запроса:

```sql
SELECT DISTINCT trackname, artist
FROM Songs;
```

является:

```
+----------------------+------------+
| trackname            | artist     |
+----------------------+------------+
| Crazy on You         | Heart      |
| My Lover             | The Sounds |
| Running up That Hill | Kate Bush  |
| Thrill               | The Sounds |
| Spent the Day in Bed | Morrissey  |
+----------------------+------------+
```

Здесь вторая и четвертая записи считаются разными, так как их значения совпадают не по всем полям, а только по одному.

<hr>

[Содержание](#содержание)

## Ограничение результатов запроса

Иногда при извлечении данных из таблицы может потребоваться получить лишь первую запись или некоторое определенное количество записей. Сделать это можно с помощью ключевого слова `LIMIT`.

Результатом приведенного ниже запроса:

```sql
SELECT trackname
FROM Songs
LIMIT 3;
```

является:

```
+----------------------+
| trackname            |
+----------------------+
| Crazy on You         |
| My Lover             |
| Running up That Hill |
+----------------------+
```

Запрос выше извлекает поле `trackname`, а выражение `LIMIT 3` говорит о том, что должно быть извлечено не более трех записей. Если необходимо получить следующие три записи, можно задать начальную точку извлечения с помощью ключевого слова `OFFSET`.

Результатом приведенного ниже запроса:

```sql
SELECT trackname
FROM Songs
LIMIT 3
OFFSET 2;
```

является:

```
+----------------------+
| trackname            |
+----------------------+
| Running up That Hill |
| Thrill               |
| Spent the Day in Bed |
+----------------------+
```

Выражение `LIMIT 3` `OFFSET 2` говорит о том, что должно быть извлечено три записи, начиная с записи с индексом два. Таким образом, первое число — это количество строк для извлечения, а второе — начальная точка.

Записи при использовании ключевого слова `OFFSET` индексируются с нуля, поэтому, например, выражение `LIMIT 1` `OFFSET 1` вернет вторую запись, а не первую.

Следует понимать, что ключевое слово `LIMIT` лишь ограничивает количество извлекаемых записей, а не определяет их количество. Например, если в таблице содержится пять записей, а ограничивающим значением является число десять, то извлечены будут все пять записей и только они.

Результатом приведенного ниже запроса:

```sql
SELECT trackname
FROM Songs
LIMIT 10;
```

является:

```
+----------------------+
| trackname            |
+----------------------+
| Crazy on You         |
| My Lover             |
| Running up That Hill |
| Thrill               |
| Spent the Day in Bed |
+----------------------+
```

Ключевое слово `OFFSET` можно использовать только в паре с ключевым словом `LIMIT`.

<hr>

[Содержание](#содержание)

## Псевдонимы

При извлечении различных полей таблицы они сохраняют свои исходные имена в результирующей таблице, однако при необходимости можно воспользоваться псевдонимами, чтобы дать им альтернативные имена. Делается это с помощью ключевого слова `AS`, которое располагается между исходным именем поля и новым.

Результатом приведенного ниже запроса:

```sql
SELECT trackname AS 'Song name',
       artist AS Artist
FROM Songs;
```

является:

```
+----------------------+------------+
| Song name            | Artist     |
+----------------------+------------+
| Crazy On You         | Heart      |
| My Lover             | The Sounds |
| Running up That Hill | Kate Bush  |
| Thrill               | The Sounds |
| Spent the Day in Bed | Morrissey  |
+----------------------+------------+
```

Обратите внимание: если псевдоним состоит из нескольких слов, он должен быть представлен строкой, заключенной в апострофы.

Псевдонимы могут содержать до 255 знаков, включая пробелы, цифры и специальные символы.

<hr>

[Содержание](#содержание)

## Примечания 2

**Примечание 1.** Записи в результирующей таблице иногда могут отображаться в произвольном порядке, и это нормально. Например, это может быть порядок, в котором записи заносились в таблицу. Главное, чтобы запрос возвращал одни и те же записи.

**Примечание 2.** Все лишние пробельные символы в запросе пропускаются при его обработке, поэтому запрос может быть записан как в одной длинной строке, так и разбит на несколько строк.

Например, приведенные ниже запросы функционально полностью идентичны:

```sql
SELECT trackname
FROM Songs;

SELECT trackname FROM Songs;

SELECT
trackname
FROM
Songs;
```

**Примечание 3.** Оператор `SELECT` может использоваться не только для извлечения данных из базы, но и для вывода конкретных значений, например, строк или чисел.

Результатом приведенного ниже запроса:

```sql
SELECT 'beegeek';
```

является:

```
+---------+
| beegeek |
+---------+
| beegeek |
+---------+
```

Результатом приведенного ниже запроса:

```sql
SELECT 100, 200, 300;
```

является:

```
+-----+-----+-----+
| 100 | 200 | 300 |
+-----+-----+-----+
| 100 | 200 | 300 |
+-----+-----+-----+
```

**Примечание 4.** Как и многие другие языки, SQL поддерживает несколько видов комментариев: однострочные и многострочные. Однострочные комментарии обозначаются двумя дефисами (--):

```sql
-- это комментарий

SELECT trackname    -- это комментарий
FROM Songs;
```

Многострочные комментарии обрамляются сочетанием символов /*:

```sql
/* это
многострочный
комментарий */

SELECT trackname
FROM Songs;
```

<hr>

[Содержание](#содержание)

## Детали решения задач

Перед тем как вы приступите к решению задач, в которых необходимо написать SQL-запрос, мы бы хотели рассмотреть одну из таких задач и дать относительно нее несколько комментариев.

Задача. Вам доступна база данных, принадлежащая анимационной студии Pixar. Она включает таблицу `Films`, которая хранит информацию о фильмах студии.

Таблица `Films`

```
+----+-----------------+----------------+--------------+
| id | title           | director       | release_year |
+----+-----------------+----------------+--------------+
| 1  | The Incredibles | Brad Bird      | 2004         |
| 2  | WALL-E          | Andrew Stanton | 2008         |
| 3  | Finding Nemo    | Andrew Stanton | 2003         |
| 4  | Up              | Pete Docter    | 2009         |
| 5  | Ratatouille     | Brad Bird      | 2007         |
+----+-----------------+----------------+--------------+
```

Первое поле этой таблицы содержит идентификатор фильма, второе — название, третье — имя и фамилию режиссера, четвертое — год выхода.

Напишите запрос, извлекающий из предложенной базы данных названия фильмов, которые вышли в 2004 году.

Результат запроса

```
+-----------------+
| title           |
+-----------------+
| The Incredibles |
+-----------------+
```

Скрипт для создания таблицы `Films`

```sql
DROP TABLE IF EXISTS Films;
CREATE TABLE Films
(
    id           INT PRIMARY KEY AUTO_INCREMENT,
    title        VARCHAR(20),
    director     VARCHAR(20),
    release_year INT
);

INSERT INTO Films (title, director, release_year)
VALUES ('The Incredibles', 'Brad Bird', 2004),
       ('WALL-E', 'Andrew Stanton', 2008),
       ('Finding Nemo', 'Andrew Stanton', 2003),
       ('Up', 'Pete Docter', 2009),
       ('Ratatouille', 'Brad Bird', 2007);
```

**Примечание.** Записи в результирующей таблице могут быть расположены в произвольном порядке.

**Решение.** В задаче сперва предлагается краткое описание используемой базы данных, а также названия таблиц, которые она включает. База данных может включать более одной таблицы, однако в этой задаче таблица всего одна. Далее прилагается содержимое всех таблиц и подробное их описание. После следует непосредственно задача, которую необходимо решить посредством написания SQL-запроса. В нашем случае нужно извлечь данные, которые удовлетворяют заданному условию. Ниже располагается результат запроса, представляющий собой таблицу, которая должна быть извлечена нашим запросом, в точности до порядка полей и их названий.

Результат запроса — это полноценная часть условия задачи, а не подсказка или ответ. Его нужно открыть и проанализировать во время прочтения условия, а не после безуспешных попыток решить задачу.

После результата запроса следует скрипт для создания всех используемых в задаче таблиц, который удобен тем, что позволяет быстро протестировать решение задачи локально. Завершается условие примечаниями, которые включают дополнительную уточняющую информацию. В нашей задаче говорится, что извлекать данные можно в произвольном порядке без какой-либо сортировки.

После внимательного изучения всей информации, представленной в условии задачи, можно приступить к ее решению. Например, одним из вариантов правильного запроса является:

```sql
SELECT title
FROM Films
WHERE release_year = 2004;
```

Приведенный выше код представляет собой ответ на задачу, и именно его следует вставить в окошко ввода.

<hr>

[Содержание](#содержание)

## Примечания 2a

**Примечание 1.** По мере усложнения задач условия будут включать больше информации: например, правила сортировки извлекаемых данных.

**Примечание 2.** Курс включает задачи не только на извлечение информации из базы данных, но и на модификацию базы данных (создание, изменение и удаление таблиц). В подобных задачах результат запроса содержит состояние базы данных, в котором она должна оказаться после выполнения правильного запроса.

**Примечание 3.** В большинстве задач курса допускается выполнять только один SQL-запрос. Как говорилось в уроке, каждый из них завершается точкой с запятой (;), которая отделяет операции (запросы) друг от друга. Поэтому если вы столкнулись с ошибкой `Only one query is allowed` при сдаче решения задачи, то у вас реализовано более одного запроса.

Даже если после точки с запятой просто написан комментарий, он будет восприниматься как следующий запрос и решение не пройдет. Перед тем, как отправить решение, все комментарии и лишние запросы необходимо удалить.

Задачи, в которых допускается выполнять более одного запроса, будут содержать соответствующее примечание.

**Примечание 4.** Задачи на написание SQL-запросов делятся на три категории:
+ базовая — 5 баллов
+ повышенного уровня сложности — 10 баллов 🌶️
+ высокого уровня сложности — 20 баллов 🌶️🌶️

<hr>

[Содержание](#содержание)

# 3.3 Сортировка данных

Урок посвящен сортировке данных.

### Используемая база данных 3

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем Songs, которая содержит информацию о пяти наиболее популярных песнях на некоторой площадке для прослушивания музыки:

```
+----+-------+----------------------+------------+---------+--------------+
| id | place | trackname            | artist     | streams | release_date |
+----+-------+----------------------+------------+---------+--------------+
| 1  | 4     | Crazy On You         | Heart      | 76338   | 2009-12-19   |
| 2  | 3     | My Lover             | The Sounds | 99488   | 2009-05-31   |
| 3  | 2     | Running up That Hill | Kate Bush  | 121495  | 1985-08-05   |
| 4  | 5     | Thrill               | The Sounds | 49345   | 2016-11-11   |
| 5  | 1     | Spent the Day in Bed | Morrissey  | 174994  | 2017-10-17   |
+----+-------+----------------------+------------+---------+--------------+
```

Первое поле этой таблицы содержит идентификатор песни, второе — позицию песни в топе, третье — название песни, четвертое — псевдоним исполнителя или название группы, пятое — количество прослушиваний, шестое — дату выхода.

Скрипт для создания таблицы `Songs`

```sql
DROP TABLE IF EXISTS Songs;
CREATE TABLE Songs
(
    id           INT PRIMARY KEY AUTO_INCREMENT,
    place        INT,
    trackname    VARCHAR(30),
    artist       VARCHAR(30),
    streams      INT,
    release_date DATE
);

INSERT INTO Songs (place, trackname, artist, streams, release_date)
VALUES (4, 'Crazy On You', 'Heart', 76338, '2009-12-19'),
       (3, 'My Lover', 'The Sounds', 99488, '2009-05-31'),
       (2, 'Running up That Hill', 'Kate Bush', 121495, '1985-08-05'),
       (5, 'Thrill', 'The Sounds', 49345, '2016-11-11'),
       (1, 'Spent the Day in Bed', 'Morrissey', 174994, '2017-10-17');
```

## Оператор ORDER BY

Нередко при извлечении данных возникает необходимость получить их в определенном упорядоченном виде. Например, во время работы с персональными данными людей может понадобиться расположить их в лексикографическом порядке имен или в порядке увеличения возраста. В SQL для подобных задач предназначен оператор `ORDER BY`.

Чтобы извлечь информацию из базы данных в отсортированном виде, достаточно дополнить запрос оператором `ORDER BY` и указать название поля, по которому необходимо осуществить сортировку.

Результатом приведенного ниже запроса:

```sql
SELECT artist, trackname, release_date
FROM Songs
ORDER BY release_date;
```

является:

```
+------------+----------------------+--------------+
| artist     | trackname            | release_date |
+------------+----------------------+--------------+
| Kate Bush  | Running up That Hill | 1985-08-05   |
| The Sounds | My Lover             | 2009-05-31   |
| Heart      | Crazy On You         | 2009-12-19   |
| The Sounds | Thrill               | 2016-11-11   |
| Morrissey  | Spent the Day in Bed | 2017-10-17   |
+------------+----------------------+--------------+
```

В данном примере извлекаются данные о песнях, однако в результирующей таблице они располагаются не в произвольном порядке, а в порядке возрастания значения поля `release_date`. Обратите внимание, что по умолчанию оператор `ORDER BY` выполняет сортировку именно по возрастанию.

В запросе оператор `ORDER BY` должен следовать после операторов `SELECT` и `FROM`, в противном случае запрос завершится с ошибкой.

Поля, по которым выполняется сортировка, необязательно должны быть извлечены, то есть сортировка может выполняться и по тем полям, которые не попадают в результирующую таблицу.

Результатом приведенного ниже запроса:

```sql
SELECT artist, trackname
FROM Songs
ORDER BY release_date;
```

является:

```
+------------+----------------------+
| artist     | trackname            |
+------------+----------------------+
| Kate Bush  | Running up That Hill |
| The Sounds | My Lover             |
| Heart      | Crazy On You         |
| The Sounds | Thrill               |
| Morrissey  | Spent the Day in Bed |
+------------+----------------------+
```

Здесь сортировка выполняется по полю `release_date`, однако извлечение этого поля не выполняется.

<hr>

[Содержание](#содержание)

### Сортировка по нескольким полям

Часто сортировки лишь по одному полю бывает недостаточно, поскольку несколько записей могут содержать одно и то же значение в том поле, по которому выполняется сортировка. Чтобы выполнить сортировку по нескольким полям, нужно перечислить их через запятую.

Результатом приведенного ниже запроса:

```sql
SELECT artist, trackname, streams
FROM Songs
ORDER BY artist, streams;
```

является:

```
+------------+----------------------+---------+
| artist     | trackname            | streams |
+------------+----------------------+---------+
| Heart      | Crazy On You         | 76338   |
| Kate Bush  | Running up That Hill | 121495  |
| Morrissey  | Spent the Day in Bed | 174994  |
| The Sounds | Thrill               | 49345   |
| The Sounds | My Lover             | 99488   |
+------------+----------------------+---------+
```

Запрос выше выполняет сортировку сначала по полю `artist`, затем по полю `streams`. Если какие-либо две записи имеют разные значения в поле `artist`, они сортируются согласно этим значениям. Если какие-либо две записи имеют одинаковые значения в поле `artist`, они сортируются согласно значениям в поле `streams`.

<hr>

[Содержание](#содержание)

### Сортировка по положению поля

Вместо имен полей оператор `ORDER BY` позволяет указывать порядковые номера полей, по которым необходимо выполнить сортировку. Однако сортировка таким методом возможна только по тем полям, которые присутствуют в результирующей таблице. Нумеруются поля с единицы: первое поле результирующей таблицы имеет порядковый номер 1, второе — 2 и так далее.

Например, запрос:

```sql
SELECT artist, trackname, streams
FROM Songs
ORDER BY artist, streams;
```

можно переписать следующим образом:

```sql
SELECT artist, trackname, streams
FROM Songs
ORDER BY 1, 3;
```

и получить аналогичный результат:

```
+------------+----------------------+---------+
| artist     | trackname            | streams |
+------------+----------------------+---------+
| Heart      | Crazy On You         | 76338   |
| Kate Bush  | Running up That Hill | 121495  |
| Morrissey  | Spent the Day in Bed | 174994  |
| The Sounds | Thrill               | 49345   |
| The Sounds | My Lover             | 99488   |
+------------+----------------------+---------+
```

Второй запрос отличается от первого лишь тем, что использует для сортировки порядковые номера полей, а не их имена. Он осуществляет сортировку по первому полю (`artist`), а в случае совпадения — по третьему полю (`streams`).

<hr>

[Содержание](#содержание)

### Указание направления сортировки

Сортировать данные можно не только по возрастанию, но и по убыванию. Чтобы сортировка выполнялась в порядке убывания, необходимо после имени поля указать ключевое слово `DESC`.

Результатом приведенного ниже запроса:

```sql
SELECT place, trackname
FROM Songs
ORDER BY place DESC;
```

является:

```
+-------+----------------------+
| place | trackname            |
+-------+----------------------+
| 5     | Thrill               |
| 4     | Crazy On You         |
| 3     | My Lover             |
| 2     | Running up That Hill |
| 1     | Spent the Day in Bed |
+-------+----------------------+
```

В примере выше записи сортируются по убыванию значения поля `place`.

Важной особенностью ключевого слова `DESC` является то, что оно применяется только к тому полю, после которого стоит. Это необходимо учитывать, когда сортировка выполняется по нескольким полям.

Результатом приведенного ниже запроса:

```sql
SELECT id, artist, trackname
FROM Songs
ORDER BY artist, id DESC;
```

является:

```
+----+------------+----------------------+
| id | artist     | trackname            |
+----+------------+----------------------+
| 1  | Heart      | Crazy On You         |
| 3  | Kate Bush  | Running up That Hill |
| 5  | Morrissey  | Spent the Day in Bed |
| 4  | The Sounds | Thrill               |
| 2  | The Sounds | My Lover             |
+----+------------+----------------------+
```

Здесь сортировка выполняется по полям `artist` и `id`. Ключевое слово `DESC` указано лишь после поля `id`, поэтому сортировка происходит в порядке возрастания значения поля `artist`, а в случае совпадения — в порядке убывания значения поля `id`.

Если необходимо отсортировать записи в порядке убывания значений нескольких полей, нужно обязательно указать ключевое слово `DESC` после каждого из них.

<hr>

[Содержание](#содержание)

## Примечания 3

**Примечание 1.** Аналогично тому, как для сортировки в порядке убывания существует ключевое слово `DESC`, для сортировки в порядке возрастания предусмотрено ключевое слово `ASC`, использовать которое необязательно.

Приведенный ниже запрос:

```sql
SELECT title
FROM Songs
ORDER BY title;
```

полностью идентичен следующему запросу:

```sql
SELECT title
FROM Songs
ORDER BY title ASC;
```

**Примечание 2.** Операторы `ORDER BY` и `LIMIT` могут использоваться вместе для решения различных задач. Например, с их помощью можно определить две песни, которые вышли позже всех остальных. Для этого сперва необходимо отсортировать музыкальные композиции в порядке убывания даты их выхода, а затем ограничить полученный результат до двух значений.

Результатом приведенного ниже запроса:

```sql
SELECT artist, trackname, release_date
FROM Songs
ORDER BY release_date DESC
LIMIT 2;
```

является:

```
+------------+----------------------+--------------+
| artist     | trackname            | release_date |
+------------+----------------------+--------------+
| Morrissey  | Spent the Day in Bed | 2017-10-17   |
| The Sounds | Thrill               | 2016-11-11   |
+------------+----------------------+--------------+
```

Стоит отметить, что подобные манипуляции с данными возможны благодаря порядку, в котором запрос выполняет свои операции: сначала запрос извлекает записи из таблицы, затем сортирует и только после этого ограничивает определенным количеством.

**Примечание 3.** Сортировка является одной из завершающих операций и выполняется уже после формирования результирующей таблицы, поэтому в блоке оператора `ORDER BY` можно указывать как фактические имена полей таблицы, из которой извлекаются данные, так и их псевдонимы.

Результатом приведенного ниже запроса:

```sql
SELECT artist, trackname AS track, release_date
FROM Songs
ORDER BY track;
```

является:

```
+------------+----------------------+--------------+
| artist     | track                | release_date |
+------------+----------------------+--------------+
| Heart      | Crazy On You         | 2009-12-19   |
| The Sounds | My Lover             | 2009-05-31   |
| Kate Bush  | Running up That Hill | 1985-08-05   |
| Morrissey  | Spent the Day in Bed | 2017-10-17   |
| The Sounds | Thrill               | 2016-11-11   |
+------------+----------------------+--------------+
```

Если псевдоним состоит из нескольких слов, то при сортировке данных по этому псевдониму необходимо заключать его в обратные апострофы (``).

Результатом приведенного ниже запроса:

```sql
SELECT artist, trackname AS 'track name'
FROM Songs
ORDER BY `track name`;
```

является:

```
+------------+----------------------+
| artist     | track name           |
+------------+----------------------+
| Heart      | Crazy On You         |
| The Sounds | My Lover             |
| Kate Bush  | Running up That Hill |
| Morrissey  | Spent the Day in Bed |
| The Sounds | Thrill               |
+------------+----------------------+
```

**Примечание 4.** Ключевое слово `DESC` — это сокращение от `DESCENDING` (убывание). Его антоним – ключевое слово `ASC` – сокращение от `ASCENDING` (возрастание).

**Примечание 5.** При сортировке строковых значений регистр не учитывается. Данное поведение может быть изменено в настройках СУБД, однако выбирать, учитывать регистр или нет, с помощью оператора `ORDER BY` нельзя.

<hr>

[Содержание](#содержание)

# 3.4 Фильтрация данных. Часть 1

Урок посвящен фильтрации данных.

### Используемая база данных 4

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем Songs, которая содержит информацию о пяти наиболее популярных песнях на некоторой площадке для прослушивания музыки:

```
+----+-------+----------------------+------------+---------+--------------+
| id | place | trackname            | artist     | streams | release_date |
+----+-------+----------------------+------------+---------+--------------+
| 1  | 4     | Crazy On You         | Heart      | 76338   | NULL         |
| 2  | 3     | My Lover             | The Sounds | 99488   | NULL         |
| 3  | 2     | Running up That Hill | Kate Bush  | 121495  | 1985-08-05   |
| 4  | 5     | Thrill               | The Sounds | 49345   | 2016-11-10   |
| 5  | 1     | Spent the Day in Bed | Morrissey  | 174994  | 2017-09-19   |
+----+-------+----------------------+------------+---------+--------------+
```

Первое поле этой таблицы содержит идентификатор песни, второе — позицию песни в топе, третье — название песни, четвертое — псевдоним исполнителя или название группы, пятое — количество прослушиваний, шестое — дату выхода.

Скрипт для создания таблицы `Songs`

```sql
DROP TABLE IF EXISTS Songs;
CREATE TABLE Songs
(
    id           INT PRIMARY KEY AUTO_INCREMENT,
    place        INT,
    trackname    VARCHAR(30),
    artist       VARCHAR(30),
    streams      INT,
    release_date DATE
);

INSERT INTO Songs (place, trackname, artist, streams, release_date)
VALUES (4, 'Crazy On You', 'Heart', 76338, NULL),
       (3, 'My Lover', 'The Sounds', 99488, NULL),
       (2, 'Running up That Hill', 'Kate Bush', 121495, '1985-08-05'),
       (5, 'Thrill', 'The Sounds', 49345, '2016-11-10'),
       (1, 'Spent the Day in Bed', 'Morrissey', 174994, '2017-09-19');
```

## Оператор WHERE

В таблицах баз данных обычно содержится очень много информации, и необходимость извлекать все записи из таблицы возникает довольно редко. Гораздо чаще требуется извлечь лишь некоторую их часть. Для этого используется оператор `WHERE`, который позволяет указывать определенные условия при извлечении записей. Если запись удовлетворяет этим условиям, то она попадает в результирующую таблицу, в противном случае отбрасывается.

В качестве первого примера напишем запрос, который извлекает данные о песнях некоторого конкретного исполнителя.

Результатом приведенного ниже запроса:

```sql
SELECT *
FROM Songs
WHERE artist = 'The Sounds';
```

является:

```
+----+----------+-----------+------------+---------+--------------+
| id | place    | trackname | artist     | streams | release_date |
+----+----------+-----------+------------+---------+--------------+
| 2  | 3        | My Lover  | The Sounds | 99488   | NULL         |
| 4  | 5        | Thrill    | The Sounds | 49345   | 2016-11-10   |
+----+----------+-----------+------------+---------+--------------+
```

В данном примере используется простая проверка на равенство. Запрос извлекает все поля таблицы, но возвращает не все записи, а только те, значение поля `artist` которых равно строке `The Sounds`.

Также в примере выше следует обратить внимание на расположение оператора `WHERE` в запросе: он указывается после названия таблицы. Также оператор `WHERE` может использоваться совместно с оператором `ORDER BY`, в таком случае оператор `ORDER BY` должен располагаться после оператора `WHERE`.

Результатом приведенного ниже запроса:

```sql
SELECT *
FROM Songs
WHERE artist = 'The Sounds'
ORDER BY streams;
```

является:

```
+----+----------+-----------+------------+---------+--------------+
| id | place    | trackname | artist     | streams | release_date |
+----+----------+-----------+------------+---------+--------------+
| 4  | 5        | Thrill    | The Sounds | 49345   | 2016-11-10   |
| 2  | 3        | My Lover  | The Sounds | 99488   | NULL         |
+----+----------+-----------+------------+---------+--------------+
```

<hr>

[Содержание](#содержание)

## Операторы сравнения

Условие после оператора `WHERE` может являться не только проверкой на равенство. В SQL поддерживается целый набор операторов сравнения, которые перечислены в таблице ниже:

Оператор | Проверка
-|-
`=` | Равенство
`<=>` | Эквивалентность
`!=` или `<>` | Неравенство
`<` | Меньше
`<=` | Меньше или равно
`>` | Больше
`>=` | Больше или равно
`BETWEEN` | Вхождение в диапазон
`IS NULL` | Значение `NULL`
`IS NOT NULL` | Не значение `NULL`

Мы уже рассмотрели пример проверки на равенство. Теперь попробуем воспользоваться и другими операторами сравнения.

<hr>

[Содержание](#содержание)

### Сравнение с одиночным значением

**Пример 1.** Извлечем из таблицы `Songs` данные о песнях, количество прослушиваний которых превышает 100000.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist, streams
FROM Songs
WHERE streams > 100000;
```

является:

```
+----------------------+-----------+---------+
| trackname            | artist    | streams |
+----------------------+-----------+---------+
| Running up That Hill | Kate Bush | 121495  |
| Spent the Day in Bed | Morrissey | 174994  |
+----------------------+-----------+---------+
```

**Пример 2.** Извлечем из таблицы `Songs` данные о песнях, которые входят в тройку лучших композиций, и отсортируем их по занимаемой позиции.

Результатом приведенного ниже запроса:

```sql
SELECT place, trackname, artist
FROM Songs
WHERE place <= 3
ORDER BY place;
```

является:

```
+----------+----------------------+------------+
| place    | trackname            | artist     |
+----------+----------------------+------------+
| 1        | Spent the Day in Bed | Morrissey  |
| 2        | Running up That Hill | Kate Bush  |
| 3        | My Lover             | The Sounds |
+----------+----------------------+------------+
```

**Пример 3.** Извлечем из таблицы `Songs` данные о песнях, которые не принадлежат группе `The Sounds`.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist
FROM Songs
WHERE artist != 'The Sounds';
```

является:

```
+----------------------+-----------+
| trackname            | artist    |
+----------------------+-----------+
| Crazy on You         | Heart     |
| Running up That Hill | Kate Bush |
| Spent the Day in Bed | Morrissey |
+----------------------+-----------+
```

Операторы `!=` и `<>` обычно взаимозаменяемы, однако не во всех СУБД поддерживаются обе формы оператора.

<hr>

[Содержание](#содержание)

### Сравнение с диапазоном значений

Для сравнения с диапазоном значений используется оператор `BETWEEN`. Его синтаксис немного отличается от других операторов, так как для него требуются два значения: начальное и конечное.

**Пример 1.** Извлечем из таблицы `Songs` данные о песнях, количество прослушиваний которых находится в диапазоне [50000; 100000].

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist, streams
FROM Songs
WHERE streams BETWEEN 50000 AND 100000;
```

является:

```
+--------------+------------+---------+
| trackname    | artist     | streams |
+--------------+------------+---------+
| Crazy on You | Heart      | 76338   |
| My Lover     | The Sounds | 99488   |
+--------------+------------+---------+
```

Как видно из примера выше, при использовании оператора BETWEEN нужно указывать два значения: нижнюю и верхнюю границы диапазона. Оба значения должны быть разделены ключевым словом AND. При этом извлекаются все значения из диапазона, включая те, что равны граничным значениям.

**Пример 2.** Извлечем из таблицы `Songs` данные о песнях, которые занимают второе, третье и четвертое места, и отсортируем их по занимаемой позиции.

Результатом приведенного ниже запроса:

```sql
SELECT place, trackname, artist
FROM Songs
WHERE place BETWEEN 2 AND 4
ORDER BY place;
```

является:

```
+----------+----------------------+------------+
| place    | trackname            | artist     |
+----------+----------------------+------------+
| 2        | Running up That Hill | Kate Bush  |
| 3        | My Lover             | The Sounds |
| 4        | Crazy on You         | Heart      |
+----------+----------------------+------------+
```

<hr>

[Содержание](#содержание)

### Проверка на присутствие и отсутствие значения

Чтобы проверить, содержит ли поле значение `NULL`, нельзя просто записать `<название поля> = NULL`, поскольку значение `NULL` трактуется как неопределенное, и мы не можем выполнить проверку такого значения ни на равенство, ни на неравенство.

Для определения того, находится ли в поле значение `NULL`, предусмотрен оператор `IS NULL`. Противоположным для него оператором является I`S NOT NULL`, который позволяет определить, что в поле не находится значение `NULL`.

**Пример 1.** Извлечем из таблицы `Songs` данные о песнях, которые не имеют даты выхода.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist, release_date
FROM Songs
WHERE release_date IS NULL;
```

является:

```
+--------------+------------+--------------+
| trackname    | artist     | release_date |
+--------------+------------+--------------+
| Crazy on You | Heart      | NULL         |
| My Lover     | The Sounds | NULL         |
+--------------+------------+--------------+
```

**Пример 2.** Извлечем из таблицы `Songs` данные о песнях, которые имеют дату выхода, и отсортируем их по этой дате в порядке убывания.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist, release_date
FROM Songs
WHERE release_date IS NOT NULL
ORDER BY release_date DESC;
```

является:

```
+----------------------+------------+--------------+
| trackname            | artist     | release_date |
+----------------------+------------+--------------+
| Spent the Day in Bed | Morrissey  | 2017-09-19   |
| Thrill               | The Sounds | 2016-11-10   |
| Running up That Hill | Kate Bush  | 1985-08-05   |
+----------------------+------------+--------------+
```

<hr>

[Содержание](#содержание)

## Примечания 4

**Примечание 1.** Фильтрация данных может выполняться после извлечения на уровне приложения, работающего с этими данными. Но такой метод обычно не приветствуется, так как базы данных оптимизированы для быстрой и эффективной фильтрации, и выполнение приложением функций базы данных приведет к значительному снижению его производительности.

**Примечание 2.** Псевдонимы полей не могут быть использованы в блоке оператора `WHERE` для фильтрации записей.

Результатом приведенного ниже запроса:

```sql
​SELECT trackname, artist, streams AS auditions
FROM Songs
WHERE auditions > 100000;
```

является ошибка:

```
ERROR 1054: Unknown column 'auditions' in 'where clause'
```

Это связано с тем, что блок `WHERE` обрабатывается до блока `SELECT`, поэтому на момент выполнения блока `WHERE` псевдонимы полей еще не известны.

**Примечание 3.** В зависимости от оператора и сравниваемых значений результатом операции сравнения могут являться следующие значения:
+ `1`, что эквивалентно истине
+ `0`, что эквивалентно лжи
+ `NULL`, что эквивалентно неопределенности

Результатом приведенного ниже запроса:

```sql
SELECT 'x' = 'x',
       'x' <=> 'x',
       'x' <=> 'y',
       'x' != 'z',
       5 < 10,
       10 <= 10,
       5 > 10,
       10 >= 5;
```

является:

```
+-----------+-------------+-------------+------------+--------+----------+--------+---------+
| 'x' = 'x' | 'x' <=> 'x' | 'x' <=> 'y' | 'x' != 'z' | 5 < 10 | 10 <= 10 | 5 > 10 | 10 >= 5 |
+-----------+-------------+-------------+------------+--------+----------+--------+---------+
| 1         | 1           | 0           | 1          | 1      | 1        | 0      | 1       |
+-----------+-------------+-------------+------------+--------+----------+--------+---------+
```

Отдельного рассмотрения требует значение `NULL`. Дело в том, что результатом сравнения любого значения с `NULL` является `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT 'x' != NULL,
       10 > NULL,
       NULL = NULL;
```

является:

```
+-------------+-----------+-------------+
| 'x' != NULL | 10 > NULL | NULL = NULL |
+-------------+-----------+-------------+
| NULL        | NULL      | NULL        |
+-------------+-----------+-------------+
```

Исключением является оператор эквивалентности, который аналогичен оператору равенства лишь с той разницей, что результат будет равен `1` в случае сравнения `NULL` с `NULL` и `0`, когда идет сравнение любого отличного от `NULL` значения с `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT 'x' <=> NULL,
       '5' <=> NULL,
       NULL <=> NULL;
```

является:

```
+--------------+--------------+---------------+
| 'x' <=> NULL | '5' <=> NULL | NULL <=> NULL |
+--------------+--------------+---------------+
| 0            | 0            | 1             |
+--------------+--------------+---------------+
```

**Примечание 4.** По умолчанию операторы сравнения не учитывают регистр при сравнении строковых значений.

Результатом приведенного ниже запроса:

```sql
SELECT 'bee' = 'Bee',
       'bee' <=> 'Bee',
       'bee' > 'Bee',
       'bee' < 'Bee';
```

является:

```
+---------------+-----------------+---------------+---------------+
| 'bee' = 'Bee' | 'bee' <=> 'Bee' | 'bee' > 'Bee' | 'bee' < 'Bee' |
+---------------+-----------------+---------------+---------------+
| 1             | 1               | 0             | 0             |
+---------------+-----------------+---------------+---------------+
```

Для учета регистра необходимо преобразовать одну из сравниваемых строк в тип данных `BINARY` с помощью функций `CAST()` или `CONVERT()`. `BINARY` — это строковый тип данных аналогичный типу `CHAR` за исключением того, что он хранит строки в двоичном виде.

Результатом приведенного ниже запроса:

```sql
SELECT CAST('bee' AS BINARY) = 'Bee' AS `'bee' = Bee'`,
       CAST('Bee' AS BINARY) = 'Bee' AS `'Bee' = Bee'`,
       CAST('bee' AS BINARY) <=> 'Bee' AS `'bee' <=> Bee'`,
       CONVERT('bee', BINARY) > 'Bee' AS `'bee' > Bee'`,
       CONVERT('bee', BINARY) < 'Bee' AS `'bee' < Bee'`;
```

является:

```
+--------------+--------------+----------------+--------------+--------------+
| 'bee' = Bee' | 'Bee' = Bee' | 'bee' <=> Bee' | 'bee' > Bee' | 'bee' < Bee' |
+--------------+--------------+----------------+--------------+--------------+
| 0            | 1            | 0              | 1            | 0            |
+--------------+--------------+----------------+--------------+--------------+
```

Функции `CAST()` и `CONVERT()` будут подробнее изучены в одном из следующих уроков.

**Примечание 5.** Оператор  `LIMIT` при его использовании совместно с оператором `WHERE`  или сочетанием операторов `WHERE` и `ORDER BY` должен располагаться после них.

Результатом приведенного ниже запроса:

```sql
SELECT place, trackname, artist
FROM Songs
WHERE place <= 4
LIMIT 2;
```

является:

```
+-------+--------------+------------+
| place | trackname    | artist     |
+-------+--------------+------------+
| 4     | Crazy on You | Heart      |
| 3     | My Lover     | The Sounds |
+-------+--------------+------------+
```

Результатом приведенного ниже запроса:

```sql
SELECT place, trackname, artist
FROM Songs
WHERE place <= 4
ORDER BY place
LIMIT 2;
```

является:

```
+-------+----------------------+-----------+
| place | trackname            | artist    |
+-------+----------------------+-----------+
| 1     | Spent the Day in Bed | Morrissey |
| 2     | Running up That Hill | Kate Bush |
+-------+----------------------+-----------+
```

Это связано с порядком, в котором запрос выполняет свои операции: сначала запрос извлекает из таблицы записи, удовлетворяющие заданным условиям, затем сортирует и только после этого ограничивает определенным количеством.

<hr>

[Содержание](#содержание)

# 3.5 Фильтрация данных. Часть 2

Урок посвящен фильтрации данных.

## Используемая база данных 5

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем Songs, которая содержит информацию о пяти наиболее популярных песнях на некоторой площадке для прослушивания музыки:

```
+----+----------+----------------------+------------+---------+--------------+
| id | place    | trackname            | artist     | streams | release_date |
+----+----------+----------------------+------------+---------+--------------+
| 1  | 4        | Crazy On You         | Heart      | 76338   | 1976-03-01   |
| 2  | 3        | My Lover             | The Sounds | 99488   | 2009-05-31   |
| 3  | 2        | Running up That Hill | Kate Bush  | 121495  | 1985-08-05   |
| 4  | 5        | Thrill               | The Sounds | 49345   | 2016-11-10   |
| 5  | 1        | Spent the Day in Bed | Morrissey  | 174994  | 2017-09-19   |
+----+----------+----------------------+------------+---------+--------------+
```

Первое поле таблицы содержит идентификатор песни, второе — позицию песни в топе, третье — название песни, четвертое — псевдоним исполнителя или название группы, пятое — количество прослушиваний, шестое — дату выхода.

Скрипт для создания таблицы `Songs`

```sql
DROP TABLE IF EXISTS Songs;
CREATE TABLE Songs
(
    id           INT PRIMARY KEY AUTO_INCREMENT,
    place        INT,
    trackname    VARCHAR(30),
    artist       VARCHAR(30),
    streams      INT,
    release_date DATE
);

INSERT INTO Songs (place, trackname, artist, streams, release_date)
VALUES (4, 'Crazy On You', 'Heart', 76338, '1976-03-01'),
       (3, 'My Lover', 'The Sounds', 99488, '2009-05-31'),
       (2, 'Running up That Hill', 'Kate Bush', 121495, '1985-08-05'),
       (5, 'Thrill', 'The Sounds', 49345, '2016-11-10'),
       (1, 'Spent the Day in Bed', 'Morrissey', 174994, '2017-09-19');
```

<hr>

[Содержание](#содержание)

## Операторы AND и OR

Фильтрация данных при их извлечении не ограничивается лишь одним критерием. В SQL, как и во многих других языках программирования, можно использовать несколько условий, чтобы создавать более сложные фильтры. Для этого предназначены логические операторы AND и OR.

### Оператор AND

Чтобы отфильтровать данные по нескольким полям, необходимо воспользоваться оператором `AND`. Он используется для извлечения только тех записей, которые удовлетворяют всем указанным условиям.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist, streams, release_date
FROM Songs
WHERE streams > 50000 AND release_date >= '2000-01-01';
```

является:

```
+----------------------+------------+---------+--------------+
| trackname            | artist     | streams | release_date |
+----------------------+------------+---------+--------------+
| My Lover             | The Sounds | 99488   | 2009-05-31   |
| Spent the Day in Bed | Morrissey  | 174994  | 2017-09-19   |
+----------------------+------------+---------+--------------+
```

Посредством запроса выше извлекаются данные о тех песнях, количество прослушиваний которых превышает 50000 и которые были выпущены в 2000 году или позднее. После оператора WHERE содержатся два условия, а оператор AND используется для их объединения. Оператор AND говорит о том, что должны быть возвращены только те записи, которые удовлетворяют всем перечисленным условиям. Если количество прослушиваний песни превышает 50000, но она была выпущена до 2000 года, то она не попадет в результат запроса. Аналогично если песня была выпущена в 2000 году или позднее, но не имеет более 50000 прослушиваний, то она также не попадет в результат запроса.

Количество условий после оператора `WHERE` может быть больше двух, в таком случае каждое из них должно отделяться отдельным оператором AND.

### Оператор OR

Действие оператора `OR` отличается от действия оператора `AND`. Он говорит о том, что должны быть извлечены только те записи, которые удовлетворяют хотя бы одному условию.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist
FROM Songs
WHERE artist = 'Heart' OR artist = 'Kate Bush';
```

является:

```
+----------------------+-----------+
| trackname            | artist    |
+----------------------+-----------+
| Crazy On You         | Heart     |
| Running up That Hill | Kate Bush |
+----------------------+-----------+
```

Посредством запроса выше извлекаются данные о тех песнях, исполнителями которых являются `Heart` или `Kate Bush`.

В большинстве СУБД при использовании оператора OR второе условие не рассматривается, если выполняется первое.

### Порядок обработки операторов

После оператора `WHERE` может содержаться любое количество логических операторов `AND` и `OR`. Комбинируя их, можно создавать сложные фильтры. Однако при комбинировании операторов `AND` и `OR` возникает одна проблема. Для ее понимания рассмотрим запрос, который, как кажется на первый взгляд, извлекает данные о песнях, исполнителями которых являются `The Sounds` или `Kate Bush` и количество прослушиваний которых превышает 50000.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist, streams
FROM Songs
WHERE artist = 'The Sounds' OR artist = 'Kate Bush' AND streams > 50000;
```

является:

```
+----------------------+------------+---------+
| trackname            | artist     | streams |
+----------------------+------------+---------+
| My Lover             | The Sounds | 99488   |
| Running up That Hill | Kate Bush  | 121495  |
| Thrill               | The Sounds | 49345   |
+----------------------+------------+---------+
```

Как видно по результирующей таблице, записи были отфильтрованы не так, как нужно, так как количество прослушиваний последней песни в результирующей таблице не превышает 50000. Произошло это потому, что сперва обрабатывается логический оператор `AND`, а потом уже — логический оператор `OR`. Таким образом, приведенный выше запрос извлекает песни, исполненные `Kate Bush` , количество прослушиваний которых превышает `50000`, и песни, исполненные `The Sounds`, независимо от количества их прослушиваний.

Чтобы составить корректный запрос, необходимо воспользоваться скобками и точно сгруппировать необходимые условия. В нашем случае в скобки нужно заключить часть условия с оператором OR, чтобы она имела больший приоритет и выполнялась первой. 

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist, streams
FROM Songs
WHERE (artist = 'The Sounds' OR artist = 'Kate Bush') AND streams > 50000;
```

является:

```
+----------------------+------------+---------+
| trackname            | artist     | streams |
+----------------------+------------+---------+
| My Lover             | The Sounds | 99488   |
| Running up That Hill | Kate Bush  | 121495  |
+----------------------+------------+---------+
```

Теперь при извлечении записи сперва проверяется, что в поле `artist` содержится значение `The Sounds` или `Kate Bush`, а затем выполняется проверка того, что значение поля `streams` больше 50000. Если обе проверки успешны, то запись извлекается, в противном случае отбрасывается.

При использовании логических операторов `AND` и `OR` рекомендуется всегда ставить скобки, чтобы точно сгруппировать условия. Не стоит полагаться на порядок обработки по умолчанию, даже если он подразумевает необходимый результат.

<hr>

[Содержание](#содержание)

## Оператор IN

Оператор `IN` позволяет определить, совпадает ли значение поля с одним из перечисленных значений.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist
FROM Songs
WHERE artist IN ('Heart', 'Kate Bush', 'Morrissey');
```

является:

```
+----------------------+-----------+
| trackname            | artist    |
+----------------------+-----------+
| Crazy on You         | Heart     |
| Running up That Hill | Kate Bush |
| Spent the Day in Bed | Morrissey |
+----------------------+-----------+
```

Данный запрос извлекает данные о тех песнях, исполнителями которых являются `Heart`, `Kate Bush` и `Morrissey`. После оператора `IN` указан список этих исполнителей через запятую, а весь список заключен в скобки.

Можно предположить, что оператор `IN` выполняет ту же функцию, что и логический оператор `OR`, и это действительно так. Приведенный выше запрос равносилен следующему запросу:

```sql
SELECT trackname, artist
FROM Songs
WHERE artist = 'Heart' OR artist = 'Kate Bush' OR artist = 'Morrissey';
```

результат которого совпадает с результатом выше:

```
+----------------------+-----------+
| trackname            | artist    |
+----------------------+-----------+
| Crazy on You         | Heart     |
| Running up That Hill | Kate Bush |
| Spent the Day in Bed | Morrissey |
+----------------------+-----------+
```

Однако оператор `IN` имеет некоторое преимущество перед оператором `OR`. Например, при работе с большим количеством значений синтаксис логического оператора `IN` гораздо понятнее. Также при использовании оператора `IN` совместно с операторами `AND` и `OR` намного легче управлять порядком их обработки.

<hr>

[Содержание](#содержание)

## Оператор NOT

Логический оператор `NOT` служит только одной цели — отрицать условие, следующее за ним. Например, с помощью данного оператора мы можем извлечь данные о тех песнях, исполнителем которых не является группа `The Sounds`.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist
FROM Songs
WHERE NOT artist = 'The Sounds';
```

является:

```
+----------------------+-----------+
| trackname            | artist    |
+----------------------+-----------+
| Crazy on You         | Heart     |
| Running up That Hill | Kate Bush |
| Spent the Day in Bed | Morrissey |
+----------------------+-----------+
```

Логический оператор `NOT` отрицает следующее за ним условие, поэтому возвращаются не те записи, которые в поле `artist` содержат значение `The Sounds`, а все остальные.

Конечно, в данном случае аналогичный по функционалу запрос можно составить и без оператора `NOT`, воспользовавшись лишь оператором сравнения `!=`.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist
FROM Songs
WHERE artist != 'The Sounds';
```

является:

```
+----------------------+-----------+
| trackname            | artist    |
+----------------------+-----------+
| Crazy on You         | Heart     |
| Running up That Hill | Kate Bush |
| Spent the Day in Bed | Morrissey |
+----------------------+-----------+
```

Однако в более сложных условиях можно воспользоваться оператором `NOT` в связке с оператором `IN`, что окажется предпочтительнее оператора `!=`.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist
FROM Songs
WHERE NOT artist IN ('Heart', 'Kate Bush', 'Morrissey');
```

является:

```
+-----------+------------+
| trackname | artist     |
+-----------+------------+
| My Lover  | The Sounds |
| Thrill    | The Sounds |
+-----------+------------+
```

В этом запросе извлекаются данные о тех песнях, исполнителями которых не являются `Heart`, K`ate Bush` и `Morrissey`. Аналогичный запрос с использованием оператора сравнения `!=` выглядел бы следующим образом:

```sql
SELECT trackname, artist
FROM Songs
WHERE artist != 'Heart' AND artist != 'Kate Bush' AND artist != 'Morrissey';
```

<hr>

[Содержание](#содержание)

## Оператор NOT IN

Связка операторов `NOT` и `IN` хоть и довольно полезна, но недостаточно наглядна. На практике для определения несоответствия списку значений используется более очевидный оператор `NOT IN`, выполняющий ровно то же, что и связка операторов `NOT` и `IN`.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist
FROM Songs
WHERE artist NOT IN ('Heart', 'Kate Bush', 'Morrissey');
```

является:

```
+-----------+------------+
| trackname | artist     |
+-----------+------------+
| My Lover  | The Sounds |
| Thrill    | The Sounds |
+-----------+------------+
```

<hr>

[Содержание](#содержание)

## Примечания 5

**Примечание 1.** Логические операторы `AND`, `OR`, `NOT`, `IN` и `NOT IN` имеют разный приоритет. В таблице ниже они представлены в порядке уменьшения их приоритета:

|Оператор|
|-|
|IN , NOT IN|
|NOT|
|AND|
|OR|

Если условие содержит несколько логических операторов с одинаковым приоритетом, они выполняются слева направо.

**Примечание 2.** Логический оператор `NOT` отрицает только то условие, перед которым указан.

Результатом приведенного ниже запроса:

```sql
SELECT id, artist
FROM Songs
WHERE NOT id = 1 OR id = 2;
```

является:

```
+----+------------+
| id | artist     |
+----+------------+
| 2  | The Sounds |
| 3  | Kate Bush  |
| 4  | The Sounds |
| 5  | Morrissey  |
+----+------------+
```

В запросе выше указано два условия, но оператор `NOT` отрицает только первое из них. Для того, чтобы он отрицал все условия, необходимо объединить их вместе с помощью круглых скобок.

Результатом приведенного ниже запроса:

```sql
SELECT id, artist
FROM Songs
WHERE NOT (id = 1 OR id = 2);
```

является:

```
+----+------------+
| id | artist     |
+----+------------+
| 3  | Kate Bush  |
| 4  | The Sounds |
| 5  | Morrissey  |
+----+------------+
```

<hr>

[Содержание](#содержание)

# 3.6 Фильтрация данных. Часть 3

Урок посвящен фильтрации данных.

### Используемая база данных 6

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем Songs, которая содержит информацию о пяти наиболее популярных песнях на некоторой площадке для прослушивания музыки:

```
+----+-------+--------------------------------------+---------------+
| id | place | trackname                            | artist        |
+----+-------+--------------------------------------+---------------+
| 1  | 4     | You Just Haven't Earned It Yet, Baby | The Smiths    |
| 2  | 3     | Crazy On You                         | Heart         |
| 3  | 2     | Dark Days                            | Theredsunband |
| 4  | 5     | Wish You Were Here                   | The Sounds    |
| 5  | 1     | Let Me Kiss You                      | Morrissey     |
+----+-------+--------------------------------------+---------------+
```

Первое поле таблицы содержит идентификатор песни, второе — позицию песни в топе, третье — название песни, четвертое — псевдоним исполнителя или название группы.

Скрипт для создания таблицы `Songs`

Этот скрипт предназначен для людей, которые разворачивают БД на локальной машине. Операторы `DROP`, `CREATE` и `INSERT` будут пройдены в будущих уроках. Чтобы запросы в вашей базе работали, первым делом вставьте этот скрипт:

```sql
DROP TABLE IF EXISTS Songs;
CREATE TABLE Songs
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    place     INT,
    trackname VARCHAR(50),
    artist    VARCHAR(30)
);

INSERT INTO Songs (place, trackname, artist)
VALUES (4, "You Just Haven't Earned It Yet, Baby", 'The Smiths'),
       (3, 'Crazy On You', 'Heart'),
       (2, 'Dark Days', 'Theredsunband'),
       (5, 'Wish You Were Here', 'The Sounds'),
       (1, 'Let Me Kiss You', 'Morrissey');
```

## Метасимволы и оператор LIKE

Операторы сравнения (`=`, `>`, `BETWEEN` и другие) позволяют достаточно точно фильтровать данные, однако они несколько ограничены в своем функционале, так как выполняют фильтрацию по известным значениям. Например, если бы нам было необходимо среди множества музыкальных исполнителей отыскать только тех, названия которых начинаются с последовательности символов `The`, с помощью обычных операторов сравнения мы бы это сделать не смогли. Для подобных случаев предусмотрен поиск с использованием метасимволов, которые позволяют создавать шаблоны поиска и находить значения, соответствующие не чему-либо конкретному, а именно этим шаблонам.

Метасимволы сами по себе являются специальными знаками, которые трактуются языком особым образом. Чтобы использовать их в условиях отбора записей, необходимо задействовать оператор `LIKE`, который говорит о том, что следующий шаблон поиска необходимо анализировать с учетом метасимволов, а не искать точные совпадения.

Шаблоны поиска представляют собой строки, состоящие из обычных символов, метасимволов или любой их комбинации, поэтому поиск с использованием метасимволов может осуществляться только в строковых полях.

### Метасимвол %

Наиболее часто используемым метасимволом является знак процента (`%`), который в шаблоне поиска соответствует последовательности любых символов, причем число символов в последовательности может быть от 0 и более. Например, чтобы найти информацию о песнях, названия исполнителей которых начинаются с последовательности символов `The`, можно составить следующий шаблон поиска: `The%`.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist
FROM Songs
WHERE artist LIKE 'The%';
```

является:

```
+--------------------------------------+---------------+
| trackname                            | artist        |
+--------------------------------------+---------------+
| You Just Haven't Earned It Yet, Baby | The Smiths    |
| Dark Days                            | Theredsunband |
| Wish You Were Here                   | The Sounds    |
+--------------------------------------+---------------+
```

В этом запросе при проверке условия, следующего после оператора `WHERE`, возвращаются все записи, значения поля `artist` которых начинаются с последовательности символов `The`. Знак `%` соответствует всем символам, следующим после `The`, независимо от их количества.

Обратите внимание, что шаблон `The%` соответствует как строкам `The Smiths` и `The Sounds`, так и строке `Theredsunband`. Если бы требовалось получить информацию лишь о тех песнях, названия исполнителей которых начинаются с артикля `The`, шаблон поиска было бы необходимо дополнить символом пробела.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist
FROM Songs
WHERE artist LIKE 'The %';
```

является:

```
+--------------------------------------+------------+
| trackname                            | artist     |
+--------------------------------------+------------+
| You Just Haven't Earned It Yet, Baby | The Smiths |
| Wish You Were Here                   | The Sounds |
+--------------------------------------+------------+
```

Метасимволы могут встречаться в любом месте шаблона поиска, причем в неограниченном количестве. Например, c помощью шаблона `%You%` можно отыскать информацию о песнях, названия которых включают слово `You`.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist
FROM Songs
WHERE trackname LIKE '%You%';
```

является:

```
+--------------------------------------+------------+
| trackname                            | artist     |
+--------------------------------------+------------+
| You Just Haven't Earned It Yet, Baby | The Smiths |
| Crazy On You                         | Heart      |
| Wish You Were Here                   | The Sounds |
| Let Me Kiss You                      | Morrissey  |
+--------------------------------------+------------+
```

Таким образом, шаблону `%You%` соответствуют все строки, содержащие текст `You` в любом месте, независимо от количества символов перед указанным текстом или после него. Несложно догадаться, что такому шаблону также будут соответствовать строки, содержащие не только слово `You`, но и, например, слово `Your`, поэтому более верным решением будет перед и после слова `You` в шаблоне указать по одному пробелу.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist
FROM Songs
WHERE trackname LIKE '% You %';
```

является:

```
+--------------------+------------+
| trackname          | artist     |
+--------------------+------------+
| Wish You Were Here | The Sounds |
+--------------------+------------+
```

Теперь шаблон действительно соответствует строкам, которые содержат именно слово `You`, однако он не учитывает то, что это слово может располагаться в начале или в конце строки, так как требует слева и справа от слова `You` наличие пробелов. Для поиска необходимого слова независимо от его положения в строке мы можем воспользоваться дополнительными шаблонами, которые соответствуют упомянутым случаям.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist
FROM Songs
WHERE trackname LIKE 'You %' OR trackname LIKE '% You %' OR trackname LIKE '% You';
```

является:

```
+--------------------------------------+------------+
| trackname                            | artist     |
+--------------------------------------+------------+
| You Just Haven't Earned It Yet, Baby | The Smiths |
| Crazy On You                         | Heart      |
| Wish You Were Here                   | The Sounds |
| Let Me Kiss You                      | Morrissey  |
+--------------------------------------+------------+
```

### Метасимвол _

Еще одним полезным метасимволом является знак нижнего подчеркивания (`_`), который в шаблоне поиска соответствует одному любому символу. Например, с его помощью можно составить запрос, который поможет отыскать информацию о песнях, названия которых начинаются с какого-либо четырехсимвольного слова.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist
FROM Songs
WHERE trackname LIKE '____ %';
```

является:

```
+--------------------+---------------+
| trackname          | artist        |
+--------------------+---------------+
| Dark Days          | Theredsunband |
| Wish You Were Here | The Sounds    |
+--------------------+---------------+
```

В шаблоне выше используются четыре метасимвола `_`, пробел и метасимвол `%`. Так, к примеру, в названии второй отобранной песни четырем символам нижнего подчеркивания соответствует слово `Wish`, пробелу соответствует сам пробел, следующий после слова `Wish`, а знаку `%` соответствует оставшаяся часть названия песни — `You Were Here`.

Аналогичным образом можно получить информацию о песнях, названия которых начинаются с какого-либо трехсимвольного слова.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist
FROM Songs
WHERE trackname LIKE '___ %';
```

является:

```
+--------------------------------------+------------+
| trackname                            | artist     |
+--------------------------------------+------------+
| You Just Haven't Earned It Yet, Baby | The Smiths |
| Let Me Kiss You                      | Morrissey  |
+--------------------------------------+------------+
```

В отличие от знака `%`, который подразумевает также отсутствие символов, знак `_` всегда соответствует одному символу — не больше и не меньше.

<hr>

[Содержание](#содержание)

## Регистрозависимость

Важной особенностью оператора `LIKE` является то, что при поиске с его помощью строк, соответствующих шаблону, не учитывается регистр символов, используемых в этом шаблоне. Например, один из рассмотренных нами шаблонов поиска `%You%` мы могли записать в виде `%you%` или `%YOU%`, и результат остался бы прежним.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist
FROM Songs
WHERE trackname LIKE '%you%';
```

является:

```
+--------------------------------------+------------+
| trackname                            | artist     |
+--------------------------------------+------------+
| You Just Haven't Earned It Yet, Baby | The Smiths |
| Crazy On You                         | Heart      |
| Wish You Were Here                   | The Sounds |
| Let Me Kiss You                      | Morrissey  |
+--------------------------------------+------------+
```

Безусловно, такое поведение удобно, однако не всегда нужно. Поэтому в случаях, когда регистр символов важен, шаблон поиска необходимо преобразовать в тип данных `BINARY` с помощью функций `CAST()` или `CONVERT()`.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist
FROM Songs
WHERE trackname LIKE CAST('%You%' AS BINARY);
```

как и результатом приведенного ниже запроса:

```sql
SELECT trackname, artist
FROM Songs
WHERE trackname LIKE CONVERT('%You%', BINARY);
```

является:

```
+--------------------------------------+------------+
| trackname                            | artist     |
+--------------------------------------+------------+
| You Just Haven't Earned It Yet, Baby | The Smiths |
| Crazy On You                         | Heart      |
| Wish You Were Here                   | The Sounds |
| Let Me Kiss You                      | Morrissey  |
+--------------------------------------+------------+
```

При этом результат приведенного ниже запроса:

```sql
SELECT trackname, artist
FROM Songs
WHERE trackname LIKE CAST('%you%' AS BINARY);
```

как и результат приведенного ниже запроса, пуст:

```sql
SELECT trackname, artist
FROM Songs
WHERE trackname LIKE CONVERT('%you%', BINARY);
```

<hr>

[Содержание](#содержание)

## Примечания

**Примечание 1.** Метасимволы — очень мощный механизм. Но за эту мощь приходится платить, так как на поиск с использованием метасимволов уходит больше времени, чем на любые другие виды поиска. Поэтому если можно использовать другой оператор поиска, то следует задействовать именно его.

**Примечание 2.** Метасимволы в шаблоне поиска соответствуют набору символов или одному любому символу, однако иногда может понадобиться отыскать совпадение только для самого метасимвола, например, символа процента (`%`). В подобных случаях используется экранирование с помощью ключевого слова `ESCAPE`, которое указывается после шаблона поиска и определяет символ, отвечающий за экранирование.

Например, условие для поиска значений вида `10%`, `24%`, `49%` и так далее может выглядеть следующим образом:

```sql
...
WHERE <название поля> LIKE '__/%' ESCAPE '/';
```

Здесь для экранирования используется прямой слеш (`/`), который в шаблоне указывает на то, что символ, стоящий после прямого слеша, не следует рассматривать как метасимвол. 

**Примечание 3.** Метасимвол `%` может соответствовать чему угодно, но есть одно исключение: `NULL`. Никакой шаблон поиска не позволит отобрать запись, проверяемое поле которой содержит значение `NULL`.

**Примечание 4.** При составлении шаблона поиска, с помощью которого планируется выполнять поиск строк типа `CHAR`, необходимо помнить, что этот тип данных заполняет пробелами неиспользуемую часть строки. Если не учитывать в шаблоне потенциальные пробелы, поиск может выполняться неверно.

<hr>

[Содержание](#содержание)

# 3.7 Создание вычисляемых полей

Урок посвящен созданию вычисляемых полей.

### Используемая база данных 7

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем Songs, которая содержит информацию о пяти наиболее популярных песнях на некоторой площадке для покупки и прослушивания музыки:

```
+----+-------+----------------------+------------+-------+----------+
| id | place | trackname            | artist     | price | quantity |
+----+-------+----------------------+------------+-------+----------+
| 1  | 4     | Crazy On You         | Heart      | 2.00  | 31454    |
| 2  | 3     | My Lover             | The Sounds | 3.00  | 4558     |
| 3  | 2     | Running up That Hill | Kate Bush  | 1.00  | 15874    |
| 4  | 5     | Thrill               | The Sounds | 5.00  | 548      |
| 5  | 1     | Spent the Day in Bed | Morrissey  | 5.00  | 564797   |
+----+-------+----------------------+------------+-------+----------+
```

Первое поле этой таблицы содержит идентификатор песни, второе — позицию песни в топе, третье — название песни, четвертое — псевдоним исполнителя или название группы, пятое — цену песни в долларах, шестое — количество проданных копий.

Скрипт для создания таблицы `Songs`

```sql
DROP TABLE IF EXISTS Songs;
CREATE TABLE Songs
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    place     INT,
    trackname VARCHAR(30),
    artist    VARCHAR(30),
    price     DECIMAL(10, 2),
    quantity  INT
);

INSERT INTO Songs (place, trackname, artist, price, quantity)
VALUES (4, 'Crazy On You', 'Heart', 2.00, 31454),
       (3, 'My Lover', 'The Sounds', 3.00, 4558),
       (2, 'Running up That Hill', 'Kate Bush', 1.00, 15874),
       (5, 'Thrill', 'The Sounds', 5.00, 548),
       (1, 'Spent the Day in Bed', 'Morrissey', 5.00, 564797);
```

## Вычисляемые поля

Данные, хранимые в таблицах базы данных, часто бывают представлены не в том виде, в котором они необходимы. Например, в таблице, хранящей персональные данные людей, имя и фамилия человека могут находиться в разных полях, однако нам может потребоваться указать их в одном поле. Другим примером может являться таблица, хранящая детали интернет-заказа. В одном поле таблицы может находиться количество приобретенного товара, в другом — цена за единицу товара. Во время работы с такой таблицей закономерно может понадобиться общая стоимость — цена товара, умноженная на количество.

В каждом из рассмотренных примеров перед нами встает задача получения информации, которая не хранится в базе данных в явном виде, однако может быть получена путем различных манипуляций. Для решения подобной задачи используются вычисляемые поля — поля, значения которых не хранятся в таблице базы данных, а вычисляются автоматически на основе данных из других полей таблицы. Вычисляемые поля используются для извлечения информации с дополнительными преобразованиями, подсчетами или форматированием.

Вычисляемые поля определяются с использованием выражений, которые могут включать математические операции и вызовы различных функций. И если математические операции знакомы практически всем, то функции у неопытных студентов могут вызвать трудности. Поэтому в следующем абзаце мы предоставим ознакомительную информацию касательно функций, которой достаточно для понимания рассматриваемых в уроке примеров. 

У студентов курса, знакомых с любым современным языком программирования, изучение функций в SQL не вызовет никаких трудностей.

Функция — программная единица, предназначенная для выполнения различных операций с данными. Например, функция может переводить символы строки в верхний регистр или возводить число в определенную степень. Каждая функция обладает уникальным именем и набором аргументов. Аргументы функции представляют собой данные, с которыми работает функция. Например, аргументами функции, возводящей число в определенную степень, являются само число и показатель степени.

Для вызова функции сначала указывается ее имя, а затем в скобках через запятую перечисляются все необходимые аргументы. Например, вызов функции `POW()` для возведения числа 5 во 2 степень выглядит следующим образом:

```sql
POW(5, 2)
```

<hr>

[Содержание](#содержание)

## Объединение значений полей

Наиболее простым примером вычисляемого поля является поле, которое содержит объединение значений из нескольких полей таблицы. Например, структура нашей таблицы `Songs` такова, что название песни и ее исполнитель указываются в разных полях, однако мы можем определить вычисляемое поле, в котором сразу будут указаны и название, и исполнитель.

Операцию объединения или склеивания нескольких значений часто называют конкатенацией. Например, конкатенацией строк `bee` и `geek` является строка `beegeek`.

В SQL для объединения нескольких значений используется функция `CONCAT()`. Она принимает переменное количество аргументов, выполняет их конкатенацию и возвращает полученный результат. Результатом функции `CONCAT()` всегда является строка, однако аргументы функции могут принадлежать любым типам, поскольку функция неявно преобразует все аргументы в строки перед объединением.

Возвращаясь к предложенному примеру, воспользуемся функцией `CONCAT()` и напишем запрос, который извлекает названия песен и их исполнителей, причем указывает эти данные в одном поле.

Результатом приведенного ниже запроса:

```sql
SELECT CONCAT(artist, ' - ', trackname)
FROM Songs;
```

является:

```
+----------------------------------+
| CONCAT(artist, ' - ', trackname) |
+----------------------------------+
| Heart - Crazy On You             |
| The Sounds - My Lover            |
| Kate Bush - Running up That Hill |
| The Sounds - Thrill              |
| Morrissey - Spent the Day in Bed |
+----------------------------------+
```

В данном примере функция `CONCAT()` выполняет объединение следующих значений: исполнителя песни, строки-разделителя `( - )` и названия песни. Итогом является поле, в котором содержатся все три значения.

Также в примере выше можно заметить, что имя вычисляемого поля в результирующей таблице совпадает с выражением, которое это поле определяет. Чтобы вычисляемое поле получило более информативное название, ему достаточно дать псевдоним.

Результатом приведенного ниже запроса:

```sql
SELECT CONCAT(artist, ' - ', trackname) AS song
FROM Songs;
```

является:

```
+----------------------------------+
| song                             |
+----------------------------------+
| Heart - Crazy On You             |
| The Sounds - My Lover            |
| Kate Bush - Running up That Hill |
| The Sounds - Thrill              |
| Morrissey - Spent the Day in Bed |
+----------------------------------+
```

Именовать вычисляемые поля полезно не только для улучшения внешнего вида результирующей таблицы, но и для возможности удобно обращаться к ним в рамках запроса, например, во время сортировки записей.

Результатом приведенного ниже запроса:

```sql
​SELECT CONCAT(artist, ' - ', trackname) as song
FROM Songs
ORDER BY song DESC;
```

является:

```
+----------------------------------+
| song                             |
+----------------------------------+
| The Sounds - Thrill              |
| The Sounds - My Lover            |
| Morrissey - Spent the Day in Bed |
| Kate Bush - Running up That Hill |
| Heart - Crazy On You             |
+----------------------------------+
```

Ограничений на количество используемых вычисляемых полей нет. Запрос может включать как одно вычисляемое поле, так и десять.

### Функция CONCAT_WS()

Для конкатенации значений в SQL существует дополнительная функция — `CONCAT_WS()`. В отличие от функции `CONCAT()`, она не только объединяет значения, но и добавляет между ними разделитель. Разделитель указывается в качестве первого аргумента, объединяемые значения — в качестве всех остальных.

Результатом приведенного ниже запроса:

```sql
SELECT CONCAT_WS(', ', id, artist, trackname) AS song
FROM Songs;
```

является:

```
+------------------------------------+
| song                               |
+------------------------------------+
| 1, Heart, Crazy On You             |
| 2, The Sounds, My Lover            |
| 3, Kate Bush, Running up That Hill |
| 4, The Sounds, Thrill              |
| 5, Morrissey, Spent the Day in Bed |
+------------------------------------+
```

Здесь функция `CONCAT_WS()` объединяет значения полей `id`, `artist` и `trackname`, а в качестве разделителя использует строку `, ` (запятая и пробел).

Функция `CONCAT_WS()`, как и функция `CONCAT()`, умеет работать с аргументами любых типов, поскольку перед объединением неявно преобразует все аргументы в строки.

<hr>

[Содержание](#содержание)

## Выполнение математических вычислений

Как было упомянуто в начале урока, с помощью вычисляемых полей можно решать задачи, требующие выполнения математических операций над извлекаемыми данными. 

Например, структура нашей таблицы `Songs` такова, что в ней для каждой песни указана цена, а также количество проданных копий. Общей суммы, которую принесли продажи каждой песни, в таблице нет, однако она может быть получена путем умножения цены песни на количество проданных копий. В качестве примера напишем запрос, который выполняет именно такую операцию и определяет общую сумму, которую принесли продажи каждой песни.

Результатом приведенного ниже запроса:

```sql
SELECT artist, trackname,
       price * quantity AS revenue
FROM Songs;
```

является:

```
+------------+----------------------+------------+
| artist     | trackname            | revenue    |
+------------+----------------------+------------+
| Heart      | Crazy On You         | 62908.00   |
| The Sounds | My Lover             | 13674.00   |
| Kate Bush  | Running up That Hill | 15874.00   |
| The Sounds | Thrill               | 2740.00    |
| Morrissey  | Spent the Day in Bed | 2823985.00 |
+------------+----------------------+------------+
```

Запрос выше вычисляет суммарную прибыль каждой песни путем умножения значения поля `price` на значение поля `quantity` и указывает полученные результаты в поле revenue.

В SQL поддерживаются основные математические операторы: `+` (сложение), `-` (вычитание), `*` (умножение) и `/` (деление). Для управления порядком обработки операторов можно использовать круглые скобки.

<hr>

[Содержание](#содержание)

## Примечания

**Примечание 1.** Если хотя бы один из операндов в математическом выражении равен `NULL`, результатом всего выражения также будет значение `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT 1 + NULL,
       1 - NULL,
       1 * NULL,
       1 / NULL,
       (1 + NULL) / 2;
```

является:

```
+----------+----------+----------+----------+----------------+
| 1 + NULL | 1 - NULL | 1 * NULL | 1 / NULL | (1 + NULL) / 2 |
+----------+----------+----------+----------+----------------+
| NULL     | NULL     | NULL     | NULL     | NULL           |
+----------+----------+----------+----------+----------------+
```

**Примечание 2.** В MySQL по умолчанию результатом деления на ноль является значение `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT 1 / 0;
```

является:

```
+-------+
| 1 / 0 |
+-------+
| NULL  |
+-------+
```

При необходимости данное поведение может быть изменено в настройках СУБД так, чтобы деление на ноль приводило к ошибке.

**Примечание 3.** Псевдонимы вычисляемых полей, как и псевдонимы обычных полей, не могут быть использованы в блоке оператора WHERE для фильтрации записей.

Результатом приведенного ниже запроса:

```sql
SELECT artist, trackname,
       price * quantity AS revenue
FROM Songs
WHERE revenue > 20000;
```

является ошибка:

```
ERROR 1054: Unknown column 'revenue' in 'where clause'
```

При необходимости выполнить фильтрацию по вычисляемому полю выражение, определяющее это поле, придется продублировать.

Результатом приведенного ниже запроса:

```sql
SELECT artist, trackname,
       price * quantity AS revenue
FROM Songs
WHERE price * quantity > 20000;
```

является:

```
+-----------+----------------------+------------+
| artist    | trackname            | revenue    |
+-----------+----------------------+------------+
| Heart     | Crazy On You         | 62908.00   |
| Morrissey | Spent the Day in Bed | 2823985.00 |
+-----------+----------------------+------------+
```

**Примечание 4.** Если псевдоним вычисляемого поля совпадает с именем одного из полей таблицы, то сортировка будет осуществляться по значениям вычисляемого поля.

Результатом приведенного ниже запроса:

```sql
SELECT CONCAT(artist, ': ',trackname) AS trackname
FROM Songs
ORDER BY trackname;
```

является:

```
+---------------------------------+
| trackname                       |
+---------------------------------+
| Heart: Crazy On You             |
| Kate Bush: Running up That Hill |
| Morrissey: Spent the Day in Bed |
| The Sounds: My Lover            |
| The Sounds: Thrill              |
+---------------------------------+
```

Если необходимо осуществить сортировку по значениям поля таблицы, обращаться к полю следует через имя таблицы.

Результатом приведенного ниже запроса:

```sql
SELECT CONCAT(artist, ': ',trackname) AS trackname
FROM Songs
ORDER BY Songs.trackname;
```

является:

```
+---------------------------------+
| trackname                       |
+---------------------------------+
| Heart: Crazy On You             |
| The Sounds: My Lover            |
| Kate Bush: Running up That Hill |
| Morrissey: Spent the Day in Bed |
| The Sounds: Thrill              |
+---------------------------------+
```

Обратите внимание, значения поля `trackname` стали отсортированы по названиям песен, а не по результатам конкатенации.

**Примечание 5.** Если хотя бы один из аргументов, переданных в функцию `CONCAT()`, равняется `NULL`, функция вернет значение `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT CONCAT(1, NULL, 3) AS result1,
       CONCAT(NULL, 'two', 3) AS result2,
       CONCAT('one', 2, NULL) AS result3;
```

является:

```
+---------+---------+---------+
| result1 | result2 | result3 |
+---------+---------+---------+
| NULL    | NULL    | NULL    |
+---------+---------+---------+
```

**Примечание 6.** Если одно из объединяемых значений, переданных в функцию `CONCAT_WS()`, равняется `NULL`, при объединении оно будет проигнорировано.

Результатом приведенного ниже запроса:

```sql
SELECT CONCAT_WS('-', 1, NULL, 3) AS result1,
       CONCAT_WS('-', NULL, 'two', 3) AS result2,
       CONCAT_WS('-', 'one', 2, NULL) AS result3;
```

является:

```
+---------+---------+---------+
| result1 | result2 | result3 |
+---------+---------+---------+
| 1-3     | two-3   | one-2   |
+---------+---------+---------+
```

Если же значение `NULL` примет разделитель, функция `CONCAT_WS()` вернет значение `NULL`.

Результатом приведенного ниже запроса:

```sql
SELECT CONCAT_WS(NULL, 1, 2, 3) AS result;
```

является:

```
+--------+
| result |
+--------+
| NULL   |
+--------+
```

**Примечание 7.** Поскольку функции принимают значения и возвращают значения, возвращаемое значение одной функции может быть передано в качестве аргумента другой функции.

Результатом приведенного ниже запроса:

```sql
SELECT CONCAT('numbers: ', CONCAT_WS(', ', 1, 2, 3)) AS result;
```

является:

```
+------------------+
| result           |
+------------------+
| numbers: 1, 2, 3 |
+------------------+
```

В данном примере сначала выполняется вложенная функция `CONCAT_WS()` и возвращает строку `1`, `2`, `3`. Затем полученная строка передается в функцию `CONCAT()` в качестве второго аргумента.

<hr>

[Содержание](#содержание)
