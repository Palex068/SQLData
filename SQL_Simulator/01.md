# 1. Основы реляционной модели и SQL

В данном модуле рассматриваются основные понятия реляционной модели, а также различные виды SQL запросов к одной таблице базы данных

## Содержание
+ [1.0 Введение](#10-введение)
    + [Рекомендуемый алгоритм успешного прохождения каждого шага курса](#рекомендуемый-алгоритм-успешного-прохождения-каждого-шага-курса)
    + [Памятка о типичных ошибках и способах их исправления](#памятка-о-типичных-ошибках-и-способах-их-исправления)
    + [Структура уроков курса](#структура-уроков-курса)
+ [1.1 Отношение (таблица)](#11-отношение-таблица)
    + [Основные понятия реляционных баз данных](#основные-понятия-реляционных-баз-данных)
        + [Основные принципы реляционных баз данных](#основные-принципы-реляционных-баз-данных)
        + [Задание](#задание-1)
    + [Отношение, реляционная модель](#отношение-реляционная-модель)
        + [Задание](#задание-2)
    + [Выбор типов данных для полей](#выбор-типов-данных-для-полей)
        + [Основные типы данных SQL](#основные-типы-данных-sql)
        + [Рекомендации по выбору типов данных для полей таблицы.](#рекомендации-по-выбору-типов-данных-для-полей-таблицы)
        + [Задание](#задание-3)
    + [Создание таблицы](#создание-таблицы)
        + [Рекомендации по записи SQL запроса](#рекомендации-по-записи-sql-запроса)
        + [Задание](#задание-4)
    + [Вставка записи в таблицу](#вставка-записи-в-таблицу)
        + [Задание](#задание-5)
+ [1.2 Выборка данных](#12-выборка-данных)
    + [Выборка всех данных из таблицы;](#выборка-всех-данных-из-таблицы)
    + [Выборка данных из отдельных столбцов;](#выборка-данных-из-отдельных-столбцов)
    + [Присвоение новых имен столбцам при формировании выборки;](#присвоение-новых-имен-столбцам-при-формировании-выборки)
    + [Создание вычисляемых столбцов;](#создание-вычисляемых-столбцов)
    + [Вычисляемые столбцы, математические функции;](#вычисляемые-столбцы-математические-функции)
    + [Вычисляемые столбцы, логические функции;](#вычисляемые-столбцы-логические-функции)
    + [Выборка данных по простому условию;](#выборка-данных-по-простому-условию)
    + [Выборка данных с использованием логических выражений и операций;](#выборка-данных-с-использованием-логических-выражений-и-операций)
    + [Выборка данных, операторы BETWEEN, IN;](#выборка-данных-операторы-between-in)
    + [Выборка данных с сортировкой;](#выборка-данных-с-сортировкой)
    + [Выборка текстовых данных по шаблону, оператор LIKE.](#выборка-текстовых-данных-по-шаблону-оператор-like)

+ [1.3 Запросы, групповые операции](#13-запросы-групповые-операции)
+ [1.4 Вложенные запросы](#14-вложенные-запросы)
+ [1.5 Запросы корректировки данных](#15-запросы-корректировки-данных)
+ [1.6 Таблица "Командировки", запросы на выборку](#16-таблица-командировки-запросы-на-выборку)
+ [1.7 Таблица "Нарушения ПДД", запросы корректировки](#17-таблица-нарушения-пдд-запросы-корректировки)
+ [1.8 Глоссарий и поиск по курсу](#18-глоссарий-и-поиск-по-курсу)

[Оглавление](/SQL_Simulator/README.MD)

# 1.0 Введение

Здравствуйте, рады приветствовать Вас на курсе!

Наш курс является тренажером, поэтому состоит только из практических заданий. Перед тем как приступить, обязательно прочитайте информацию с этого шага.

## Рекомендуемый алгоритм успешного прохождения каждого шага курса

1. __Прочитайте текстовый материал__, он достаточно короткий и всегда имеет всю необходимую информацию для выполнения практического задания.
2. Eсли по тексту теории встречаются __примеры__ - скопируйте и вставьте их в окно кода, __запустите__ запрос, не отправляя на проверку (нажать черную кнопку __Запустить код__). Проанализируйте результат, если он (результат) является неожиданным или не понятным - еще раз вернитесь к теории и еще раз ее прочитайте.
3. Теперь можно приступать к выполнению практического задания. Прежде всего внимательно __прочитайте формулировку__, разберитесь, что именно нужно сделать (без этого совершенно нет смысла писать код SQL);
4. Если задание понятно - можно приступать к __реализации запроса__, тут два варианта - либо Вы __полностью напишете запрос на SQL__, либо поищите среди примеров похожий, __скопируйте его и начинайте его корректировать__ (скорее всего, когда пройдете десяток шагов, вариант с копированием отпадет, как ненужный).
5. Отправьте запрос на проверку.  Результата может быть два - либо запрос написан верно, и он проходит - можно переходить к следующему шагу. Либо запрос система не пропускает, в нем __допущена ошибка__, но "кто не ошибается, тот ничего и не делает...", __ошибки__ это __обязательный__ и __полезный элемент__ в процессе обучения;
6. Начинайте __отлаживать__ (исправлять) запрос, причем если Вам удастся это сделать __самостоятельно__ - значит Вы  действительно разобрались с материалом шага, можно переходить к следующему. Если же ошибки исправить не удается,  не спешите паниковать, читать и писать комментарии, лезть в Интернет - просто __вернитесь к 1 или 2-му пункту__ этого алгоритма.
7. Если же все-таки теория и примеры не помогают, воспользуйтесь __памяткой о типичных ошибках и способах их исправления__ (приведена ниже),  примерно половина ошибок связана с описанными в ней пунктами и, привыкнув каждый раз проверять свой запрос, Вы сбережете себе много часов и нервов (проверено на опыте).
8. Когда Вы напишете правильный запрос, его можно __опубликовать в решениях__, посмотреть решения других студентов и обсудить свое.
9. В комментариях можно __давать подсказки__ или делиться тем, что вызвало у Вас наибольшие трудности, только без спойлеров!
10. Очень полезно прочитать вопрос другого обучающегося и, __если Вы точно знаете ответ__, самостоятельно __ответить__ на его вопрос - это еще один способ закрепления материала, причем очень действенный (тоже проверено на опыте).
После выполнения заданий каждого модуля, Вы будете получать ссылку на __текстовый конспект__ этого модуля, по которому удобно ориентироваться по пройденному материалу.

[Содержание](#содержание)

<hr>

## Памятка о типичных ошибках и способах их исправления

Эта памятка написана, чтобы помочь Вам __самостоятельно находить ошибки в своих запросах__. Если ваш запрос не принимается системой, то возвращайтесь на эту страничку и пройдитесь по всем пунктам:

1. Приведите синтаксис запроса к общепринятому:
    + если у вас есть время, стоит изучить руководство по стилю SQL https://www.sqlstyle.guide/ru/
    + можете отформатировать ваш запрос с помощью, например, https://codebeautify.org/sqlformatter
    + в любом случае, информации и примеров в курсе достаточно для того, чтобы писать запросы корректно.
2. Проверьте, что ключевые слова, названия столбцов и значения в ячейках, которые необходимо найти, написаны правильно. Особенно обратите внимание, чтобы в русских названиях столбцов не было английских букв.

3. Проверьте, что:
+ количество открывающихся скобок равно количеству закрывающихся;
+ запятые разделяют перечисление столбцов, но не ключевые слова;
+ запросы разделяются точкой с запятой.
4. Проверьте, что последовательность команд указана верно (она отличается от последовательности выполнения команд в запросе):

```sql
  SELECT 'столбцы или * для выбора всех столбцов; обязательно'
    FROM 'таблица; обязательно'
   WHERE 'условие/фильтрация, например, city = 'Moscow'; необязательно'
GROUP BY 'столбец, по которому хотим сгруппировать данные; необязательно'
  HAVING 'условие/фильтрация на уровне сгруппированных данных; необязательно'
ORDER BY 'столбец, по которому хотим отсортировать вывод; необязательно'
```
5.  Если запрос включает подзапросы, выполните сначала подзапросы и удостоверьтесь, что получаете ожидаемый результат.

6. Прочитайте комментарии под заданием: большинство трудностей уже обсуждалось не один раз.

[Содержание](#содержание)

<hr>

## Структура уроков курса

**Первый шаг** каждого урока – краткий перечень рассматриваемых вопросов или типов запросов SQL, а также, при необходимости, описание структур данных, используемых в запросах. 

Все **остальные шаги**  – это задания, в большинстве из которых нужно написать запрос на языке SQL. На локальный компьютер ничего ставить не нужно, запросы пишутся и проверяются на платформе. Перед выполнением задания необходимо прочитать краткий теоретический материал, затем разобрать пример и посмотреть, как он выполняется. Для каждого задания приводится результат, который должен получиться после выполнения запроса, а также необходимые пояснения.

На **последнем шаге** большинства уроков нужно придумать задание для рассматриваемой структуры данных, реализовать соответствующий запрос,  проверить его и при желании разместить в комментариях. В последнем модуле мы разместим лучшие запросы, и все смогут их выполнить и проголосовать за понравившиеся.

**Важно!** На платформе Stepik используется **MySQL**, версия 8.0.21.

[Содержание](#содержание)

<hr>

# 1.1 Отношение (таблица)

## Основные понятия реляционных баз данных

Реляционная модель была разработана в конце 1960-х годов Е.Ф.Коддом . Она определяет способ представления данных (структуру данных), методы защиты данных (целостность данных), и операции, которые можно выполнять с данными (манипулирование данными). Эта модель лежит в основе всех реляционных баз данных до настоящего времени.

[Содержание](#содержание)

<hr>

### Основные принципы реляционных баз данных:

+ все данные на концептуальном уровне представляются в виде объектов, заданных в виде строк и столбцов, называемых отношением, более распространенное название – таблица;
+ в пересечение строки и столбца таблицы можно занести только одно значение;
+ все операции выполняются над целыми отношениями и результатом этих операций является отношение.

Пример отношения: 

![01](/SQL_Simulator/img/01_01.jpg)

На примере таблицы Сотрудник рассмотрим терминологию реляционных баз данных:
+ **отношение**  – это структура данных целиком, набор записей (в обычном понимании – таблица) , в  примере –это **Сотрудник**;
+ **кортеж** – это каждая строка , содержащая данные (более распространенный термин – запись ), например, `<001, Борин С.А, 234-01-23, программист>`, все кортежи в отношении должны быть различны;
+ **мощность** – число кортежей в таблице (проще говоря, число записей), в данном случае 3, мощность отношения может быть любой (от 0 до бесконечности), порядок следования кортежей - неважен;
+ **атрибут** – это столбец в таблице (более распространенный термин – поле ), в примере – `Табельный номер`, `Фамилия И.О.`, `Телефон`, `Должность`.
+ **размерность** – это число атрибутов в таблице, в данном случае – 4;<br>
размерность отношения должна быть больше 0, порядок следования атрибутов существенен;
+ **домен атрибута** – это допустимые значения (неповторяющиеся), которые можно занести в поле , например для атрибута `Должность` домен – `{инженер, программист}`.

[Содержание](#содержание)

<hr>

### Задание 1

Для таблицы **Сотрудник** отметьте верные ячейки (В каждом столбце и строке - один правильный ответ).

![01](/SQL_Simulator/img/01_02.PNG)

[Содержание](#содержание)

<hr>

## Отношение, реляционная модель

База данных, в том числе и реляционная, используется для формального описания  некоторой предметной области реального мира, например, склада, учебного процесса и пр. Обязательным этапом перед созданием базы данных является ее проектирование (этот процесс разбирается в следующих модулях).

В первом модуле будем рассматривать простейшие предметные области, информацию о которых можно описать в виде одной таблицы. Каждая такая таблица ассоциируется с неким информационным объектом или событием реального мира – человеком, документом, посещением и т.д. 

**Пример.**

Рассмотрим некоторый склад, на котором хранятся книги. Известно название книги, ее автор, количество экземпляров на складе и ее цена.

Всю эту информацию можно представить в виде таблицы, состоящей из 4 столбцов (приведено только 4 записи, на самом деле их значительно больше):


Название | Автор | Цена, руб | Количество
-|-|-|-
Мастер и Маргарита | Булгаков М.А. | 670.99 | 3
Белая гвардия | Булгаков М.А. | 540.50 | 5
Идиот | Достоевский Ф.М. | 460 | 10
Братья Карамазовы | Достоевский Ф.М. | 799.01 | 2

Перед созданием таблицы в базе данных необходимо описать ее структуру. Для этого выполняется следующая последовательность шагов:

1. Дать таблице имя, пусть она будет называться `book`, вот некоторые правила для выбора имен таблиц:
+ может включать латинские буквы, цифры и знак подчеркивания, должно начинаться с буквы;
+ имя должно быть уникальным в пределах базы данных.

Также **рекомендуется**:
+ чтобы имя было существительным в единственном числе;
+ имя должно быть понятным и соответствовать тому объекту, который оно описывает;
+ имя должно быть как можно короче, максимум до 10 символов.

**Важно**. Имена таблиц являются регистрозависимыми из-за операционной системы на которой работает **stepik**, то есть имя `book` и `Book` – разные имена. Рекомендуется для записи имен таблиц использовать только строчные (маленькие) буквы.

2. Определить структуру таблицы, из каких атрибутов(столбцов, полей) она будет состоять,  в нашем случае это:
+ `title` – поле для хранения названия книги;
+ `author` – поле с фамилией автора книги;
+ `priсe` – цена книги;
+ `amount` – количество книг.

**Правила по выбору имени поля информационного объекта:**

+ может включать латинские буквы, цифры и знак подчеркивания, должно начинаться с буквы;
+ имя поля должно быть уникальным в пределах таблицы.

**Рекомендации по выбору имени поля информационного объекта:**

+ имя должно быть понятным и соответствовать тем данным, которые хранятся в поле;
+ имя может состоять из нескольких слов, тогда слова разделяются подчеркиванием, после подчеркивания слово пишется с маленькой буквы.

3. Включить ключевое поле `book_id`, которое является ОБЯЗАТЕЛЬНЫМ ЭЛЕМЕНТОМ каждой реляционной таблицы. Ключевое поле является уникальным для каждой записи, однозначно определяет запись и в дальнейшем будет использоваться для связей с другими таблицами.

**Рекомендации по именованию  ключевых полей:**

+ имя должно состоять  из двух частей: начинаться с названия таблицы, которой поле принадлежит, затем через подчеркивание необходимо указать id.

Таким образом, наша таблица `book` будет выглядеть следующим образом:


book_id | title | author | price | amount
-|-|-|-|-
1 | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3
2 | Белая гвардия | Булгаков М.А. | 540.50 | 5
3 | Идиот | Достоевский Ф.М. | 460 | 10
4 | Братья Карамазовы | Достоевский Ф.М. | 799.01 | 2

[Содержание](#содержание)

<hr>

### Задание 2

Отметьте ПРАВИЛЬНЫЕ имена, которые можно выбрать в качестве названий таблиц или полей.

+ [x] name_book
+ [ ] name -author
+ [ ] price(rub)
+ [ ] book store
+ [x] price_rub
+ [x] store

[Содержание](#содержание)

<hr>

## Выбор типов данных для полей

После описания структуры таблицы необходимо выбрать типы данных для каждого поля.

[Содержание](#содержание)

<hr>

### Основные типы данных SQL:

Тип данных | Описание | Пример
-|-|-
`INT` <br>`INTEGER` | Целое число, могут принимать значения <br> от -2 147 483 648 до 2 147 483 647 | -567 <br>1205
`DECIMAL` <br>`NUMERIC` | Вещественное число, в скобках указывается <br>максимальная длина числа (включает символы слева и справа от десятичной запятой) и количество знаков после запятой. Можно использовать оба этих типа, они эквивалентны, принимают значения в диапазоне $-10^{38}+1$ до $10^{38}-1$.<br>DECIMAL(4,1)<br> NUMERIC(6,3) | 34.6<br>-3.294
`DATE` | Дата в формате ГГГГ-ММ-ДД <br>26 июля 2020 года<br>3 января 2021 года |  2020-07-26<br>2021-01-03
`VARCHAR` | Строка длиной не более 255 символов, в скобках указывается максимальная длина строки, которая может храниться в поле `VARCHAR(10)`(рассматриваются однобайтовые кодировки, для которых число в скобках соответствует максимальному количеству символов в строке) | пример<br>описание

[Содержание](#содержание)

<hr>

### Рекомендации по выбору типов данных для полей таблицы.

+ Выбирайте минимальный тип данных исходя из максимального значения поля. Например, если максимальный текст, который может быть записан в поле, имеет длину 25 символов, значит нужно использовать тип `VARCHAR(25)`.
+ Для описания ключевого поля используйте описание `INT PRIMARY KEY AUTO_INCREMENT`. Это значит, что в поле будут заноситься различные целые числа, при этом они будут автоматически генерироваться (каждая следующая строка будет иметь значение ключа на 1 больше предыдущего).

Определим тип данных для каждого поля таблицы `book`:

book_id | title | author | price | amount
-|-|-|-|-
1 | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3
2 | Белая гвардия | Булгаков М.А. | 540.50 | 5
3 | Идиот | Достоевский Ф.М. | 460 | 10
4 | Братья Карамазовы | Достоевский Ф.М. | 799.01 | 2

+ `book_id` - ключевой столбец, целое число, которое должно генерироваться автоматически  - `INT PRIMARY KEY AUTO_INCREMENT`;
+ `title` - строка текста, ее длина выбирается в зависимости от данных, которые предполагается хранить в поле, предположим, что название книги не превышает 50 символов - `VARCHAR(50)`;
+ `author` - строка текста - `VARCHAR(30)`;
+ `priсe` - для описание денежного значения используется числовой тип данных с двумя знаками после запятой - `DECIMAL(8,2)`;
+ `amount` - целое число - `INT`.

[Содержание](#содержание)

<hr>

### Задание 3

Сопоставьте значения и типы данных, с помощью которых их можно описать.

![01](/SQL_Simulator/img/01_03.PNG)

[Содержание](#содержание)

<hr>

## Создание таблицы

*На этом шаге нужно написать и проверить SQL запрос. Сначала кратко описывается структура и особенности запроса, приводится пример. А затем формулируется задание, для которого нужно реализовать запрос.*

Для создания таблицы используется SQL-запрос. В нем указывается какая таблица создается, из каких атрибутов(полей) она состоит и какой тип данных имеет каждое поле, при необходимости указывается описание полей (ключевое поле и т.д.). Его структура :

+ ключевые слова : `CREATE TABLE`
+ имя создаваемой таблицы;
+ открывающая круглая скобка `(`;
+ название поля и его описание, которое включает тип поля и другие необязательные характеристики;
+ запятая;
+ название поля и его описание;
+ ...
+ закрывающая скобка `)`.

Пример. Создадим таблицу `genre` следующей структуры:

Поле | Тип, описание
-|-
genre_id | INT PRIMARY KEY AUTO_INCREMENT
name_genre | VARCHAR(30)

Запрос:

```sql
CREATE TABLE genre(
    genre_id INT PRIMARY KEY AUTO_INCREMENT, 
    name_genre VARCHAR(30)
);
```

Созданная таблица - пустая.

[Содержание](#содержание)

<hr>

### Рекомендации по записи SQL запроса

Ключевые слова: SQL не является регистрозависимым языком (CREATE и create - одно и тоже ключевое слово). 
Ключевые слова SQL и типы данных рекомендуется  записывать прописными (большими) буквами.
Имена таблиц и полей - строчными (маленькими) буквами.
SQL-запрос можно писать на нескольких строках.
В конце SQL-запроса ставится точка с запятой (хотя если Вы пишете один запрос, это необязательно).

[Содержание](#содержание)

<hr>

## Задание 4

Сформулируйте SQL запрос для создания таблицы `book`, занесите  его в окно кода (расположено ниже)  и отправьте на проверку (кнопка **Отправить**). Структура таблицы `book`:


Поле | Тип, описание
-|-
`book_id` | `INT PRIMARY KEY AUTO_INCREMENT`
`title` | `VARCHAR(50)`
`author` | `VARCHAR(30)`
`price` | `DECIMAL(8, 2)`
`amount` | `INT`

При записи сохраняйте порядок следования полей. 

```sql
CREATE TABLE book(
     book_id INT PRIMARY KEY AUTO_INCREMENT,
       title VARCHAR(50),
      author VARCHAR(30),
       price DECIMAL(8, 2),
      amount INT
);
```

[Содержание](#содержание)

<hr>

## Вставка записи в таблицу

*На каждом шаге можно посмотреть, как  работает запрос примера. Для этого нужно скопировать его код в окно для ввода и нажать на черную кнопку Запустить код (не отправляя на проверку). Те запросы, которые уже проверены, можно не удалять, а просто закомментировать, используя /* и */.*

Для занесения новой записи в таблицу используется SQL запрос, в котором указывается в какую таблицу, в какие поля заносить новые значения. Структура запроса:

+ ключевые слова `INSERT INTO` (ключевое слово `INTO` можно пропустить);
+ имя таблицы, в которую добавляется запись;
+ открывающая круглая скобка `(`;
+ список полей через запятую, в которые следует занести новые данные;
+ закрывающая скобка `)`;
+ ключевое слово `VALUES`;
+ открывающая круглая скобка `(`;
+ список значений через запятую, которые заносятся в соответствующие поля, при этом текстовые значения заключаются в кавычки, числовые значения записываются без кавычек, в качестве разделителя целой и дробной части используется точка;
+ закрывающая скобка `)`.

**Пример**. В таблицу, состоящую из двух столбцов добавим новую строку, при этом в `поле1` заносится `значение1`,  в `поле2` - `значение2`.

```sql
INSERT INTO таблица(поле1, поле2) 
VALUES (значение1, значение2);
```

В результате выполнения запроса новая запись заносится в конец обновляемой таблицы.

При составлении списка полей и списка значений необходимо учитывать следующее:
+ количество полей и количество значений в списках должны совпадать;
+ должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках, поэтому первый элемент списка значений должен относиться к первому столбцу в списке столбцов, второй – ко второму столбцу и т.д.;
+ типы данных элементов в списке значений должны быть совместимы с типами данных соответствующих столбцов таблицы ( целое число можно занести в поле типа `DECIMAL`, обратная операция - недопустима);
новые значения нельзя добавлять в поля, описанные как `PRIMARY KEY AUTO_INCREMENT`;
+ рекомендуется заполнять все поля записи, если же поле пропущено, значение этого поля зависит от установленных по умолчанию значений, если значения не установлены - на данной платформе вставляется пустое значение (`NULL`).

**Пример**

Вставим новую запись в таблицу `genre`, созданную на предыдущем шаге ( в первых двух строках показана структура таблицы, далее - ее содержимое):


genre_id | name_genre
-|-
`INT PRIMARY KEY AUTO_INCREMENT` | `VARCHAR(30)`
1 | Роман

Заносится только значение поля name_genre, значение ключевого поля формируется автоматически.

Результат:  в таблицу будет вставлена новая строка, после запуска запроса на платформе **stepik**, имеем:

![01](/SQL_Simulator/img/01_04.jpg)

Чтобы увидеть как именно выглядит таблица `genre`, можно добавить SQL запрос, который выберет все записи из таблицы:

```sql
SELECT * FROM genre;
```

Результат:

![01](/SQL_Simulator/img/01_05.jpg)

[Содержание](#содержание)

<hr>

## Задание 5

Занесите новую строку в таблицу `book` (текстовые значения (тип `VARCHAR`) заключать либо в двойные, либо в одинарные кавычки):


book_id | title | author | price | amount
-|-|-|-|-
`INT PRIMARY KEY AUTO_INCREMENT` | `VARCHAR(50)` | `VARCHAR(30)` | `DECIMAL(8,2)` | `INT`
1 | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3

Рекомендация: текстовые поля копируйте из таблицы, представленной в задании, и вставляйте в запрос во избежание ошибок... 

Результат:

```
Affected rows: 1
Query result:
+---------+--------------------+---------------+--------+--------+
| book_id | title              | author        | price  | amount |
+---------+--------------------+---------------+--------+--------+
| 1       | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3      |
+---------+--------------------+---------------+--------+--------+
```

```sql
INSERT INTO book (title, author, price, amount)
VALUES ('Мастер и Маргарита', 'Булгаков М.А.', 670.99, 3);
SELECT *
FROM book
```

[Содержание](#содержание)

<hr>

## Задание 5

Занесите три последние записи в таблицу `book`,  первая запись уже добавлена на предыдущем шаге:

book_id | title | author | price | amount
-|-|-|-|-
1 | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3
2 | Белая гвардия | Булгаков М.А. | 540.50 | 5
3 | Идиот | Достоевский Ф.М. | 460 | 10
4 | Братья Карамазовы | Достоевский Ф.М. | 799.01 | 2

Каждая строка вставляется отдельным SQL запросом, запросы обязательно разделять точкой с запятой. Для просмотра полученной таблицы после запросов на добавление записей вставить:

```sql
SELECT * FROM book;
```

Результат : 

```
Affected rows: 1
Affected rows: 1
Affected rows: 1
Query result:
+---------+--------------------+------------------+--------+--------+
| book_id | title              | author           | price  | amount |
+---------+--------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия      | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот              | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы  | Достоевский Ф.М. | 799.01 | 2      |
+---------+--------------------+------------------+--------+--------+
```

ВАЖНО! При вставке строк в таблицу значения ключевых столбцов (в данном случае `book_id`) указывать НЕ НУЖНО. 

```sql
INSERT INTO book (
        title,
        author,
        price,
        amount
    )
VALUES (
        'Белая гвардия',
        'Булгаков М.А.',
        540.50,
        5
    ),
    (
        'Идиот',
        'Достоевский Ф.М.',
        460.00,
        10
    ),
    (
        'Братья Карамазовы',
        'Достоевский Ф.М.',
        799.01,
        2
    );
SELECT *
FROM book
```

[Содержание](#содержание)

<hr>

# 1.2 Выборка данных

## Структура и наполнение таблицы

Все запросы будут формулироваться для таблицы `book`


`book_id` | `title` | `author` | `price` | `amount`
-|-|-|-|-
`INT PRIMARY KEY AUTO_INCREMENT` | `VARCHAR(50)` | `VARCHAR(30)` | `DECIMAL(8,2)` | `INT`
1 | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3
2 | Белая гвардия | Булгаков М.А. | 540.50 | 5
3 | Идиот | Достоевский Ф.М. | 460.00 | 10
4 | Братья Карамазовы | Достоевский Ф.М. | 799.01 | 2
5 | Стихотворения и поэмы | Есенин С.А. | 650.00 | 15

## Выборка всех данных из таблицы; 

Для того чтобы отобрать все данные из таблицы используется SQL запрос следующей структуры: 

+ ключевое слово `SELECT`; 
+ символ  `*`; 
+ ключевое слово `FROM`; 
+ имя таблицы.

Результатом является таблица, в которую включены все строки и столбцы указанной в запросе таблицы.

**Пример**

Выбрать все записи таблицы *book* .

Запрос:

```sql
SELECT * 
FROM book;
```

**Задание**

Вывести информацию о всех книгах, хранящихся на складе.

Для этого: 
+ Напишите SQL запрос в окне кода; 
+ Отправьте на проверку (кнопка  Отправить); 
+ Если запрос работает неверно, исправьте его и снова отправьте на проверку.

**Важно!** В окне кода можно использовать комментарии для сохранения разных вариантов запросов или пояснений. Комментарии заключаются в /* и */

Результат:

```
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
Affected rows: 5
```

```sql
SELECT *
FROM book
```

[Содержание](#содержание)

<hr>

## Выборка данных из отдельных столбцов;

Для того чтобы отобрать данные из определенных столбцов таблицы используется SQL запрос следующей структуры: 
+ ключевое слово `SELECT` ; 
+ список столбцов таблицы через запятую; 
+ ключевое слово `FROM` ; 
+ имя таблицы.

Результатом является таблица, в которую включены все данные из указанных после `SELECT` столбцов исходной таблицы.

Пример

Выбрать названия книг и их количества из таблицы book .

Запрос:

```sql
SELECT title,
    amount
FROM book;
```

Результат:

```
+-----------------------+--------+ 
|title                  | amount |
+-----------------------+--------+ 
| Мастер и Маргарита    | 3      | 
| Белая гвардия         | 5      | 
| Идиот                 | 10     | 
| Братья Карамазовы     | 2      | 
| Стихотворения и поэмы | 15     |
+-----------------------+--------+
```

Пояснение. Чтобы посмотреть, как работает запрос примера, скопируйте его код в окно для ввода и нажмите на черную кнопку Запустить код. После запуска выведется результат запроса, который можно сравнить с приведенным образцом. 

**Задание**

Выбрать авторов, название книг и их цену из таблицы `book`.

Результат:

```
+------------------+-----------------------+--------+
| author           | title                 | price  |
+------------------+-----------------------+--------+
| Булгаков М.А.    | Мастер и Маргарита    | 670.99 |
| Булгаков М.А.    | Белая гвардия         | 540.50 |
| Достоевский Ф.М. | Идиот                 | 460.00 |
| Достоевский Ф.М. | Братья Карамазовы     | 799.01 |
| Есенин С.А.      | Стихотворения и поэмы | 650.00 |
+------------------+-----------------------+--------+
Affected rows: 5
```

```sql
SELECT author,
    title,
    price
FROM book;
```

[Содержание](#содержание)

<hr>

## Присвоение новых имен столбцам при формировании выборки; 

Для того чтобы отобрать данные из определенных столбцов таблицы и одновременно задать столбцам новые названия в результате выборки используется SQL запрос следующей структуры: 
+ ключевое слово `SELECT`; 
+ имя столбца;
+ ключевое слово `AS`;
+ новое название столбца (можно русскими буквами), выводимое в результате запроса, но это должно быть одно слово, если название состоит из двух слов – соединяйте их подчеркиванием, например, `Количество_книг`;
+ запятая;
+ имя столбца;
+ ...
+ ключевое слово `FROM`; 
+ имя таблицы.

В одном запросе можно использовать и имена столбцов из таблицы, и новые названия.

Результатом является таблица, в которую включены все данные из указанных после `SELECT` столбцов исходной таблицы. Каждому столбцу в результате запроса присваивается новое имя, заданное после `AS`, или столбец получает имя столбца исходной таблицы, если `AS` отсутствует.

Пример

Выбрать все названия книг и их количества из таблицы `book` , для столбца `title` задать новое имя Название.

Запрос:

```sql
SELECT title AS Название, amount 
FROM book;
```

Результат:

```
+-----------------------+--------+
| Название              | amount |
+-----------------------+--------+ 
| Мастер и Маргарита    | 3      |
| Белая гвардия         | 5      | 
| Идиот                 | 10     |
| Братья Карамазовы     | 2      |
| Стихотворения и поэмы | 15     |
+-----------------------+--------+
```

**Задание**

Выбрать названия книг и авторов из таблицы `book`, для поля `title` задать имя(псевдоним) Название, для поля `author` –  Автор. 

Результат:

```
+-----------------------+------------------+
| Название              | Автор            |
+-----------------------+------------------+
| Мастер и Маргарита    | Булгаков М.А.    |
| Белая гвардия         | Булгаков М.А.    |
| Идиот                 | Достоевский Ф.М. |
| Братья Карамазовы     | Достоевский Ф.М. |
| Стихотворения и поэмы | Есенин С.А.      |
+-----------------------+------------------+
Affected rows: 5
```

```sql
SELECT title AS Название,
      author AS Автор
  FROM book;
```

[Содержание](#содержание)

<hr>

## Создание вычисляемых столбцов; 

**Выборка данных с созданием вычисляемого столбца**

С помощью SQL запросов можно осуществлять вычисления по каждой строке таблицы с помощью вычисляемого столбца. Для него в списке полей после оператора `SELECT` указывается выражение и задается имя.

Выражение может включать имена столбцов, константы, знаки операций, встроенные функции.

Результатом является таблица, в которую включены все данные из указанных после `SELECT` столбцов, а также новый столбец, в каждой строке которого вычисляется заданное выражение.

**Пояснение от слушателя.** Можно осуществлять арифметические и логические вычисления над целым столбцом, результатом будет новый столбец.

**Пример**

Вывести всю информацию о книгах, а также для каждой позиции посчитать ее стоимость (произведение цены на количество). Вычисляемому столбцу дать имя `total` .

Запрос:

```sql
SELECT title,
    author,
    price,
    amount,
    price * amount AS total
FROM book;
```

Результат:

```
+-----------------------+------------------+--------+--------+---------+ 
| title                 | author           | price  | amount | total   | 
+-----------------------+------------------+--------+--------+---------+ 
| Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      | 2012.97 | 
| Белая гвардия         | Булгаков М.А.    | 540.50 | 5      | 2702.50 | 
| Идиот                 | Достоевский Ф.М. | 460.00 | 10     | 4600.00 | 
| Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      | 1598.02 | 
| Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     | 9750.00 |
+-----------------------+------------------+--------+--------+---------+ 
```

**Задание**

Для упаковки каждой книги требуется один лист бумаги, цена которого `1` рубль `65` копеек. Посчитать стоимость упаковки для каждой книги (сколько денег потребуется, чтобы упаковать все экземпляры книги). В запросе вывести название книги, ее количество и стоимость упаковки, последний столбец назвать `pack`. 

Результат:

+-----------------------+--------+-------+
| title                 | amount | pack  |
+-----------------------+--------+-------+
| Мастер и Маргарита    | 3      | 4.95  |
| Белая гвардия         | 5      | 8.25  |
| Идиот                 | 10     | 16.50 |
| Братья Карамазовы     | 2      | 3.30  |
| Стихотворения и поэмы | 15     | 24.75 |
+-----------------------+--------+-------+
Affected rows: 5

```sql
SELECT title,
    amount,
    1.65 * amount AS pack
FROM book;
```

[Содержание](#содержание)

<hr>

## Вычисляемые столбцы, математические функции; 

**Выборка данных, вычисляемые столбцы, математические функции**

В SQL реализовано множество  [математических функций](https://docs.microsoft.com/ru-ru/sql/t-sql/functions/mathematical-functions-transact-sql?view=sql-server-ver15) для работы с числовыми данными. В таблице приведены некоторые из них.

Функция | Описание | Пример
-|-|-
`CEILING(x)` | возвращает наименьшее целое число, большее или равное x <br>(округляет до целого числа в большую сторону) | CEILING(4.2) = 5<br>CEILING(-5.8) = -5
`ROUND(x, k)` | округляет значение x до k знаков после запятой, <br>если k не указано – x округляется до целого | ROUND(4.361)=4<br>ROUND(5.86592,1)=5.9
`FLOOR(x)` | возвращает наибольшее целое число, меньшее или равное x <br>(округляет до  целого числа в меньшую сторону) | FLOOR(4.2)=4 <br>FLOOR(-5.8)=-6
`POWER(x, y)` | возведение x в степень y | POWER(3,4)=81.0
`SQRT(x)` | квадратный корень из x | SQRT(4)=2.0<br>SQRT(2)=1.41...
`DEGREES(x)` | конвертирует значение x из радиан в градусы | DEGREES(3) = 171.8...
`RADIANS(x)` | конвертирует значение x из градусов в радианы | RADIANS(180)=3.14...
`ABS(x)` | модуль числа x | ABS(-1) = 1<br>ABS(1) = 1
`PI()` | pi = 3.1415926... |  

**Пояснение.**   Существуют разные способы округления чисел. В SQL реализовано **математическое округление**. Для округления вещественного числа нужно в записи числа выбрать разряд в дробной части, до которого производится округление. Цифра, записанная в выбранном разряде: не меняется, если следующая за ней справа цифра - 0, 1, 2, 3 или 4; увеличивается на единицу, если следующая за ней справа цифра - 5,6,7,8 или 9.

**Пример** 

Для каждой книги из таблицы `book` вычислим налог на добавленную стоимость (имя столбца `tax`) , который включен в цену и составляет k = 18%,  а также цену книги (`price_tax`) без него. Формулы для вычисления:

$tax= \dfrac{price \cdot \dfrac{k}{100}}{1 + \dfrac{k}{100}} $,<br>
$pricetax= \dfrac{price}{1 + \dfrac{k}{100}} $

Значение НДС в 18% взято для ПРИМЕРА, чтобы показать как использовать функции округления.

**Запрос:**

```sql
SELECT title,
    price,
    (price * 18 / 100) /(1 + 18 / 100) AS tax,
    price /(1 + 18 / 100) AS price_tax
FROM book;
```
Результат:

```
+-----------------------+--------+----------------+------------+
| title                 | price  | tax            | price_tax  |
+-----------------------+--------+----------------+------------+
| Мастер и Маргарита    | 670.99 | 102.3544067797 | 568.635593 |
| Белая гвардия         | 540.50 | 82.4491525424  | 458.050847 |
| Идиот                 | 460.00 | 70.1694915254  | 389.830508 |
| Братья Карамазовы     | 799.01 | 121.8828813559 | 677.127119 |
| Стихотворения и поэмы | 650.00 | 99.1525423729  | 550.847458 |
+-----------------------+--------+----------------+------------+
```

Сумма налога и цена книги без налога – это деньги, поэтому количество знаков после запятой у этих чисел должно быть 2. Следовательно необходимо округлить полученные значения.

Запрос:

```sql
SELECT title,
    price,
    ROUND((price * 18 / 100) /(1 + 18 / 100), 2) AS tax,
    ROUND(price /(1 + 18 / 100), 2) AS price_tax
FROM book;
```
Результат:

```
+-----------------------+--------+--------+-----------+
| title                 | price  | tax    | price_tax |
+-----------------------+--------+--------+-----------+
| Мастер и Маргарита    | 670.99 | 102.35 | 568.64    |
| Белая гвардия         | 540.50 | 82.45  | 458.05    |
| Идиот                 | 460.00 | 70.17  | 389.83    |
| Братья Карамазовы     | 799.01 | 121.88 | 677.13    |
| Стихотворения и поэмы | 650.00 | 99.15  | 550.85    |
+-----------------------+--------+--------+-----------+
```

**Задание**

В конце года цену каждой книги на складе пересчитывают – снижают ее на 30%. Написать SQL запрос, который из таблицы book выбирает названия, авторов, количества и вычисляет новые цены книг. Столбец с новой ценой назвать `new_price`, цену округлить до 2-х знаков после запятой.

Результат:

```
+-----------------------+------------------+--------+-----------+
| title                 | author           | amount | new_price |
+-----------------------+------------------+--------+-----------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      | 469.69    |
| Белая гвардия         | Булгаков М.А.    | 5      | 378.35    |
| Идиот                 | Достоевский Ф.М. | 10     | 322.00    |
| Братья Карамазовы     | Достоевский Ф.М. | 2      | 559.31    |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 455.00    |
+-----------------------+------------------+--------+-----------+
```

```sql
SELECT title,
    author,
    amount,
    ROUND(price * 0.7, 2) AS new_price
    FROM book;
```

[Содержание](#содержание)

<hr>

## Вычисляемые столбцы, логические функции; 

**Выборка данных, вычисляемые столбцы, логические функции**

В SQL реализована возможность заносить в поле значение в зависимости от условия. Для этого используется функция `IF()`:

```sql
IF(логическое_выражение, выражение_1, выражение_2)
```

Функция вычисляет `логическое_выражение`, если оно истина – в поле заносится значение `выражения_1`, в противном случае –  значение `выражения_2`. Все три параметра `IF()` являются обязательными.

Допускается использование вложенных функций, вместо `выражения_1` или `выражения_2` может стоять новая функция `IF`.

**Пример**

Для каждой книги из таблицы `book` установим скидку следующим образом: если количество книг меньше `4`, то скидка будет составлять `50%` от цены, в противном случае `30%`.

Запрос:

```sql
SELECT title,
    amount,
    price,
    IF(amount < 4, price * 0.5, price * 0.7) AS sale
FROM book;
```

Результат:

```
+-----------------------+--------+--------+---------+
| title                 | amount | price  | sale    |
+-----------------------+--------+--------+---------+
| Мастер и Маргарита    | 3      | 670.99 | 335.495 |
| Белая гвардия         | 5      | 540.50 | 378.350 |
| Идиот                 | 10     | 460.00 | 322.000 |
| Братья Карамазовы     | 2      | 799.01 | 399.505 |
| Стихотворения и поэмы | 15     | 650.00 | 455.000 |
+-----------------------+--------+--------+---------+
```

Цена по скидке должна отображаться с двумя знаками после запятой, добавим в запрос округление:

```sql
SELECT title,
    amount,
    price,
    ROUND(IF(amount < 4, price * 0.5, price * 0.7), 2) AS sale
FROM book;
```

Результат:

```
+-----------------------+--------+--------+--------+
| title                 | amount | price  | sale   |
+-----------------------+--------+--------+--------+
| Мастер и Маргарита    | 3      | 670.99 | 335.50 |
| Белая гвардия         | 5      | 540.50 | 378.35 |
| Идиот                 | 10     | 460.00 | 322.00 |
| Братья Карамазовы     | 2      | 799.01 | 399.51 |
| Стихотворения и поэмы | 15     | 650.00 | 455.00 |
+-----------------------+--------+--------+--------+
```

**Пример**

Усложним вычисление скидки в зависимости от количества книг. Если количество книг меньше `4` – то скидка `50%`, меньше `11` – `30%`, в остальных случаях – `10%`. И еще укажем какая именно скидка на каждую книгу.

Запрос:

```sql
SELECT title,
    amount,
    price,
    ROUND(
        IF(
            amount < 4,
            price * 0.5,
            IF(amount < 11, price * 0.7, price * 0.9)
        ),
        2
    ) AS sale,
    IF(
        amount < 4,
        'скидка 50%',
        IF(amount < 11, 'скидка 30%', 'скидка 10%')
    ) AS Ваша_скидка
FROM book;
```
Результат:

```
+-----------------------+--------+--------+--------+-------------+
| title                 | amount | price  | sale   | Ваша_скидка |
+-----------------------+--------+--------+--------+-------------+
| Мастер и Маргарита    | 3      | 670.99 | 335.50 | скидка 50%  |
| Белая гвардия         | 5      | 540.50 | 378.35 | скидка 30%  |
| Идиот                 | 10     | 460.00 | 322.00 | скидка 30%  |
| Братья Карамазовы     | 2      | 799.01 | 399.51 | скидка 50%  |
| Стихотворения и поэмы | 15     | 650.00 | 585.00 | скидка 10%  |
+-----------------------+--------+--------+--------+-------------+
```

**Задание**

При анализе продаж книг выяснилось, что наибольшей популярностью пользуются книги Михаила Булгакова, на втором месте книги Сергея Есенина. Исходя из этого решили поднять цену книг Булгакова на `10%`, а цену книг Есенина - на `5%`. Написать запрос, куда включить автора, название книги и новую цену, последний столбец назвать `new_price`. Значение округлить до двух знаков после запятой.

**Пояснение**
+ фамилию автора задавать с инициалами (как занесено в таблице), заключая в одинарные или двойные кавычки;
+ для сравнения на равенство использовать знак =, например author = "Булгаков М.А.".

```sql
SELECT author,
    title,
    ROUND(
        IF(
            author = 'Булгаков М.А.',
            price * 1.1,
            IF(
                author = 'Есенин С.А.',
                price * 1.05,
                price
            )
        ),
        2
    ) AS new_price,
    FROM book;
```

[Содержание](#содержание)

<hr>

## Выборка данных по простому условию; 

С помощью запросов можно включать в итоговую выборку не все строки исходной таблицы, а только те, которые отвечают некоторому условию. Для этого после указания таблицы, откуда выбираются данные, задается ключевое слово `WHERE` и логическое выражение, от результата которого зависит будет ли включена строка в выборку или нет. Если условие – истина, то строка(запись)  включается в выборку, если ложь – нет.

Логическое выражение может включать операторы сравнения (равно `=`, не равно `<>`, больше `>`, меньше `<`, больше или равно `>=`, меньше или равно `<=`) и выражения, допустимые в SQL.

**Пример**

Вывести название и цену тех книг, цены которых меньше 600 рублей.

Запрос:

```sql
SELECT title,
    price
FROM book
WHERE price < 600;
```

Результат:

```
+---------------+--------+
| title         | price  |
+---------------+--------+
| Белая гвардия | 540.50 |
| Идиот         | 460.00 |
+---------------+--------+
```
**Пример**

Вывести название, автора  и стоимость (цена умножить на количество) тех книг, стоимость которых больше `4000` рублей

Запрос:

```sql
SELECT title,
    author,
    price * amount AS total
FROM book
WHERE price * amount > 4000;
```
Результат:

```
+-----------------------+------------------+---------+
| title                 | author           | total   |
+-----------------------+------------------+---------+
| Идиот                 | Достоевский Ф.М. | 4600.00 |
| Стихотворения и поэмы | Есенин С.А.      | 9750.00 |
+-----------------------+------------------+---------+
```

**Пояснение**

В логическом выражении после `WHERE` нельзя использовать названия столбцов, присвоенные им с помощью `AS`,  так как при выполнении запроса сначала вычисляется логическое выражение для каждой строки исходной таблицы, выбираются строки, для которых оно истинно. А только после этого формируется "шапка запроса" – столбцы, включаемые в запрос.

**Задание**

Вывести автора, название  и цены тех книг, количество которых меньше `10`.

Результат:

```
+------------------+--------------------+--------+
| author           | title              | price  |
+------------------+--------------------+--------+
| Булгаков М.А.    | Мастер и Маргарита | 670.99 |
| Булгаков М.А.    | Белая гвардия      | 540.50 |
| Достоевский Ф.М. | Братья Карамазовы  | 799.01 |
+------------------+--------------------+--------+
```

```sql
SELECT author,
    title,
    price
FROM book
WHERE amount < 10;
```

[Содержание](#содержание)

<hr>

## Выборка данных с использованием логических выражений и операций; 

**Выборка данных, логические операции**

Логическое выражение после ключевого слова `WHERE` кроме операторов сравнения  и выражений может включать  логические операции (И `and`, ИЛИ `or`, НЕ `not`) и круглые скобки, изменяющие приоритеты выполнения операций.

Приоритеты операций:

1. круглые скобки
2. умножение  (*),  деление (/)
3. сложение  (+), вычитание (-)
4. операторы сравнения (=, >, <, >=, <=, <>)
5. NOT
6. AND
7. OR

**Пример**

Вывести название, автора и цену тех книг, которые написал Булгаков, ценой больше 600 рублей

Запрос:

```sql
SELECT title, author, price 
FROM book
WHERE price > 600 AND author = 'Булгаков М.А.';
```

Результат:

```
+--------------------+---------------+--------+
| title              | author        | price  |
+--------------------+---------------+--------+
| Мастер и Маргарита | Булгаков М.А. | 670.99 |
+--------------------+---------------+--------+
```
**Пример**

Вывести название, цену  тех книг, которые написал Булгаков или Есенин, ценой больше 600 рублей

Запрос:

```sql
SELECT title, author, price 
FROM book
WHERE (author = 'Булгаков М.А.' OR author = 'Есенин С.А.') AND price > 600;
```

Результат:

```
+-----------------------+---------------+--------+
| title                 | author        | price  |
+-----------------------+---------------+--------+
| Мастер и Маргарита    | Булгаков М.А. | 670.99 |
| Стихотворения и поэмы | Есенин С.А.   | 650.00 |
+-----------------------+---------------+--------+
```

В данном запросе обязательно нужно поставить скобки, так как без них сначала вычисляется  `author = 'Есенин С.А.'` `and` `price > 600`, а потом уже выражение через `or`. Без скобок были бы отобраны все книги Булгакова и те книги Есенина, цена которых больше `600`.

Запрос:

```sql
SELECT title, author, price 
FROM book
WHERE author = 'Булгаков М.А.' OR author = 'Есенин С.А.' AND price > 600;
```

Результат (сравните с предыдущим):

```
+-----------------------+---------------+--------+
| title                 | author        | price  |
+-----------------------+---------------+--------+
| Мастер и Маргарита    | Булгаков М.А. | 670.99 |
| Белая гвардия         | Булгаков М.А. | 540.50 |
| Стихотворения и поэмы | Есенин С.А.   | 650.00 |
+-----------------------+---------------+--------+
```

**Задание**

Вывести название, автора,  цену  и количество всех книг, цена которых меньше 500 или больше 600, а стоимость всех экземпляров этих книг больше или равна 5000.

Результат:

```
+-----------------------+-------------+--------+--------+
| title                 | author      | price  | amount |
+-----------------------+-------------+--------+--------+
| Стихотворения и поэмы | Есенин С.А. | 650.00 | 15     |
+-----------------------+-------------+--------+--------+
```
```sql
SELECT
    title,
    author,
    price,
    amount
FROM
    book
WHERE
    (
        price < 500
        OR price > 600
    )
    AND price * amount >= 5000;
```

[Содержание](#содержание)

<hr>

## Выборка данных, операторы BETWEEN, IN; 

**Выборка данных, операторы `BETWEEN`, `IN`**

Логическое выражение после ключевого слова `WHERE` может включать операторы  `BETWEEN` и `IN`. Приоритет  у этих операторов такой же как у операторов сравнения, то есть они выполняются раньше, чем `NOT`, `AND`, `OR`.

Оператор `BETWEEN` позволяет отобрать данные, относящиеся к некоторому интервалу, включая его границы.

**Пример**

Выбрать названия и количества тех книг, количество которых от 5 до 14 включительно.

Запрос:

```sql
SELECT title, amount 
FROM book
WHERE amount BETWEEN 5 AND 14;
```

Результат:

```
+---------------+--------+
| title         | amount |
+---------------+--------+
| Белая гвардия | 5      |
| Идиот         | 10     |
+---------------+--------+
```

Этот запрос можно реализовать по-другому, результат будет точно такой же.

```sql
SELECT title, amount 
FROM book
WHERE amount >= 5 AND amount <=14;
```

Оператор  `IN`  позволяет выбрать данные, соответствующие значениям из списка.

**Пример**

Выбрать названия и цены книг, написанных Булгаковым или Достоевским.

Запрос:

```sql
SELECT title, price 
FROM book
WHERE author IN ('Булгаков М.А.', 'Достоевский Ф.М.');
```

Результат:

```
+--------------------+--------+
| title              | price  |
+--------------------+--------+
| Мастер и Маргарита | 670.99 |
| Белая гвардия      | 540.50 |
| Идиот              | 460.00 |
| Братья Карамазовы  | 799.01 |
+--------------------+--------+
```

Этот запрос можно реализовать по-другому, результат будет точно такой же.

```sql
SELECT title, price 
FROM book
WHERE author = 'Булгаков М.А.' OR author = 'Достоевский Ф.М.';
```

**Задание**

Вывести название и авторов тех книг, цены которых принадлежат интервалу от 540.50 до 800 (включая границы),  а количество или 2, или 3, или 5, или 7 .

Результат:

```
+--------------------+------------------+
| title              | author           |
+--------------------+------------------+
| Мастер и Маргарита | Булгаков М.А.    |
| Белая гвардия      | Булгаков М.А.    |
| Братья Карамазовы  | Достоевский Ф.М. |
+--------------------+------------------+
```

```sql
SELECT
    title,
    author
FROM
    book
WHERE
    price BETWEEN 540.5
    AND 800
    AND amount IN (2, 3, 5, 7);
```
[Содержание](#содержание)

<hr>

## Выборка данных с сортировкой;

При выборке можно указывать столбец или несколько столбцов, по которым необходимо отсортировать отобранные строки. Для этого используются ключевые слова `ORDER BY`, после которых задаются имена столбцов. При этом строки сортируются по первому столбцу. Если указан второй столбец, сортировка осуществляется только для тех строк, у которых значения первого столбца одинаковы. По умолчанию `ORDER BY` выполняет сортировку по возрастанию. Чтобы управлять направлением сортировки вручную, после имени столбца указывается ключевое слово `ASC` (по возрастанию) или `DESC` (по убыванию). 

Столбцы после ключевого слова `ORDER BY` можно задавать:

+ названием столбца;
+ номером столбца;
+ именем столбца (указанным после AS).

**Пример**

Вывести название, автора и цены книг. Информацию  отсортировать по названиям книг в алфавитном порядке.

Запрос:

```sql
SELECT title, author, price
FROM book
ORDER BY title;
```

Результат:

```
+-----------------------+------------------+--------+
| title                 | author           | price  |
+-----------------------+------------------+--------+
| Белая гвардия         | Булгаков М.А.    | 540.50 |
| Братья Карамазовы     | Достоевский Ф.М. | 799.01 |
| Идиот                 | Достоевский Ф.М. | 460.00 |
| Мастер и Маргарита    | Булгаков М.А.    | 670.99 |
| Стихотворения и поэмы | Есенин С.А.      | 650.00 |
+-----------------------+------------------+--------+
```

Аналогичный результат получится при использовании запроса:

```sql
SELECT title, author, price
FROM book
ORDER BY 1;
```

**Пример**

Вывести автора, название и количество книг, в отсортированном в алфавитном порядке по автору и по убыванию количества, для тех книг, цены которых меньше 750 рублей.

Запрос:

```sql
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, amount DESC;
```

Результат:

```
+------------------+-----------------------+------------+
| author           | title                 | Количество |
+------------------+-----------------------+------------+
| Булгаков М.А.    | Белая гвардия         | 5          |
| Булгаков М.А.    | Мастер и Маргарита    | 3          |
| Достоевский Ф.М. | Идиот                 | 10         |
| Есенин С.А.      | Стихотворения и поэмы | 15         |
+------------------+-----------------------+------------+
```

Можно использовать другие варианты записи запроса:

```sql
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, Количество DESC;
```
```sql
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY 1, 3 DESC;
```

**Важно!** Если названия столбцов заключены в кавычки, то при использовании их в сортировке, необходимо записывать их БЕЗ КАВЫЧЕК.

**Задание**

Вывести  автора и название  книг, количество которых принадлежит интервалу от 2 до 14 (включая границы). Информацию  отсортировать сначала по авторам (в обратном алфавитном порядке), а затем по названиям книг (по алфавиту).

Результат:

```
+------------------+--------------------+
| author           | title              |
+------------------+--------------------+
| Достоевский Ф.М. | Братья Карамазовы  |
| Достоевский Ф.М. | Идиот              |
| Булгаков М.А.    | Белая гвардия      |
| Булгаков М.А.    | Мастер и Маргарита |
+------------------+--------------------+
```

```sql
SELECT
    author,
    title
FROM
    book
WHERE
    amount BETWEEN 2
    AND 14
ORDER BY
    author DESC,
    title ASC;
```

[Содержание](#содержание)

<hr>

## Выборка текстовых данных по шаблону, оператор LIKE. 

**Выборка данных, оператор LIKE**

Оператор `LIKE` используется для сравнения строк. В отличие от операторов отношения равно (`=`) и не равно (`<>`), `LIKE` позволяет сравнивать строки не на полное совпадение (не совпадение), а в соответствии с шаблоном. Шаблон может включать **обычные символы** и **символы-шаблоны**. При сравнении с шаблоном, его обычные символы должны в точности совпадать с символами, указанными в строке. Символы-шаблоны могут совпадать с произвольными элементами символьной строки.


Символ-шаблон | Описание | Пример
-|-|-
`%` | Любая строка, содержащая ноль или более символов | `SELECT` * `FROM` book `WHERE` author `LIKE` '%М.%'<br>выполняет поиск и выдает все книги, инициалы авторов которых содержат «М.»
_ (подчеркивание) | Любой одиночный символ | `SELECT` * `FROM` book `WHERE` title `LIKE` 'Поэм_'<br>выполняет поиск и выдает все книги, названия которых либо «Поэма», либо «Поэмы» и пр.

**Пример 1**

Вывести названия книг, начинающихся с буквы «Б».

Запрос:

```sql
SELECT title 
FROM book
WHERE title LIKE 'Б%';
/* эквивалентное условие 
title LIKE 'б%'
*/
```

Результат:

```
+-------------------+
| title             |
+-------------------+
| Белая гвардия     |
| Братья Карамазовы |
+-------------------+
```
Строчные и прописные буквы в строках эквивалентны.

**Пример 2**

Вывести название книг, состоящих ровно из 5 букв.

Запрос:

```sql
SELECT title FROM book 
WHERE title LIKE "_____"
```
Результат:

```
+-------+
| title |
+-------+
| Идиот |
| Поэмы |
+-------+
```

Для обозначения одного любого символа используется  "_", следовательно для обозначения 5 символов используется 5 подряд символов подчеркивания.

**Пример 3**

Вывести книги, название которых длиннее 5 символов:

Запрос:

```sql
SELECT title FROM book 
WHERE title LIKE "______%";
/* эквивалентные условия 
title LIKE "%______"
title LIKE "%______%"
*/
```

Результат:

```
+-----------------------+
| title                 |
+-----------------------+
| Мастер и Маргарита    |
| Белая гвардия         |
| Братья Карамазовы     |
| Стихотворения и поэмы |
| Дети полуночи         |
| Лирика                |
| Капитанская дочка     |
+-----------------------+
```

**Пояснение**<br>
Для того чтобы вывести названия, состоящие из любого количества символов после `LIKE` можно использовать шаблон "`%`", с помощью которого отбираются строки, состоящие из любого количества символов, в том числе и "пустые", поскольку `%` заменяет любое количество символов, в том числе и нулевое.

Чтобы указать, что в названии должен быть хотя бы один символ, можно использовать один из эквивалентных шаблонов:

+ `_%` - сначала идет символ, а за ним любое количество символов;
+ `%_` - сначала идет любое количество символов, а затем обязательный символ;
+ `%_%` - сначала идет любое количество символов, потом обязательный символ, а за ним любое количество символов.

**Пример 4**

Вывести названия книг, которые содержат букву "и" как отдельное слово, если считать, что слова в названии отделяются друг от друга пробелами и не содержат знаков препинания.

Запрос:

```sql
SELECT title FROM book 
WHERE   title LIKE "_% и _%" /*отбирает слово И внутри названия */
    OR title LIKE "и _%" /*отбирает слово И в начале названия */
    OR title LIKE "_% и" /*отбирает слово И в конце названия */
    OR title LIKE "и" /* отбирает название, состоящее из одного слова И */
```

Слово "и" может располагаться в названии в следующих позициях (при условии, что слова отделяются друг от друга пробелами):
+ в середине -  `_% и _%` - сначала идет любое количество символов (один обязательный), потом обязательный пробел, а за ним "и", снова обязательный пробел, и наконец любое количество символов (один обязательный);
+ в начале - `и _%` - сначала идет "и", обязательный пробел и любое количество символов (один обязательный);
+ в конце - `_% и` - сначала идет любое количество символов, затем обязательный пробел и буква "и":
+ одно слово в названии - "и".

Вместо `_%` можно использовать эквивалентные шаблоны `%_` и `%_%` .

В качестве обязательного символа (`_`), может быть и пробел, но, к сожалению, шаблоны для `LIKE` не позволяют исключить какой-то символ. Это можно сделать только с помощью регулярных выражений (будут рассмотрены в уроке 3.5)

Результат:

```
+-----------------------+
| title                 |
+-----------------------+
| Мастер и Маргарита    |
| Стихотворения и поэмы |
+-----------------------+
```

**Пример 5**

Вывести названия книг, которые состоят ровно из одного слова, если считать, что слова в названии отделяются друг от друга пробелами .

Запрос:

```sql
SELECT title FROM book 
WHERE title NOT LIKE "% %";    
```

Результат:

```
+--------+
| title  |
+--------+
| Идиот  |
| Лирика |
| Поэмы  |
+--------+
```

Пояснение

Отсутствие пробела в названии означает, что оно состоит из одного слова. Чтобы это проверить используется оператор `NOT LIKE`, который в данном случае отберет все названия, в которых нет пробелов.

**Задание**

Вывести название и автора тех книг, название которых состоит из двух и более слов, а инициалы автора содержат букву «С». Считать, что в названии слова отделяются друг от друга пробелами и не содержат знаков препинания, между фамилией автора и инициалами обязателен пробел, инициалы записываются без пробела в формате: буква, точка, буква, точка. Информацию отсортировать по названию книги в алфавитном порядке.

Результат:

+-----------------------+-------------+
| title                 | author      |
+-----------------------+-------------+
| Капитанская дочка     | Пушкин А.С. |
| Стихотворения и поэмы | Есенин С.А. |
+-----------------------+-------------+

Пояснение.
1. При записи условия, необходимо учесть, что слово в названии обязательно должно содержать  хотя бы один символ.
2. Инициалы в этом задании - это первая буква имени или отчества, после которой стоит точка.
3. Буква C должна быть написана в РУССКОЙ раскладке. Если не проходит решение - проверьте это.

**Важно!** Только для этого шага в таблицу добавлены новые записи.

```sql
SELECT
    title,
    author
FROM
    book
WHERE
    title LIKE "%_ _%"
    AND author LIKE "%С.%"
ORDER BY
    title;
```

## TODO

**Задание**

Придумайте один или несколько запросов к нашей таблице book. Проверьте, правильно ли они работают.

При желании можно формулировку запросов  разместить в комментариях.

Размещенные задания можно использовать для закрепления материала урока.

Оценивайте понравившиеся Вам запросы.

В последнем модуле создан отдельный урок, в котором мы разместим запросы, набравшие наибольшее количество лайков. 

Структура и наполнение таблицы `book`:

book_id | title | author | price | amount
-|-|-|-|-
INT PRIMARY KEY AUTO_INCREMENT | VARCHAR(50) | VARCHAR(30) | DECIMAL(8,2) | INT
1 | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3
2 | Белая гвардия | Булгаков М.А. | 540.50 | 5
3 | Идиот | Достоевский Ф.М. | 460.00 | 10
4 | Братья Карамазовы | Достоевский Ф.М. | 799.01 | 2
5 | Стихотворения и поэмы | Есенин С.А. | 650.00 | 15

[Содержание](#содержание)

<hr>

# 1.3 Запросы, групповые операции

[Содержание](#содержание)

<hr>

# 1.4 Вложенные запросы

[Содержание](#содержание)

<hr>

# 1.5 Запросы корректировки данных

[Содержание](#содержание)

<hr>

# 1.6 Таблица "Командировки", запросы на выборку

[Содержание](#содержание)

<hr>

# 1.7 Таблица "Нарушения ПДД", запросы корректировки

[Содержание](#содержание)

<hr>

# 1.8 Глоссарий и поиск по курсу

[Содержание](#содержание)

<hr>
