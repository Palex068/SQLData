# 1. Основы реляционной модели и SQL

В данном модуле рассматриваются основные понятия реляционной модели, а также различные виды SQL запросов к одной таблице базы данных

## Содержание
+ [1.0 Введение](#10-введение)
    + [Рекомендуемый алгоритм успешного прохождения каждого шага курса](#рекомендуемый-алгоритм-успешного-прохождения-каждого-шага-курса)
    + [Памятка о типичных ошибках и способах их исправления](#памятка-о-типичных-ошибках-и-способах-их-исправления)
    + [Структура уроков курса](#структура-уроков-курса)
+ [1.1 Отношение (таблица)](#11-отношение-таблица)
    + [Основные понятия реляционных баз данных](#основные-понятия-реляционных-баз-данных)
        + [Основные принципы реляционных баз данных](#основные-принципы-реляционных-баз-данных)
        + [Задание](#задание-1)
    + [Отношение, реляционная модель](#отношение-реляционная-модель)
        + [Задание](#задание-2)
    + [Выбор типов данных для полей](#выбор-типов-данных-для-полей)
        + [Основные типы данных SQL](#основные-типы-данных-sql)
        + [Рекомендации по выбору типов данных для полей таблицы.](#рекомендации-по-выбору-типов-данных-для-полей-таблицы)
        + [Задание](#задание-3)
    + [Создание таблицы](#создание-таблицы)
        + [Рекомендации по записи SQL запроса](#рекомендации-по-записи-sql-запроса)
        + [Задание](#задание-4)
    + [Вставка записи в таблицу](#вставка-записи-в-таблицу)
        + [Задание](#задание-5)
+ [1.2 Выборка данных](#12-выборка-данных)
    + [Выборка всех данных из таблицы;](#выборка-всех-данных-из-таблицы)
    + [Выборка данных из отдельных столбцов;](#выборка-данных-из-отдельных-столбцов)
    + [Присвоение новых имен столбцам при формировании выборки;](#присвоение-новых-имен-столбцам-при-формировании-выборки)
    + [Создание вычисляемых столбцов;](#создание-вычисляемых-столбцов)
    + [Вычисляемые столбцы, математические функции;](#вычисляемые-столбцы-математические-функции)
    + [Вычисляемые столбцы, логические функции;](#вычисляемые-столбцы-логические-функции)
    + [Выборка данных по простому условию;](#выборка-данных-по-простому-условию)
    + [Выборка данных с использованием логических выражений и операций;](#выборка-данных-с-использованием-логических-выражений-и-операций)
    + [Выборка данных, операторы BETWEEN, IN;](#выборка-данных-операторы-between-in)
    + [Выборка данных с сортировкой;](#выборка-данных-с-сортировкой)
    + [Выборка текстовых данных по шаблону, оператор LIKE.](#выборка-текстовых-данных-по-шаблону-оператор-like)
+ [1.3 Запросы, групповые операции](#13-запросы-групповые-операции)
    + [Выборка уникальных элементов столбца;](#выборка-уникальных-элементов-столбца)
    + [Выборка данных (групповые функции sum и count);](#выборка-данных-групповые-функции-sum-и-count)
    + [Выборка данных (групповые функции min, max и avg);](#выборка-данных-групповые-функции-min-max-и-avg)
    + [Выборка данных с вычислением (групповые функции);](#выборка-данных-с-вычислением-групповые-функции)
    + [Вычисления по таблице целиком;](#вычисления-по-таблице-целиком)
    + [Выборка данных по условию (групповые функции)](#выборка-данных-по-условию-групповые-функции)
    + [Выборка данных по условию (групповые функции WHERE и HAVING).](#выборка-данных-по-условию-групповые-функции-where-и-having)
+ [1.4 Вложенные запросы](#14-вложенные-запросы)
    + [Вложенный запрос, возвращающий одно значение](#вложенный-запрос-возвращающий-одно-значение)
    + [Использование вложенного запроса в выражении](#использование-вложенного-запроса-в-выражении)
    + [Вложенный запрос, оператор IN](#вложенный-запрос-оператор-in)
    + [Вложенный запрос, операторы ANY и ALL](#вложенный-запрос-операторы-any-и-all)
    + [Вложенный запрос после SELECT](#вложенный-запрос-после-select)
+ [1.5 Запросы корректировки данных](#15-запросы-корректировки-данных)
    + [Создание пустой таблицы](#создание-пустой-таблицы)
    + [Добавление записей в таблицу](#добавление-записей-в-таблицу)
    + [Добавление записей из другой таблицы](#добавление-записей-из-другой-таблицы)
    + [Запросы на обновление](#запросы-на-обновление)
    + [Запросы на обновление нескольких столбцов](#запросы-на-обновление-нескольких-столбцов)
    + [Запросы на обновление нескольких таблиц](#запросы-на-обновление-нескольких-таблиц)
    + [Запросы на удаление](#запросы-на-удаление)
    + [Запросы на создание таблицы](#запросы-на-создание-таблицы)
    + [TODO](#todo-3)
+ [1.6 Таблица "Командировки", запросы на выборку](#16-таблица-командировки-запросы-на-выборку)
+ [1.7 Таблица "Нарушения ПДД", запросы корректировки](#17-таблица-нарушения-пдд-запросы-корректировки)
+ [1.8 Глоссарий и поиск по курсу](#18-глоссарий-и-поиск-по-курсу)

[Оглавление](/SQL_Simulator/README.MD)

# 1.0 Введение

Здравствуйте, рады приветствовать Вас на курсе!

Наш курс является тренажером, поэтому состоит только из практических заданий. Перед тем как приступить, обязательно прочитайте информацию с этого шага.

## Рекомендуемый алгоритм успешного прохождения каждого шага курса

1. __Прочитайте текстовый материал__, он достаточно короткий и всегда имеет всю необходимую информацию для выполнения практического задания.
2. Eсли по тексту теории встречаются __примеры__ - скопируйте и вставьте их в окно кода, __запустите__ запрос, не отправляя на проверку (нажать черную кнопку __Запустить код__). Проанализируйте результат, если он (результат) является неожиданным или не понятным - еще раз вернитесь к теории и еще раз ее прочитайте.
3. Теперь можно приступать к выполнению практического задания. Прежде всего внимательно __прочитайте формулировку__, разберитесь, что именно нужно сделать (без этого совершенно нет смысла писать код SQL);
4. Если задание понятно - можно приступать к __реализации запроса__, тут два варианта - либо Вы __полностью напишете запрос на SQL__, либо поищите среди примеров похожий, __скопируйте его и начинайте его корректировать__ (скорее всего, когда пройдете десяток шагов, вариант с копированием отпадет, как ненужный).
5. Отправьте запрос на проверку.  Результата может быть два - либо запрос написан верно, и он проходит - можно переходить к следующему шагу. Либо запрос система не пропускает, в нем __допущена ошибка__, но "кто не ошибается, тот ничего и не делает...", __ошибки__ это __обязательный__ и __полезный элемент__ в процессе обучения;
6. Начинайте __отлаживать__ (исправлять) запрос, причем если Вам удастся это сделать __самостоятельно__ - значит Вы  действительно разобрались с материалом шага, можно переходить к следующему. Если же ошибки исправить не удается,  не спешите паниковать, читать и писать комментарии, лезть в Интернет - просто __вернитесь к 1 или 2-му пункту__ этого алгоритма.
7. Если же все-таки теория и примеры не помогают, воспользуйтесь __памяткой о типичных ошибках и способах их исправления__ (приведена ниже),  примерно половина ошибок связана с описанными в ней пунктами и, привыкнув каждый раз проверять свой запрос, Вы сбережете себе много часов и нервов (проверено на опыте).
8. Когда Вы напишете правильный запрос, его можно __опубликовать в решениях__, посмотреть решения других студентов и обсудить свое.
9. В комментариях можно __давать подсказки__ или делиться тем, что вызвало у Вас наибольшие трудности, только без спойлеров!
10. Очень полезно прочитать вопрос другого обучающегося и, __если Вы точно знаете ответ__, самостоятельно __ответить__ на его вопрос - это еще один способ закрепления материала, причем очень действенный (тоже проверено на опыте).
После выполнения заданий каждого модуля, Вы будете получать ссылку на __текстовый конспект__ этого модуля, по которому удобно ориентироваться по пройденному материалу.

[Содержание](#содержание)

<hr>

## Памятка о типичных ошибках и способах их исправления

Эта памятка написана, чтобы помочь Вам __самостоятельно находить ошибки в своих запросах__. Если ваш запрос не принимается системой, то возвращайтесь на эту страничку и пройдитесь по всем пунктам:

1. Приведите синтаксис запроса к общепринятому:
    + если у вас есть время, стоит изучить руководство по стилю SQL https://www.sqlstyle.guide/ru/
    + можете отформатировать ваш запрос с помощью, например, https://codebeautify.org/sqlformatter
    + в любом случае, информации и примеров в курсе достаточно для того, чтобы писать запросы корректно.
2. Проверьте, что ключевые слова, названия столбцов и значения в ячейках, которые необходимо найти, написаны правильно. Особенно обратите внимание, чтобы в русских названиях столбцов не было английских букв.

3. Проверьте, что:
+ количество открывающихся скобок равно количеству закрывающихся;
+ запятые разделяют перечисление столбцов, но не ключевые слова;
+ запросы разделяются точкой с запятой.
4. Проверьте, что последовательность команд указана верно (она отличается от последовательности выполнения команд в запросе):

```sql
  SELECT 'столбцы или * для выбора всех столбцов; обязательно'
    FROM 'таблица; обязательно'
   WHERE 'условие/фильтрация, например, city = 'Moscow'; необязательно'
GROUP BY 'столбец, по которому хотим сгруппировать данные; необязательно'
  HAVING 'условие/фильтрация на уровне сгруппированных данных; необязательно'
ORDER BY 'столбец, по которому хотим отсортировать вывод; необязательно'
```
5.  Если запрос включает подзапросы, выполните сначала подзапросы и удостоверьтесь, что получаете ожидаемый результат.

6. Прочитайте комментарии под заданием: большинство трудностей уже обсуждалось не один раз.

[Содержание](#содержание)

<hr>

## Структура уроков курса

**Первый шаг** каждого урока – краткий перечень рассматриваемых вопросов или типов запросов SQL, а также, при необходимости, описание структур данных, используемых в запросах. 

Все **остальные шаги**  – это задания, в большинстве из которых нужно написать запрос на языке SQL. На локальный компьютер ничего ставить не нужно, запросы пишутся и проверяются на платформе. Перед выполнением задания необходимо прочитать краткий теоретический материал, затем разобрать пример и посмотреть, как он выполняется. Для каждого задания приводится результат, который должен получиться после выполнения запроса, а также необходимые пояснения.

На **последнем шаге** большинства уроков нужно придумать задание для рассматриваемой структуры данных, реализовать соответствующий запрос,  проверить его и при желании разместить в комментариях. В последнем модуле мы разместим лучшие запросы, и все смогут их выполнить и проголосовать за понравившиеся.

**Важно!** На платформе Stepik используется **MySQL**, версия 8.0.21.

[Содержание](#содержание)

<hr>

# 1.1 Отношение (таблица)

## Основные понятия реляционных баз данных

Реляционная модель была разработана в конце 1960-х годов Е.Ф.Коддом . Она определяет способ представления данных (структуру данных), методы защиты данных (целостность данных), и операции, которые можно выполнять с данными (манипулирование данными). Эта модель лежит в основе всех реляционных баз данных до настоящего времени.

[Содержание](#содержание)

<hr>

### Основные принципы реляционных баз данных:

+ все данные на концептуальном уровне представляются в виде объектов, заданных в виде строк и столбцов, называемых отношением, более распространенное название – таблица;
+ в пересечение строки и столбца таблицы можно занести только одно значение;
+ все операции выполняются над целыми отношениями и результатом этих операций является отношение.

Пример отношения: 

![01](/SQL_Simulator/img/01_01.jpg)

На примере таблицы Сотрудник рассмотрим терминологию реляционных баз данных:
+ **отношение**  – это структура данных целиком, набор записей (в обычном понимании – таблица) , в  примере –это **Сотрудник**;
+ **кортеж** – это каждая строка , содержащая данные (более распространенный термин – запись ), например, `<001, Борин С.А, 234-01-23, программист>`, все кортежи в отношении должны быть различны;
+ **мощность** – число кортежей в таблице (проще говоря, число записей), в данном случае 3, мощность отношения может быть любой (от 0 до бесконечности), порядок следования кортежей - неважен;
+ **атрибут** – это столбец в таблице (более распространенный термин – поле ), в примере – `Табельный номер`, `Фамилия И.О.`, `Телефон`, `Должность`.
+ **размерность** – это число атрибутов в таблице, в данном случае – 4;<br>
размерность отношения должна быть больше 0, порядок следования атрибутов существенен;
+ **домен атрибута** – это допустимые значения (неповторяющиеся), которые можно занести в поле , например для атрибута `Должность` домен – `{инженер, программист}`.

[Содержание](#содержание)

<hr>

### Задание 1

Для таблицы **Сотрудник** отметьте верные ячейки (В каждом столбце и строке - один правильный ответ).

![01](/SQL_Simulator/img/01_02.PNG)

[Содержание](#содержание)

<hr>

## Отношение, реляционная модель

База данных, в том числе и реляционная, используется для формального описания  некоторой предметной области реального мира, например, склада, учебного процесса и пр. Обязательным этапом перед созданием базы данных является ее проектирование (этот процесс разбирается в следующих модулях).

В первом модуле будем рассматривать простейшие предметные области, информацию о которых можно описать в виде одной таблицы. Каждая такая таблица ассоциируется с неким информационным объектом или событием реального мира – человеком, документом, посещением и т.д. 

**Пример.**

Рассмотрим некоторый склад, на котором хранятся книги. Известно название книги, ее автор, количество экземпляров на складе и ее цена.

Всю эту информацию можно представить в виде таблицы, состоящей из 4 столбцов (приведено только 4 записи, на самом деле их значительно больше):


Название | Автор | Цена, руб | Количество
-|-|-|-
Мастер и Маргарита | Булгаков М.А. | 670.99 | 3
Белая гвардия | Булгаков М.А. | 540.50 | 5
Идиот | Достоевский Ф.М. | 460 | 10
Братья Карамазовы | Достоевский Ф.М. | 799.01 | 2

Перед созданием таблицы в базе данных необходимо описать ее структуру. Для этого выполняется следующая последовательность шагов:

1. Дать таблице имя, пусть она будет называться `book`, вот некоторые правила для выбора имен таблиц:
+ может включать латинские буквы, цифры и знак подчеркивания, должно начинаться с буквы;
+ имя должно быть уникальным в пределах базы данных.

Также **рекомендуется**:
+ чтобы имя было существительным в единственном числе;
+ имя должно быть понятным и соответствовать тому объекту, который оно описывает;
+ имя должно быть как можно короче, максимум до 10 символов.

**Важно**. Имена таблиц являются регистрозависимыми из-за операционной системы на которой работает **stepik**, то есть имя `book` и `Book` – разные имена. Рекомендуется для записи имен таблиц использовать только строчные (маленькие) буквы.

2. Определить структуру таблицы, из каких атрибутов(столбцов, полей) она будет состоять,  в нашем случае это:
+ `title` – поле для хранения названия книги;
+ `author` – поле с фамилией автора книги;
+ `priсe` – цена книги;
+ `amount` – количество книг.

**Правила по выбору имени поля информационного объекта:**

+ может включать латинские буквы, цифры и знак подчеркивания, должно начинаться с буквы;
+ имя поля должно быть уникальным в пределах таблицы.

**Рекомендации по выбору имени поля информационного объекта:**

+ имя должно быть понятным и соответствовать тем данным, которые хранятся в поле;
+ имя может состоять из нескольких слов, тогда слова разделяются подчеркиванием, после подчеркивания слово пишется с маленькой буквы.

3. Включить ключевое поле `book_id`, которое является ОБЯЗАТЕЛЬНЫМ ЭЛЕМЕНТОМ каждой реляционной таблицы. Ключевое поле является уникальным для каждой записи, однозначно определяет запись и в дальнейшем будет использоваться для связей с другими таблицами.

**Рекомендации по именованию  ключевых полей:**

+ имя должно состоять  из двух частей: начинаться с названия таблицы, которой поле принадлежит, затем через подчеркивание необходимо указать id.

Таким образом, наша таблица `book` будет выглядеть следующим образом:


book_id | title | author | price | amount
-|-|-|-|-
1 | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3
2 | Белая гвардия | Булгаков М.А. | 540.50 | 5
3 | Идиот | Достоевский Ф.М. | 460 | 10
4 | Братья Карамазовы | Достоевский Ф.М. | 799.01 | 2

[Содержание](#содержание)

<hr>

### Задание 2

Отметьте ПРАВИЛЬНЫЕ имена, которые можно выбрать в качестве названий таблиц или полей.

+ [x] name_book
+ [ ] name -author
+ [ ] price(rub)
+ [ ] book store
+ [x] price_rub
+ [x] store

[Содержание](#содержание)

<hr>

## Выбор типов данных для полей

После описания структуры таблицы необходимо выбрать типы данных для каждого поля.

[Содержание](#содержание)

<hr>

### Основные типы данных SQL:

Тип данных | Описание | Пример
-|-|-
`INT` <br>`INTEGER` | Целое число, могут принимать значения <br> от -2 147 483 648 до 2 147 483 647 | -567 <br>1205
`DECIMAL` <br>`NUMERIC` | Вещественное число, в скобках указывается <br>максимальная длина числа (включает символы слева и справа от десятичной запятой) и количество знаков после запятой. Можно использовать оба этих типа, они эквивалентны, принимают значения в диапазоне $-10^{38}+1$ до $10^{38}-1$.<br>DECIMAL(4,1)<br> NUMERIC(6,3) | 34.6<br>-3.294
`DATE` | Дата в формате ГГГГ-ММ-ДД <br>26 июля 2020 года<br>3 января 2021 года |  2020-07-26<br>2021-01-03
`VARCHAR` | Строка длиной не более 255 символов, в скобках указывается максимальная длина строки, которая может храниться в поле `VARCHAR(10)`(рассматриваются однобайтовые кодировки, для которых число в скобках соответствует максимальному количеству символов в строке) | пример<br>описание

[Содержание](#содержание)

<hr>

### Рекомендации по выбору типов данных для полей таблицы.

+ Выбирайте минимальный тип данных исходя из максимального значения поля. Например, если максимальный текст, который может быть записан в поле, имеет длину 25 символов, значит нужно использовать тип `VARCHAR(25)`.
+ Для описания ключевого поля используйте описание `INT PRIMARY KEY AUTO_INCREMENT`. Это значит, что в поле будут заноситься различные целые числа, при этом они будут автоматически генерироваться (каждая следующая строка будет иметь значение ключа на 1 больше предыдущего).

Определим тип данных для каждого поля таблицы `book`:

book_id | title | author | price | amount
-|-|-|-|-
1 | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3
2 | Белая гвардия | Булгаков М.А. | 540.50 | 5
3 | Идиот | Достоевский Ф.М. | 460 | 10
4 | Братья Карамазовы | Достоевский Ф.М. | 799.01 | 2

+ `book_id` - ключевой столбец, целое число, которое должно генерироваться автоматически  - `INT PRIMARY KEY AUTO_INCREMENT`;
+ `title` - строка текста, ее длина выбирается в зависимости от данных, которые предполагается хранить в поле, предположим, что название книги не превышает 50 символов - `VARCHAR(50)`;
+ `author` - строка текста - `VARCHAR(30)`;
+ `priсe` - для описание денежного значения используется числовой тип данных с двумя знаками после запятой - `DECIMAL(8,2)`;
+ `amount` - целое число - `INT`.

[Содержание](#содержание)

<hr>

### Задание 3

Сопоставьте значения и типы данных, с помощью которых их можно описать.

![01](/SQL_Simulator/img/01_03.PNG)

[Содержание](#содержание)

<hr>

## Создание таблицы

*На этом шаге нужно написать и проверить SQL запрос. Сначала кратко описывается структура и особенности запроса, приводится пример. А затем формулируется задание, для которого нужно реализовать запрос.*

Для создания таблицы используется SQL-запрос. В нем указывается какая таблица создается, из каких атрибутов(полей) она состоит и какой тип данных имеет каждое поле, при необходимости указывается описание полей (ключевое поле и т.д.). Его структура :

+ ключевые слова : `CREATE TABLE`
+ имя создаваемой таблицы;
+ открывающая круглая скобка `(`;
+ название поля и его описание, которое включает тип поля и другие необязательные характеристики;
+ запятая;
+ название поля и его описание;
+ ...
+ закрывающая скобка `)`.

Пример. Создадим таблицу `genre` следующей структуры:

Поле | Тип, описание
-|-
genre_id | INT PRIMARY KEY AUTO_INCREMENT
name_genre | VARCHAR(30)

Запрос:

```sql
CREATE TABLE genre(
    genre_id INT PRIMARY KEY AUTO_INCREMENT, 
    name_genre VARCHAR(30)
);
```

Созданная таблица - пустая.

[Содержание](#содержание)

<hr>

### Рекомендации по записи SQL запроса

Ключевые слова: SQL не является регистрозависимым языком (CREATE и create - одно и тоже ключевое слово). 
Ключевые слова SQL и типы данных рекомендуется  записывать прописными (большими) буквами.
Имена таблиц и полей - строчными (маленькими) буквами.
SQL-запрос можно писать на нескольких строках.
В конце SQL-запроса ставится точка с запятой (хотя если Вы пишете один запрос, это необязательно).

[Содержание](#содержание)

<hr>

## Задание 4

Сформулируйте SQL запрос для создания таблицы `book`, занесите  его в окно кода (расположено ниже)  и отправьте на проверку (кнопка **Отправить**). Структура таблицы `book`:


Поле | Тип, описание
-|-
`book_id` | `INT PRIMARY KEY AUTO_INCREMENT`
`title` | `VARCHAR(50)`
`author` | `VARCHAR(30)`
`price` | `DECIMAL(8, 2)`
`amount` | `INT`

При записи сохраняйте порядок следования полей. 

```sql
CREATE TABLE book(
     book_id INT PRIMARY KEY AUTO_INCREMENT,
       title VARCHAR(50),
      author VARCHAR(30),
       price DECIMAL(8, 2),
      amount INT
);
```

[Содержание](#содержание)

<hr>

## Вставка записи в таблицу

*На каждом шаге можно посмотреть, как  работает запрос примера. Для этого нужно скопировать его код в окно для ввода и нажать на черную кнопку Запустить код (не отправляя на проверку). Те запросы, которые уже проверены, можно не удалять, а просто закомментировать, используя /* и */.*

Для занесения новой записи в таблицу используется SQL запрос, в котором указывается в какую таблицу, в какие поля заносить новые значения. Структура запроса:

+ ключевые слова `INSERT INTO` (ключевое слово `INTO` можно пропустить);
+ имя таблицы, в которую добавляется запись;
+ открывающая круглая скобка `(`;
+ список полей через запятую, в которые следует занести новые данные;
+ закрывающая скобка `)`;
+ ключевое слово `VALUES`;
+ открывающая круглая скобка `(`;
+ список значений через запятую, которые заносятся в соответствующие поля, при этом текстовые значения заключаются в кавычки, числовые значения записываются без кавычек, в качестве разделителя целой и дробной части используется точка;
+ закрывающая скобка `)`.

**Пример**. В таблицу, состоящую из двух столбцов добавим новую строку, при этом в `поле1` заносится `значение1`,  в `поле2` - `значение2`.

```sql
INSERT INTO таблица(поле1, поле2) 
VALUES (значение1, значение2);
```

В результате выполнения запроса новая запись заносится в конец обновляемой таблицы.

При составлении списка полей и списка значений необходимо учитывать следующее:
+ количество полей и количество значений в списках должны совпадать;
+ должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках, поэтому первый элемент списка значений должен относиться к первому столбцу в списке столбцов, второй – ко второму столбцу и т.д.;
+ типы данных элементов в списке значений должны быть совместимы с типами данных соответствующих столбцов таблицы ( целое число можно занести в поле типа `DECIMAL`, обратная операция - недопустима);
новые значения нельзя добавлять в поля, описанные как `PRIMARY KEY AUTO_INCREMENT`;
+ рекомендуется заполнять все поля записи, если же поле пропущено, значение этого поля зависит от установленных по умолчанию значений, если значения не установлены - на данной платформе вставляется пустое значение (`NULL`).

**Пример**

Вставим новую запись в таблицу `genre`, созданную на предыдущем шаге ( в первых двух строках показана структура таблицы, далее - ее содержимое):


genre_id | name_genre
-|-
`INT PRIMARY KEY AUTO_INCREMENT` | `VARCHAR(30)`
1 | Роман

Заносится только значение поля name_genre, значение ключевого поля формируется автоматически.

Результат:  в таблицу будет вставлена новая строка, после запуска запроса на платформе **stepik**, имеем:

![01](/SQL_Simulator/img/01_04.jpg)

Чтобы увидеть как именно выглядит таблица `genre`, можно добавить SQL запрос, который выберет все записи из таблицы:

```sql
SELECT * FROM genre;
```

Результат:

![01](/SQL_Simulator/img/01_05.jpg)

[Содержание](#содержание)

<hr>

## Задание 5

Занесите новую строку в таблицу `book` (текстовые значения (тип `VARCHAR`) заключать либо в двойные, либо в одинарные кавычки):


book_id | title | author | price | amount
-|-|-|-|-
`INT PRIMARY KEY AUTO_INCREMENT` | `VARCHAR(50)` | `VARCHAR(30)` | `DECIMAL(8,2)` | `INT`
1 | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3

Рекомендация: текстовые поля копируйте из таблицы, представленной в задании, и вставляйте в запрос во избежание ошибок... 

Результат:

```
Affected rows: 1
Query result:
+---------+--------------------+---------------+--------+--------+
| book_id | title              | author        | price  | amount |
+---------+--------------------+---------------+--------+--------+
| 1       | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3      |
+---------+--------------------+---------------+--------+--------+
```

```sql
INSERT INTO book (title, author, price, amount)
VALUES ('Мастер и Маргарита', 'Булгаков М.А.', 670.99, 3);
SELECT *
FROM book
```

[Содержание](#содержание)

<hr>

## Задание 5

Занесите три последние записи в таблицу `book`,  первая запись уже добавлена на предыдущем шаге:

book_id | title | author | price | amount
-|-|-|-|-
1 | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3
2 | Белая гвардия | Булгаков М.А. | 540.50 | 5
3 | Идиот | Достоевский Ф.М. | 460 | 10
4 | Братья Карамазовы | Достоевский Ф.М. | 799.01 | 2

Каждая строка вставляется отдельным SQL запросом, запросы обязательно разделять точкой с запятой. Для просмотра полученной таблицы после запросов на добавление записей вставить:

```sql
SELECT * FROM book;
```

Результат : 

```
Affected rows: 1
Affected rows: 1
Affected rows: 1
Query result:
+---------+--------------------+------------------+--------+--------+
| book_id | title              | author           | price  | amount |
+---------+--------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия      | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот              | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы  | Достоевский Ф.М. | 799.01 | 2      |
+---------+--------------------+------------------+--------+--------+
```

ВАЖНО! При вставке строк в таблицу значения ключевых столбцов (в данном случае `book_id`) указывать НЕ НУЖНО. 

```sql
INSERT INTO book (
        title,
        author,
        price,
        amount
    )
VALUES (
        'Белая гвардия',
        'Булгаков М.А.',
        540.50,
        5
    ),
    (
        'Идиот',
        'Достоевский Ф.М.',
        460.00,
        10
    ),
    (
        'Братья Карамазовы',
        'Достоевский Ф.М.',
        799.01,
        2
    );
SELECT *
FROM book
```

[Содержание](#содержание)

<hr>

# 1.2 Выборка данных

## Структура и наполнение таблицы

Все запросы будут формулироваться для таблицы `book`


`book_id` | `title` | `author` | `price` | `amount`
-|-|-|-|-
`INT PRIMARY KEY AUTO_INCREMENT` | `VARCHAR(50)` | `VARCHAR(30)` | `DECIMAL(8,2)` | `INT`
1 | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3
2 | Белая гвардия | Булгаков М.А. | 540.50 | 5
3 | Идиот | Достоевский Ф.М. | 460.00 | 10
4 | Братья Карамазовы | Достоевский Ф.М. | 799.01 | 2
5 | Стихотворения и поэмы | Есенин С.А. | 650.00 | 15

## Выборка всех данных из таблицы; 

Для того чтобы отобрать все данные из таблицы используется SQL запрос следующей структуры: 

+ ключевое слово `SELECT`; 
+ символ  `*`; 
+ ключевое слово `FROM`; 
+ имя таблицы.

Результатом является таблица, в которую включены все строки и столбцы указанной в запросе таблицы.

**Пример**

Выбрать все записи таблицы *book* .

Запрос:

```sql
SELECT * 
FROM book;
```

**Задание**

Вывести информацию о всех книгах, хранящихся на складе.

Для этого: 
+ Напишите SQL запрос в окне кода; 
+ Отправьте на проверку (кнопка  Отправить); 
+ Если запрос работает неверно, исправьте его и снова отправьте на проверку.

**Важно!** В окне кода можно использовать комментарии для сохранения разных вариантов запросов или пояснений. Комментарии заключаются в /* и */

Результат:

```
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
Affected rows: 5
```

```sql
SELECT *
FROM book
```

[Содержание](#содержание)

<hr>

## Выборка данных из отдельных столбцов;

Для того чтобы отобрать данные из определенных столбцов таблицы используется SQL запрос следующей структуры: 
+ ключевое слово `SELECT` ; 
+ список столбцов таблицы через запятую; 
+ ключевое слово `FROM` ; 
+ имя таблицы.

Результатом является таблица, в которую включены все данные из указанных после `SELECT` столбцов исходной таблицы.

Пример

Выбрать названия книг и их количества из таблицы book .

Запрос:

```sql
SELECT title,
    amount
FROM book;
```

Результат:

```
+-----------------------+--------+ 
|title                  | amount |
+-----------------------+--------+ 
| Мастер и Маргарита    | 3      | 
| Белая гвардия         | 5      | 
| Идиот                 | 10     | 
| Братья Карамазовы     | 2      | 
| Стихотворения и поэмы | 15     |
+-----------------------+--------+
```

Пояснение. Чтобы посмотреть, как работает запрос примера, скопируйте его код в окно для ввода и нажмите на черную кнопку Запустить код. После запуска выведется результат запроса, который можно сравнить с приведенным образцом. 

**Задание**

Выбрать авторов, название книг и их цену из таблицы `book`.

Результат:

```
+------------------+-----------------------+--------+
| author           | title                 | price  |
+------------------+-----------------------+--------+
| Булгаков М.А.    | Мастер и Маргарита    | 670.99 |
| Булгаков М.А.    | Белая гвардия         | 540.50 |
| Достоевский Ф.М. | Идиот                 | 460.00 |
| Достоевский Ф.М. | Братья Карамазовы     | 799.01 |
| Есенин С.А.      | Стихотворения и поэмы | 650.00 |
+------------------+-----------------------+--------+
Affected rows: 5
```

```sql
SELECT author,
    title,
    price
FROM book;
```

[Содержание](#содержание)

<hr>

## Присвоение новых имен столбцам при формировании выборки; 

Для того чтобы отобрать данные из определенных столбцов таблицы и одновременно задать столбцам новые названия в результате выборки используется SQL запрос следующей структуры: 
+ ключевое слово `SELECT`; 
+ имя столбца;
+ ключевое слово `AS`;
+ новое название столбца (можно русскими буквами), выводимое в результате запроса, но это должно быть одно слово, если название состоит из двух слов – соединяйте их подчеркиванием, например, `Количество_книг`;
+ запятая;
+ имя столбца;
+ ...
+ ключевое слово `FROM`; 
+ имя таблицы.

В одном запросе можно использовать и имена столбцов из таблицы, и новые названия.

Результатом является таблица, в которую включены все данные из указанных после `SELECT` столбцов исходной таблицы. Каждому столбцу в результате запроса присваивается новое имя, заданное после `AS`, или столбец получает имя столбца исходной таблицы, если `AS` отсутствует.

Пример

Выбрать все названия книг и их количества из таблицы `book` , для столбца `title` задать новое имя Название.

Запрос:

```sql
SELECT title AS Название, amount 
FROM book;
```

Результат:

```
+-----------------------+--------+
| Название              | amount |
+-----------------------+--------+ 
| Мастер и Маргарита    | 3      |
| Белая гвардия         | 5      | 
| Идиот                 | 10     |
| Братья Карамазовы     | 2      |
| Стихотворения и поэмы | 15     |
+-----------------------+--------+
```

**Задание**

Выбрать названия книг и авторов из таблицы `book`, для поля `title` задать имя(псевдоним) Название, для поля `author` –  Автор. 

Результат:

```
+-----------------------+------------------+
| Название              | Автор            |
+-----------------------+------------------+
| Мастер и Маргарита    | Булгаков М.А.    |
| Белая гвардия         | Булгаков М.А.    |
| Идиот                 | Достоевский Ф.М. |
| Братья Карамазовы     | Достоевский Ф.М. |
| Стихотворения и поэмы | Есенин С.А.      |
+-----------------------+------------------+
Affected rows: 5
```

```sql
SELECT title AS Название,
      author AS Автор
  FROM book;
```

[Содержание](#содержание)

<hr>

## Создание вычисляемых столбцов; 

**Выборка данных с созданием вычисляемого столбца**

С помощью SQL запросов можно осуществлять вычисления по каждой строке таблицы с помощью вычисляемого столбца. Для него в списке полей после оператора `SELECT` указывается выражение и задается имя.

Выражение может включать имена столбцов, константы, знаки операций, встроенные функции.

Результатом является таблица, в которую включены все данные из указанных после `SELECT` столбцов, а также новый столбец, в каждой строке которого вычисляется заданное выражение.

**Пояснение от слушателя.** Можно осуществлять арифметические и логические вычисления над целым столбцом, результатом будет новый столбец.

**Пример**

Вывести всю информацию о книгах, а также для каждой позиции посчитать ее стоимость (произведение цены на количество). Вычисляемому столбцу дать имя `total` .

Запрос:

```sql
SELECT title,
    author,
    price,
    amount,
    price * amount AS total
FROM book;
```

Результат:

```
+-----------------------+------------------+--------+--------+---------+ 
| title                 | author           | price  | amount | total   | 
+-----------------------+------------------+--------+--------+---------+ 
| Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      | 2012.97 | 
| Белая гвардия         | Булгаков М.А.    | 540.50 | 5      | 2702.50 | 
| Идиот                 | Достоевский Ф.М. | 460.00 | 10     | 4600.00 | 
| Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      | 1598.02 | 
| Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     | 9750.00 |
+-----------------------+------------------+--------+--------+---------+ 
```

**Задание**

Для упаковки каждой книги требуется один лист бумаги, цена которого `1` рубль `65` копеек. Посчитать стоимость упаковки для каждой книги (сколько денег потребуется, чтобы упаковать все экземпляры книги). В запросе вывести название книги, ее количество и стоимость упаковки, последний столбец назвать `pack`. 

Результат:

+-----------------------+--------+-------+
| title                 | amount | pack  |
+-----------------------+--------+-------+
| Мастер и Маргарита    | 3      | 4.95  |
| Белая гвардия         | 5      | 8.25  |
| Идиот                 | 10     | 16.50 |
| Братья Карамазовы     | 2      | 3.30  |
| Стихотворения и поэмы | 15     | 24.75 |
+-----------------------+--------+-------+
Affected rows: 5

```sql
SELECT title,
    amount,
    1.65 * amount AS pack
FROM book;
```

[Содержание](#содержание)

<hr>

## Вычисляемые столбцы, математические функции; 

**Выборка данных, вычисляемые столбцы, математические функции**

В SQL реализовано множество  [математических функций](https://docs.microsoft.com/ru-ru/sql/t-sql/functions/mathematical-functions-transact-sql?view=sql-server-ver15) для работы с числовыми данными. В таблице приведены некоторые из них.

Функция | Описание | Пример
-|-|-
`CEILING(x)` | возвращает наименьшее целое число, большее или равное x <br>(округляет до целого числа в большую сторону) | CEILING(4.2) = 5<br>CEILING(-5.8) = -5
`ROUND(x, k)` | округляет значение x до k знаков после запятой, <br>если k не указано – x округляется до целого | ROUND(4.361)=4<br>ROUND(5.86592,1)=5.9
`FLOOR(x)` | возвращает наибольшее целое число, меньшее или равное x <br>(округляет до  целого числа в меньшую сторону) | FLOOR(4.2)=4 <br>FLOOR(-5.8)=-6
`POWER(x, y)` | возведение x в степень y | POWER(3,4)=81.0
`SQRT(x)` | квадратный корень из x | SQRT(4)=2.0<br>SQRT(2)=1.41...
`DEGREES(x)` | конвертирует значение x из радиан в градусы | DEGREES(3) = 171.8...
`RADIANS(x)` | конвертирует значение x из градусов в радианы | RADIANS(180)=3.14...
`ABS(x)` | модуль числа x | ABS(-1) = 1<br>ABS(1) = 1
`PI()` | pi = 3.1415926... |  

**Пояснение.**   Существуют разные способы округления чисел. В SQL реализовано **математическое округление**. Для округления вещественного числа нужно в записи числа выбрать разряд в дробной части, до которого производится округление. Цифра, записанная в выбранном разряде: не меняется, если следующая за ней справа цифра - 0, 1, 2, 3 или 4; увеличивается на единицу, если следующая за ней справа цифра - 5,6,7,8 или 9.

**Пример** 

Для каждой книги из таблицы `book` вычислим налог на добавленную стоимость (имя столбца `tax`) , который включен в цену и составляет k = 18%,  а также цену книги (`price_tax`) без него. Формулы для вычисления:

$tax= \dfrac{price \cdot \dfrac{k}{100}}{1 + \dfrac{k}{100}} $,<br>
$pricetax= \dfrac{price}{1 + \dfrac{k}{100}} $

Значение НДС в 18% взято для ПРИМЕРА, чтобы показать как использовать функции округления.

**Запрос:**

```sql
SELECT title,
    price,
    (price * 18 / 100) /(1 + 18 / 100) AS tax,
    price /(1 + 18 / 100) AS price_tax
FROM book;
```
Результат:

```
+-----------------------+--------+----------------+------------+
| title                 | price  | tax            | price_tax  |
+-----------------------+--------+----------------+------------+
| Мастер и Маргарита    | 670.99 | 102.3544067797 | 568.635593 |
| Белая гвардия         | 540.50 | 82.4491525424  | 458.050847 |
| Идиот                 | 460.00 | 70.1694915254  | 389.830508 |
| Братья Карамазовы     | 799.01 | 121.8828813559 | 677.127119 |
| Стихотворения и поэмы | 650.00 | 99.1525423729  | 550.847458 |
+-----------------------+--------+----------------+------------+
```

Сумма налога и цена книги без налога – это деньги, поэтому количество знаков после запятой у этих чисел должно быть 2. Следовательно необходимо округлить полученные значения.

Запрос:

```sql
SELECT title,
    price,
    ROUND((price * 18 / 100) /(1 + 18 / 100), 2) AS tax,
    ROUND(price /(1 + 18 / 100), 2) AS price_tax
FROM book;
```
Результат:

```
+-----------------------+--------+--------+-----------+
| title                 | price  | tax    | price_tax |
+-----------------------+--------+--------+-----------+
| Мастер и Маргарита    | 670.99 | 102.35 | 568.64    |
| Белая гвардия         | 540.50 | 82.45  | 458.05    |
| Идиот                 | 460.00 | 70.17  | 389.83    |
| Братья Карамазовы     | 799.01 | 121.88 | 677.13    |
| Стихотворения и поэмы | 650.00 | 99.15  | 550.85    |
+-----------------------+--------+--------+-----------+
```

**Задание**

В конце года цену каждой книги на складе пересчитывают – снижают ее на 30%. Написать SQL запрос, который из таблицы book выбирает названия, авторов, количества и вычисляет новые цены книг. Столбец с новой ценой назвать `new_price`, цену округлить до 2-х знаков после запятой.

Результат:

```
+-----------------------+------------------+--------+-----------+
| title                 | author           | amount | new_price |
+-----------------------+------------------+--------+-----------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      | 469.69    |
| Белая гвардия         | Булгаков М.А.    | 5      | 378.35    |
| Идиот                 | Достоевский Ф.М. | 10     | 322.00    |
| Братья Карамазовы     | Достоевский Ф.М. | 2      | 559.31    |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 455.00    |
+-----------------------+------------------+--------+-----------+
```

```sql
SELECT title,
    author,
    amount,
    ROUND(price * 0.7, 2) AS new_price
    FROM book;
```

[Содержание](#содержание)

<hr>

## Вычисляемые столбцы, логические функции; 

**Выборка данных, вычисляемые столбцы, логические функции**

В SQL реализована возможность заносить в поле значение в зависимости от условия. Для этого используется функция `IF()`:

```sql
IF(логическое_выражение, выражение_1, выражение_2)
```

Функция вычисляет `логическое_выражение`, если оно истина – в поле заносится значение `выражения_1`, в противном случае –  значение `выражения_2`. Все три параметра `IF()` являются обязательными.

Допускается использование вложенных функций, вместо `выражения_1` или `выражения_2` может стоять новая функция `IF`.

**Пример**

Для каждой книги из таблицы `book` установим скидку следующим образом: если количество книг меньше `4`, то скидка будет составлять `50%` от цены, в противном случае `30%`.

Запрос:

```sql
SELECT title,
    amount,
    price,
    IF(amount < 4, price * 0.5, price * 0.7) AS sale
FROM book;
```

Результат:

```
+-----------------------+--------+--------+---------+
| title                 | amount | price  | sale    |
+-----------------------+--------+--------+---------+
| Мастер и Маргарита    | 3      | 670.99 | 335.495 |
| Белая гвардия         | 5      | 540.50 | 378.350 |
| Идиот                 | 10     | 460.00 | 322.000 |
| Братья Карамазовы     | 2      | 799.01 | 399.505 |
| Стихотворения и поэмы | 15     | 650.00 | 455.000 |
+-----------------------+--------+--------+---------+
```

Цена по скидке должна отображаться с двумя знаками после запятой, добавим в запрос округление:

```sql
SELECT title,
    amount,
    price,
    ROUND(IF(amount < 4, price * 0.5, price * 0.7), 2) AS sale
FROM book;
```

Результат:

```
+-----------------------+--------+--------+--------+
| title                 | amount | price  | sale   |
+-----------------------+--------+--------+--------+
| Мастер и Маргарита    | 3      | 670.99 | 335.50 |
| Белая гвардия         | 5      | 540.50 | 378.35 |
| Идиот                 | 10     | 460.00 | 322.00 |
| Братья Карамазовы     | 2      | 799.01 | 399.51 |
| Стихотворения и поэмы | 15     | 650.00 | 455.00 |
+-----------------------+--------+--------+--------+
```

**Пример**

Усложним вычисление скидки в зависимости от количества книг. Если количество книг меньше `4` – то скидка `50%`, меньше `11` – `30%`, в остальных случаях – `10%`. И еще укажем какая именно скидка на каждую книгу.

Запрос:

```sql
SELECT title,
    amount,
    price,
    ROUND(
        IF(
            amount < 4,
            price * 0.5,
            IF(amount < 11, price * 0.7, price * 0.9)
        ),
        2
    ) AS sale,
    IF(
        amount < 4,
        'скидка 50%',
        IF(amount < 11, 'скидка 30%', 'скидка 10%')
    ) AS Ваша_скидка
FROM book;
```
Результат:

```
+-----------------------+--------+--------+--------+-------------+
| title                 | amount | price  | sale   | Ваша_скидка |
+-----------------------+--------+--------+--------+-------------+
| Мастер и Маргарита    | 3      | 670.99 | 335.50 | скидка 50%  |
| Белая гвардия         | 5      | 540.50 | 378.35 | скидка 30%  |
| Идиот                 | 10     | 460.00 | 322.00 | скидка 30%  |
| Братья Карамазовы     | 2      | 799.01 | 399.51 | скидка 50%  |
| Стихотворения и поэмы | 15     | 650.00 | 585.00 | скидка 10%  |
+-----------------------+--------+--------+--------+-------------+
```

**Задание**

При анализе продаж книг выяснилось, что наибольшей популярностью пользуются книги Михаила Булгакова, на втором месте книги Сергея Есенина. Исходя из этого решили поднять цену книг Булгакова на `10%`, а цену книг Есенина - на `5%`. Написать запрос, куда включить автора, название книги и новую цену, последний столбец назвать `new_price`. Значение округлить до двух знаков после запятой.

**Пояснение**
+ фамилию автора задавать с инициалами (как занесено в таблице), заключая в одинарные или двойные кавычки;
+ для сравнения на равенство использовать знак =, например author = "Булгаков М.А.".

```sql
SELECT author,
    title,
    ROUND(
        IF(
            author = 'Булгаков М.А.',
            price * 1.1,
            IF(
                author = 'Есенин С.А.',
                price * 1.05,
                price
            )
        ),
        2
    ) AS new_price,
    FROM book;
```

[Содержание](#содержание)

<hr>

## Выборка данных по простому условию; 

С помощью запросов можно включать в итоговую выборку не все строки исходной таблицы, а только те, которые отвечают некоторому условию. Для этого после указания таблицы, откуда выбираются данные, задается ключевое слово `WHERE` и логическое выражение, от результата которого зависит будет ли включена строка в выборку или нет. Если условие – истина, то строка(запись)  включается в выборку, если ложь – нет.

Логическое выражение может включать операторы сравнения (равно `=`, не равно `<>`, больше `>`, меньше `<`, больше или равно `>=`, меньше или равно `<=`) и выражения, допустимые в SQL.

**Пример**

Вывести название и цену тех книг, цены которых меньше 600 рублей.

Запрос:

```sql
SELECT title,
    price
FROM book
WHERE price < 600;
```

Результат:

```
+---------------+--------+
| title         | price  |
+---------------+--------+
| Белая гвардия | 540.50 |
| Идиот         | 460.00 |
+---------------+--------+
```
**Пример**

Вывести название, автора  и стоимость (цена умножить на количество) тех книг, стоимость которых больше `4000` рублей

Запрос:

```sql
SELECT title,
    author,
    price * amount AS total
FROM book
WHERE price * amount > 4000;
```
Результат:

```
+-----------------------+------------------+---------+
| title                 | author           | total   |
+-----------------------+------------------+---------+
| Идиот                 | Достоевский Ф.М. | 4600.00 |
| Стихотворения и поэмы | Есенин С.А.      | 9750.00 |
+-----------------------+------------------+---------+
```

**Пояснение**

В логическом выражении после `WHERE` нельзя использовать названия столбцов, присвоенные им с помощью `AS`,  так как при выполнении запроса сначала вычисляется логическое выражение для каждой строки исходной таблицы, выбираются строки, для которых оно истинно. А только после этого формируется "шапка запроса" – столбцы, включаемые в запрос.

**Задание**

Вывести автора, название  и цены тех книг, количество которых меньше `10`.

Результат:

```
+------------------+--------------------+--------+
| author           | title              | price  |
+------------------+--------------------+--------+
| Булгаков М.А.    | Мастер и Маргарита | 670.99 |
| Булгаков М.А.    | Белая гвардия      | 540.50 |
| Достоевский Ф.М. | Братья Карамазовы  | 799.01 |
+------------------+--------------------+--------+
```

```sql
SELECT author,
    title,
    price
FROM book
WHERE amount < 10;
```

[Содержание](#содержание)

<hr>

## Выборка данных с использованием логических выражений и операций; 

**Выборка данных, логические операции**

Логическое выражение после ключевого слова `WHERE` кроме операторов сравнения  и выражений может включать  логические операции (И `and`, ИЛИ `or`, НЕ `not`) и круглые скобки, изменяющие приоритеты выполнения операций.

Приоритеты операций:

1. круглые скобки
2. умножение  (*),  деление (/)
3. сложение  (+), вычитание (-)
4. операторы сравнения (=, >, <, >=, <=, <>)
5. NOT
6. AND
7. OR

**Пример**

Вывести название, автора и цену тех книг, которые написал Булгаков, ценой больше 600 рублей

Запрос:

```sql
SELECT title, author, price 
FROM book
WHERE price > 600 AND author = 'Булгаков М.А.';
```

Результат:

```
+--------------------+---------------+--------+
| title              | author        | price  |
+--------------------+---------------+--------+
| Мастер и Маргарита | Булгаков М.А. | 670.99 |
+--------------------+---------------+--------+
```
**Пример**

Вывести название, цену  тех книг, которые написал Булгаков или Есенин, ценой больше 600 рублей

Запрос:

```sql
SELECT title, author, price 
FROM book
WHERE (author = 'Булгаков М.А.' OR author = 'Есенин С.А.') AND price > 600;
```

Результат:

```
+-----------------------+---------------+--------+
| title                 | author        | price  |
+-----------------------+---------------+--------+
| Мастер и Маргарита    | Булгаков М.А. | 670.99 |
| Стихотворения и поэмы | Есенин С.А.   | 650.00 |
+-----------------------+---------------+--------+
```

В данном запросе обязательно нужно поставить скобки, так как без них сначала вычисляется  `author = 'Есенин С.А.'` `and` `price > 600`, а потом уже выражение через `or`. Без скобок были бы отобраны все книги Булгакова и те книги Есенина, цена которых больше `600`.

Запрос:

```sql
SELECT title, author, price 
FROM book
WHERE author = 'Булгаков М.А.' OR author = 'Есенин С.А.' AND price > 600;
```

Результат (сравните с предыдущим):

```
+-----------------------+---------------+--------+
| title                 | author        | price  |
+-----------------------+---------------+--------+
| Мастер и Маргарита    | Булгаков М.А. | 670.99 |
| Белая гвардия         | Булгаков М.А. | 540.50 |
| Стихотворения и поэмы | Есенин С.А.   | 650.00 |
+-----------------------+---------------+--------+
```

**Задание**

Вывести название, автора,  цену  и количество всех книг, цена которых меньше 500 или больше 600, а стоимость всех экземпляров этих книг больше или равна 5000.

Результат:

```
+-----------------------+-------------+--------+--------+
| title                 | author      | price  | amount |
+-----------------------+-------------+--------+--------+
| Стихотворения и поэмы | Есенин С.А. | 650.00 | 15     |
+-----------------------+-------------+--------+--------+
```
```sql
SELECT
    title,
    author,
    price,
    amount
FROM
    book
WHERE
    (
        price < 500
        OR price > 600
    )
    AND price * amount >= 5000;
```

[Содержание](#содержание)

<hr>

## Выборка данных, операторы BETWEEN, IN; 

**Выборка данных, операторы `BETWEEN`, `IN`**

Логическое выражение после ключевого слова `WHERE` может включать операторы  `BETWEEN` и `IN`. Приоритет  у этих операторов такой же как у операторов сравнения, то есть они выполняются раньше, чем `NOT`, `AND`, `OR`.

Оператор `BETWEEN` позволяет отобрать данные, относящиеся к некоторому интервалу, включая его границы.

**Пример**

Выбрать названия и количества тех книг, количество которых от 5 до 14 включительно.

Запрос:

```sql
SELECT title, amount 
FROM book
WHERE amount BETWEEN 5 AND 14;
```

Результат:

```
+---------------+--------+
| title         | amount |
+---------------+--------+
| Белая гвардия | 5      |
| Идиот         | 10     |
+---------------+--------+
```

Этот запрос можно реализовать по-другому, результат будет точно такой же.

```sql
SELECT title, amount 
FROM book
WHERE amount >= 5 AND amount <=14;
```

Оператор  `IN`  позволяет выбрать данные, соответствующие значениям из списка.

**Пример**

Выбрать названия и цены книг, написанных Булгаковым или Достоевским.

Запрос:

```sql
SELECT title, price 
FROM book
WHERE author IN ('Булгаков М.А.', 'Достоевский Ф.М.');
```

Результат:

```
+--------------------+--------+
| title              | price  |
+--------------------+--------+
| Мастер и Маргарита | 670.99 |
| Белая гвардия      | 540.50 |
| Идиот              | 460.00 |
| Братья Карамазовы  | 799.01 |
+--------------------+--------+
```

Этот запрос можно реализовать по-другому, результат будет точно такой же.

```sql
SELECT title, price 
FROM book
WHERE author = 'Булгаков М.А.' OR author = 'Достоевский Ф.М.';
```

**Задание**

Вывести название и авторов тех книг, цены которых принадлежат интервалу от 540.50 до 800 (включая границы),  а количество или 2, или 3, или 5, или 7 .

Результат:

```
+--------------------+------------------+
| title              | author           |
+--------------------+------------------+
| Мастер и Маргарита | Булгаков М.А.    |
| Белая гвардия      | Булгаков М.А.    |
| Братья Карамазовы  | Достоевский Ф.М. |
+--------------------+------------------+
```

```sql
SELECT
    title,
    author
FROM
    book
WHERE
    price BETWEEN 540.5
    AND 800
    AND amount IN (2, 3, 5, 7);
```
[Содержание](#содержание)

<hr>

## Выборка данных с сортировкой;

При выборке можно указывать столбец или несколько столбцов, по которым необходимо отсортировать отобранные строки. Для этого используются ключевые слова `ORDER BY`, после которых задаются имена столбцов. При этом строки сортируются по первому столбцу. Если указан второй столбец, сортировка осуществляется только для тех строк, у которых значения первого столбца одинаковы. По умолчанию `ORDER BY` выполняет сортировку по возрастанию. Чтобы управлять направлением сортировки вручную, после имени столбца указывается ключевое слово `ASC` (по возрастанию) или `DESC` (по убыванию). 

Столбцы после ключевого слова `ORDER BY` можно задавать:

+ названием столбца;
+ номером столбца;
+ именем столбца (указанным после AS).

**Пример**

Вывести название, автора и цены книг. Информацию  отсортировать по названиям книг в алфавитном порядке.

Запрос:

```sql
SELECT title, author, price
FROM book
ORDER BY title;
```

Результат:

```
+-----------------------+------------------+--------+
| title                 | author           | price  |
+-----------------------+------------------+--------+
| Белая гвардия         | Булгаков М.А.    | 540.50 |
| Братья Карамазовы     | Достоевский Ф.М. | 799.01 |
| Идиот                 | Достоевский Ф.М. | 460.00 |
| Мастер и Маргарита    | Булгаков М.А.    | 670.99 |
| Стихотворения и поэмы | Есенин С.А.      | 650.00 |
+-----------------------+------------------+--------+
```

Аналогичный результат получится при использовании запроса:

```sql
SELECT title, author, price
FROM book
ORDER BY 1;
```

**Пример**

Вывести автора, название и количество книг, в отсортированном в алфавитном порядке по автору и по убыванию количества, для тех книг, цены которых меньше 750 рублей.

Запрос:

```sql
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, amount DESC;
```

Результат:

```
+------------------+-----------------------+------------+
| author           | title                 | Количество |
+------------------+-----------------------+------------+
| Булгаков М.А.    | Белая гвардия         | 5          |
| Булгаков М.А.    | Мастер и Маргарита    | 3          |
| Достоевский Ф.М. | Идиот                 | 10         |
| Есенин С.А.      | Стихотворения и поэмы | 15         |
+------------------+-----------------------+------------+
```

Можно использовать другие варианты записи запроса:

```sql
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, Количество DESC;
```
```sql
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY 1, 3 DESC;
```

**Важно!** Если названия столбцов заключены в кавычки, то при использовании их в сортировке, необходимо записывать их БЕЗ КАВЫЧЕК.

**Задание**

Вывести  автора и название  книг, количество которых принадлежит интервалу от 2 до 14 (включая границы). Информацию  отсортировать сначала по авторам (в обратном алфавитном порядке), а затем по названиям книг (по алфавиту).

Результат:

```
+------------------+--------------------+
| author           | title              |
+------------------+--------------------+
| Достоевский Ф.М. | Братья Карамазовы  |
| Достоевский Ф.М. | Идиот              |
| Булгаков М.А.    | Белая гвардия      |
| Булгаков М.А.    | Мастер и Маргарита |
+------------------+--------------------+
```

```sql
SELECT
    author,
    title
FROM
    book
WHERE
    amount BETWEEN 2
    AND 14
ORDER BY
    author DESC,
    title ASC;
```

[Содержание](#содержание)

<hr>

## Выборка текстовых данных по шаблону, оператор LIKE. 

**Выборка данных, оператор LIKE**

Оператор `LIKE` используется для сравнения строк. В отличие от операторов отношения равно (`=`) и не равно (`<>`), `LIKE` позволяет сравнивать строки не на полное совпадение (не совпадение), а в соответствии с шаблоном. Шаблон может включать **обычные символы** и **символы-шаблоны**. При сравнении с шаблоном, его обычные символы должны в точности совпадать с символами, указанными в строке. Символы-шаблоны могут совпадать с произвольными элементами символьной строки.


Символ-шаблон | Описание | Пример
-|-|-
`%` | Любая строка, содержащая ноль или более символов | `SELECT` * `FROM` book `WHERE` author `LIKE` '%М.%'<br>выполняет поиск и выдает все книги, инициалы авторов которых содержат «М.»
_ (подчеркивание) | Любой одиночный символ | `SELECT` * `FROM` book `WHERE` title `LIKE` 'Поэм_'<br>выполняет поиск и выдает все книги, названия которых либо «Поэма», либо «Поэмы» и пр.

**Пример 1**

Вывести названия книг, начинающихся с буквы «Б».

Запрос:

```sql
SELECT title 
FROM book
WHERE title LIKE 'Б%';
/* эквивалентное условие 
title LIKE 'б%'
*/
```

Результат:

```
+-------------------+
| title             |
+-------------------+
| Белая гвардия     |
| Братья Карамазовы |
+-------------------+
```
Строчные и прописные буквы в строках эквивалентны.

**Пример 2**

Вывести название книг, состоящих ровно из 5 букв.

Запрос:

```sql
SELECT title FROM book 
WHERE title LIKE "_____"
```
Результат:

```
+-------+
| title |
+-------+
| Идиот |
| Поэмы |
+-------+
```

Для обозначения одного любого символа используется  "_", следовательно для обозначения 5 символов используется 5 подряд символов подчеркивания.

**Пример 3**

Вывести книги, название которых длиннее 5 символов:

Запрос:

```sql
SELECT title FROM book 
WHERE title LIKE "______%";
/* эквивалентные условия 
title LIKE "%______"
title LIKE "%______%"
*/
```

Результат:

```
+-----------------------+
| title                 |
+-----------------------+
| Мастер и Маргарита    |
| Белая гвардия         |
| Братья Карамазовы     |
| Стихотворения и поэмы |
| Дети полуночи         |
| Лирика                |
| Капитанская дочка     |
+-----------------------+
```

**Пояснение**<br>
Для того чтобы вывести названия, состоящие из любого количества символов после `LIKE` можно использовать шаблон "`%`", с помощью которого отбираются строки, состоящие из любого количества символов, в том числе и "пустые", поскольку `%` заменяет любое количество символов, в том числе и нулевое.

Чтобы указать, что в названии должен быть хотя бы один символ, можно использовать один из эквивалентных шаблонов:

+ `_%` - сначала идет символ, а за ним любое количество символов;
+ `%_` - сначала идет любое количество символов, а затем обязательный символ;
+ `%_%` - сначала идет любое количество символов, потом обязательный символ, а за ним любое количество символов.

**Пример 4**

Вывести названия книг, которые содержат букву "и" как отдельное слово, если считать, что слова в названии отделяются друг от друга пробелами и не содержат знаков препинания.

Запрос:

```sql
SELECT title FROM book 
WHERE   title LIKE "_% и _%" /*отбирает слово И внутри названия */
    OR title LIKE "и _%" /*отбирает слово И в начале названия */
    OR title LIKE "_% и" /*отбирает слово И в конце названия */
    OR title LIKE "и" /* отбирает название, состоящее из одного слова И */
```

Слово "и" может располагаться в названии в следующих позициях (при условии, что слова отделяются друг от друга пробелами):
+ в середине -  `_% и _%` - сначала идет любое количество символов (один обязательный), потом обязательный пробел, а за ним "и", снова обязательный пробел, и наконец любое количество символов (один обязательный);
+ в начале - `и _%` - сначала идет "и", обязательный пробел и любое количество символов (один обязательный);
+ в конце - `_% и` - сначала идет любое количество символов, затем обязательный пробел и буква "и":
+ одно слово в названии - "и".

Вместо `_%` можно использовать эквивалентные шаблоны `%_` и `%_%` .

В качестве обязательного символа (`_`), может быть и пробел, но, к сожалению, шаблоны для `LIKE` не позволяют исключить какой-то символ. Это можно сделать только с помощью регулярных выражений (будут рассмотрены в уроке 3.5)

Результат:

```
+-----------------------+
| title                 |
+-----------------------+
| Мастер и Маргарита    |
| Стихотворения и поэмы |
+-----------------------+
```

**Пример 5**

Вывести названия книг, которые состоят ровно из одного слова, если считать, что слова в названии отделяются друг от друга пробелами .

Запрос:

```sql
SELECT title FROM book 
WHERE title NOT LIKE "% %";    
```

Результат:

```
+--------+
| title  |
+--------+
| Идиот  |
| Лирика |
| Поэмы  |
+--------+
```

Пояснение

Отсутствие пробела в названии означает, что оно состоит из одного слова. Чтобы это проверить используется оператор `NOT LIKE`, который в данном случае отберет все названия, в которых нет пробелов.

**Задание**

Вывести название и автора тех книг, название которых состоит из двух и более слов, а инициалы автора содержат букву «С». Считать, что в названии слова отделяются друг от друга пробелами и не содержат знаков препинания, между фамилией автора и инициалами обязателен пробел, инициалы записываются без пробела в формате: буква, точка, буква, точка. Информацию отсортировать по названию книги в алфавитном порядке.

Результат:

```
+-----------------------+-------------+
| title                 | author      |
+-----------------------+-------------+
| Капитанская дочка     | Пушкин А.С. |
| Стихотворения и поэмы | Есенин С.А. |
+-----------------------+-------------+
```

Пояснение.
1. При записи условия, необходимо учесть, что слово в названии обязательно должно содержать  хотя бы один символ.
2. Инициалы в этом задании - это первая буква имени или отчества, после которой стоит точка.
3. Буква C должна быть написана в РУССКОЙ раскладке. Если не проходит решение - проверьте это.

**Важно!** Только для этого шага в таблицу добавлены новые записи.

```sql
SELECT
    title,
    author
FROM
    book
WHERE
    title LIKE "%_ _%"
    AND author LIKE "%С.%"
ORDER BY
    title;
```

## TODO

**Задание**

Придумайте один или несколько запросов к нашей таблице book. Проверьте, правильно ли они работают.

При желании можно формулировку запросов  разместить в комментариях.

Размещенные задания можно использовать для закрепления материала урока.

Оценивайте понравившиеся Вам запросы.

В последнем модуле создан отдельный урок, в котором мы разместим запросы, набравшие наибольшее количество лайков. 

Структура и наполнение таблицы `book`:

book_id | title | author | price | amount
-|-|-|-|-
INT PRIMARY KEY AUTO_INCREMENT | VARCHAR(50) | VARCHAR(30) | DECIMAL(8,2) | INT
1 | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3
2 | Белая гвардия | Булгаков М.А. | 540.50 | 5
3 | Идиот | Достоевский Ф.М. | 460.00 | 10
4 | Братья Карамазовы | Достоевский Ф.М. | 799.01 | 2
5 | Стихотворения и поэмы | Есенин С.А. | 650.00 | 15

[Содержание](#содержание)

<hr>

# 1.3 Запросы, групповые операции

**Структура и наполнение таблицы**

Все запросы будут формулироваться для таблицы book(создание, заполнение):

book_id | title | author | price | amount
-|-|-|-|-
INT PRIMARY KEY AUTO_INCREMENT | VARCHAR(50) | VARCHAR(30) | DECIMAL(8,2) | INT
1 | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3
2 | Белая гвардия | Булгаков М.А. | 540.50 | 5
3 | Идиот | Достоевский Ф.М. | 460.00 | 10
4 | Братья Карамазовы | Достоевский Ф.М. | 799.01 | 3
5 | Игрок | Достоевский Ф.М. | 480.50 | 10
6 | Стихотворения и поэмы | Есенин С.А. | 650.00 | 15

## Выборка уникальных элементов столбца;

Чтобы отобрать уникальные элементы некоторого столбца используется ключевое слово `DISTINCT`, которое размещается сразу после `SELECT`.

Пример

Выбрать различных авторов, книги которых хранятся в таблице book.

Запрос:

```sql
SELECT DISTINCT author
FROM book;
```

Результат:

```
+------------------+
| author           |
+------------------+
| Булгаков М.А.    |
| Достоевский Ф.М. |
| Есенин С.А.      |
+------------------+
```

Другой способ – использование оператора `GROUP BY`, который группирует данные при выборке, имеющие одинаковые значения в некотором столбце. Столбец, по которому осуществляется группировка, указывается после `GROUP BY` .

С помощью `GROUP BY` можно выбрать уникальные элементы столбца, по которому осуществляется группировка. Результат будет точно такой же как при использовании `DISTINCT`.

Запрос:

```sql
SELECT  author
FROM book
GROUP BY author;
```

**Задание**

Отобрать различные (уникальные) элементы столбца amount таблицы book.

```sql
SELECT
    amount
FROM
    book
GROUP BY
    amount
```

[Содержание](#содержание)

<hr>

## Выборка данных (групповые функции sum и count);

**Выборка данных, групповые функции SUM и COUNT**

При группировке над элементами столбца, входящими в группу можно выполнить различные действия, например, просуммировать их или найти количество элементов в группе.

Подробно рассмотрим, как осуществляется группировка данных по некоторому столбцу и вычисления над группой на следующем примере:

```sql
SELECT author, sum(amount), count(amount)
FROM book
GROUP BY author;
```

1. В таблице `book` определяются строки, в которых в столбце `author` одинаковые значения:

![01](/SQL_Simulator/img/01_06.png)

Получили 3 различные группы:
+ **группа I** объединяет две записи, у которых в столбце `author` значение Булгаков М.А.;
+ **группа II** объединяет три записи, у которых в столбце `author` значение Достоевский Ф.М.;
+ **группа III** объединяет одну запись, у которой в столбце `author` значение Есенин С.А.
2. Вместо каждой группы в результирующий запрос включается  одна запись. Запись как минимум включает значение столбца, по которому осуществляется группировка (в нашем случае это `author`):

![01](/SQL_Simulator/img/01_07.png)

3. Дальше можно выполнить вычисления над элементами КАЖДОЙ группы в отдельности, например, посчитать общее количество экземпляров книг каждого автора. Для этого используется групповая функция `SUM()`, а в скобках указывается столбец, по которому нужно выполнить суммирование ( в нашем случае `amount`):

![01](/SQL_Simulator/img/01_08.png)

4. Также можно посчитать, сколько записей относится к группе. Для этого используется функция `COUNT()`, в скобках можно указать ЛЮБОЙ столбец из группы, если группа не содержит пустых значений (ниже приведен пример, в котором показано, как работает `COUNT()`, если в группе есть пустые значения):

![01](/SQL_Simulator/img/01_09.png)

**Пример**

Посчитать, сколько экземпляров книг каждого автора хранится на складе.

Запрос:

```sql
SELECT author, SUM(amount)
FROM book
GROUP BY author;
```

Результат:

```
+------------------+-------------+
| author           | SUM(amount) |
+------------------+-------------+
| Булгаков М.А.    | 8           |
| Достоевский Ф.М. | 23          |
| Есенин С.А.      | 15          |
+------------------+-------------+
```

Примечание

Обратите внимание, что в качестве названия вычисляемого столбца в результирующей таблице используется выражение. Рекомендуется всем  вычисляемым столбцам давать имя.

Пример

Посчитать, сколько различных книг каждого автора хранится на складе.

Только для этого примера в таблицу `book` добавлена запись с пустыми значениями в столбцах `amount` и `price`:

```
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 3      |
| 5       | Игрок                 | Достоевский Ф.М. | 480.50 | 10     |
| 6       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 7       | Черный человек        | Есенин С.А.      | Null   | Null   |
+---------+-----------------------+------------------+--------+--------+
```
Запрос:

```sql
/* чтобы проверить запрос, добавьте в таблицу строку */
INSERT INTO book (title, author, price, amount) VALUES ('Черный человек','Есенин С.А.', Null, Null);

SELECT author, COUNT(author), COUNT(amount), COUNT(*)
FROM book
GROUP BY author;
```
Результат:

```
+------------------+---------------+---------------+----------+
| author           | COUNT(author) | COUNT(amount) | COUNT(*) |
+------------------+---------------+---------------+----------+
| Булгаков М.А.    | 2             | 2             | 2        |
| Достоевский Ф.М. | 3             | 3             | 3        |
| Есенин С.А.      | 2             | 1             | 2        |
+------------------+---------------+---------------+----------+
```

Из таблицы с результатами запроса видно, что функцию `COUNT()` можно применять к любому столбцу, в том числе можно использовать и `*`, если таблица не содержит пустых значений. Если же в столбцах есть значения `Null`, (для группы по автору Есенин в нашем примере), то

`COUNT(*)` —  подсчитывает  все записи, относящиеся к группе, в том числе и со значением `NULL`;
`COUNT(имя_столбца)` — возвращает количество записей конкретного столбца (только `NOT NULL`), относящихся к группе.

**ВАЖНО.**

Если столбец указан в `SELECT`  БЕЗ применения групповой функции, то он обязательно должен быть указан и в `GROUP BY`. Иначе получим ошибку.
Между названием функции и скобкой **НЕЛЬЗЯ СТАВИТЬ ПРОБЕЛ**. Это особенность платформы.

**Задание**

Посчитать, количество различных книг и количество экземпляров книг каждого автора , хранящихся на складе.  Столбцы назвать Автор, Различных_книг и Количество_экземпляров соответственно.

```sql
SELECT
    author AS Автор,
    COUNT(title) AS Различных_книг,
    SUM(amount) AS Количество_экземпляров
FROM
    book
GROUP BY
    author;
```

**Результат**

```
+------------------+----------------+------------------------+
| Автор            | Различных_книг | Количество_экземпляров |
+------------------+----------------+------------------------+
| Булгаков М.А.    | 2              | 8                      |
| Достоевский Ф.М. | 3              | 23                     |
| Есенин С.А.      | 1              | 15                     |
+------------------+----------------+------------------------+
```

**Пояснение**

Название столбцов может состоять из нескольких слов, тогда их нужно заключать в кавычки. Но если слова написать через подчеркивание, тогда получится , что название состоит из одного слова, и кавычки можно не ставить. 

[Содержание](#содержание)

<hr>

## Выборка данных (групповые функции min, max и avg);

К групповым функциям SQL относятся: `MIN()`, `MAX()` и `AVG()`, которые вычисляют минимальное, максимальное и среднее значение элементов столбца, относящихся к группе.

**Пример**

Вывести минимальную цену книги каждого автора

Запрос:

```sql
SELECT author, MIN(price) AS min_price
FROM book
GROUP BY author;
```

Результат:

```
+------------------+-----------+
| author           | min_price |
+------------------+-----------+
| Булгаков М.А.    | 540.50    |
| Достоевский Ф.М. | 460.00    |
| Есенин С.А.      | 650.00    |
+------------------+-----------+
```

**Задание**

Вывести фамилию и инициалы автора, минимальную, максимальную и среднюю цену книг каждого автора . Вычисляемые столбцы назвать `Минимальная_цена`, `Максимальная_цена` и `Средняя_цена` соответственно.

```sql
SELECT
    author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена,
    AVG(price) AS Средняя_цена
FROM
    book
GROUP BY
    author;
```

**Результат**

```
+------------------+------------------+-------------------+--------------+
| author           | Минимальная_цена | Максимальная_цена | Средняя_цена |
+------------------+------------------+-------------------+--------------+
| Булгаков М.А.    | 540.50           | 670.99            | 605.745000   |
| Достоевский Ф.М. | 460.00           | 799.01            | 579.836667   |
| Есенин С.А.      | 650.00           | 650.00            | 650.000000   |
+------------------+------------------+-------------------+--------------+
```

[Содержание](#содержание)

<hr>

## Выборка данных с вычислением (групповые функции);

В качестве аргумента групповых функций  SQL может использоваться не только столбец, но и любое допустимое в SQL арифметическое выражение.

**Пример**

Вывести суммарную стоимость книг каждого автора.

Запрос:

```sql
SELECT author, SUM(price * amount) AS Стоимость
FROM book
GROUP BY author;
```

Результат:

```
+------------------+-----------+
| author           | Стоимость |
+------------------+-----------+
| Булгаков М.А.    | 4715.47   |
| Достоевский Ф.М. | 11802.03  |
| Есенин С.А.      | 9750.00   |
+------------------+-----------+
```

Групповые функции могут быть элементами выражений. Например, при вычислении средней стоимости книг каждого автора на предыдущем шаге получились значения с шестью знаками после запятой. А поскольку это деньги, значения нужно округлить до 2 знаков после запятой.

**Пример**

Найти среднюю цену книг каждого автора.

Запрос:

```sql
SELECT author, ROUND(AVG(price),2) AS Средняя_цена
FROM book
GROUP BY author;
```

Результат:

```
+------------------+--------------+
| author           | Средняя_цена |
+------------------+--------------+
| Булгаков М.А.    | 605.75       |
| Достоевский Ф.М. | 579.84       |
| Есенин С.А.      | 650.00       |
+------------------+--------------+
```

**Задание**

Для каждого автора вычислить суммарную стоимость книг `S` (имя столбца `Стоимость`), а также вычислить налог на добавленную стоимость  для полученных сумм (имя столбца `НДС` ) , который включен в стоимость и составляет 18% `(k=18)`,  а также стоимость книг  (`Стоимость_без_НДС`) без него. Значения округлить до двух знаков после запятой. В запросе для расчета НДС(`tax`)  и Стоимости без НДС(`S_without_tax`) использовать следующие формулы:

$tax = \dfrac{S \cdot \dfrac{k}{100}}{1 + \dfrac{k}{100}}$<br>
$S\space without \space tax = \dfrac{S}{1 + \dfrac{k}{100}}$

```sql
SELECT
    author,
    ROUND(SUM(price * amount), 2) AS Стоимость,
    ROUND(SUM(price * amount) * 18 / 118, 2) AS НДС,
    ROUND(SUM(price * amount) / 1.18, 2) AS Стоимость_без_НДС
FROM
    book
GROUP BY
    author;
```

**Результат**

```
+------------------+-----------+---------+-------------------+
| author           | Стоимость | НДС     | Стоимость_без_НДС |
+------------------+-----------+---------+-------------------+
| Булгаков М.А.    | 4715.47   | 719.31  | 3996.16           |
| Достоевский Ф.М. | 11802.03  | 1800.31 | 10001.72          |
| Есенин С.А.      | 9750.00   | 1487.29 | 8262.71           |
+------------------+-----------+---------+-------------------+
```

**Пояснение**

Имена столбцов, присвоенные им с помощью `AS`, нельзя использовать в выражениях, используйте названия столбцов исходной таблицы.

[Содержание](#содержание)

<hr>

## Вычисления по таблице целиком;

Групповые функции позволяют вычислять итоговые значения по всей таблице. Например, можно посчитать общее количество книг на складе, вычислить суммарную стоимость и пр. Для этого после ключевого слова `SELECT` указывается групповая функция для выражения или имени столбца, а ключевые слова GROUP BY опускаются.

**Пример**

Посчитать количество экземпляров книг на складе.

Запрос:

```sql
SELECT SUM(amount) AS Количество
FROM book;
```

**Результат:**

```
+------------+
| Количество |
+------------+
| 46         |
+------------+ 
```

Результатом таких запросов является единственная строка с вычисленными по таблице значениями.

**Пример**

Посчитать общее количество экземпляров книг на складе и их стоимость .

Запрос:

```sql
SELECT SUM(amount) AS Количество, 
    SUM(price * amount) AS Стоимость
FROM book;
```

Результат:

```
+------------+-----------+
| Количество | Стоимость |
+------------+-----------+
| 46         | 26267.50  |
+------------+-----------+
```

**Задание**

Вывести цену самой дешевой книги, цену самой дорогой и среднюю цену всех книг на складе. Названия столбцов Минимальная_цена, Максимальная_цена, Средняя_цена соответственно. Среднюю цену округлить до двух знаков после запятой. 

```sql
SELECT
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена,
    ROUND(AVG(price), 2) AS Средняя_цена 
FROM
    book;
```

**Результат**

```
+------------------+-------------------+--------------+
| Минимальная_цена | Максимальная_цена | Средняя_цена |
+------------------+-------------------+--------------+
| 460.00           | 799.01            | 600.17       |
+------------------+-------------------+--------------+
```

[Содержание](#содержание)

<hr>

## Выборка данных по условию (групповые функции)

В запросы с групповыми функциями можно включать условие отбора строк, которое в обычных запросах записывается после `WHERE`. В запросах с групповыми функциями вместо `WHERE` используется ключевое слово `HAVING` , которое размещается после оператора `GROUP BY`.

**Пример**

Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000.

Запрос:

```sql
SELECT author,
    MIN(price) AS Минимальная_цена, 
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000; 
```

Результат:

```
+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Достоевский Ф.М. | 460.00           | 799.01            |
| Есенин С.А.      | 650.00           | 650.00            |
+------------------+------------------+-------------------+
```

Также в запросах с группировкой можно сортировать данные.

**Пример**

Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000. Результат вывести по убыванию минимальной цены.

Запрос:

```sql
SELECT author,
    MIN(price) AS Минимальная_цена, 
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000 
ORDER BY Минимальная_цена DESC;
```

Результат:

```
+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Есенин С.А.      | 650.00           | 650.00            |
| Достоевский Ф.М. | 460.00           | 799.01            |
+------------------+------------------+-------------------+
```

**Пояснение**

При указании столбца, по которому выполняется сортировка, если столбцу присвоено имя  с помощью AS, можно использовать это имя.

**Задание**

Вычислить среднюю цену и суммарную стоимость тех книг, количество экземпляров которых принадлежит интервалу от 5 до 14, включительно. Столбцы назвать `Средняя_цена` и `Стоимость`, значения округлить до 2-х знаков после запятой.

```sql
SELECT
    ROUND(AVG(price), 2) AS Средняя_цена,
    ROUND(SUM(price * amount), 2) AS Стоимость
FROM
    book
WHERE
    amount BETWEEN 5
    AND 14;
```

```
+--------------+-----------+
| Средняя_цена | Стоимость |
+--------------+-----------+
| 493.67       | 12107.50  |
+--------------+-----------+
```

**Пояснение**

Если в запросе с групповыми функциями отсутствует `GROUP BY`, то для отбора записей используется ключевое слово `WHERE`.

[Содержание](#содержание)

<hr>

## Выборка данных по условию (групповые функции WHERE и HAVING).

`WHERE` и `HAVING` могут использоваться в одном запросе. При этом необходимо учитывать **порядок выполнения  SQL запроса на выборку на СЕРВЕРЕ**:

1. `FROM`
2. `WHERE`
3. `GROUP BY`
4. `HAVING`
5. `SELECT`
6. `ORDER BY`

+ Сначала определяется таблица, из которой выбираются данные (`FROM`),
+ затем из этой таблицы отбираются записи в соответствии с условием  `WHERE`, 
+ выбранные данные агрегируются (`GROUP BY`), 
+ из агрегированных записей выбираются те, которые удовлетворяют условию после `HAVING`.
+ Потом формируются данные результирующей выборки, как это указано после `SELECT` ( вычисляются выражения, присваиваются имена и пр. ).
+ Результирующая выборка сортируется, как указано после `ORDER BY`.

**Важно!** 

Порядок ВЫПОЛНЕНИЯ запросов - это не порядок ЗАПИСИ ключевых слов в запросе на выборку. Порядок записи (синтаксис запроса) остается таким же, как рассматривался ранее в курсе. Порядок ВЫПОЛНЕНИЯ  нужен для того, чтобы понять, почему, например, в `WHERE` нельзя использовать имена выражений из `SELECT`. Просто `SELECT` выполняется компилятором позже, чем `WHERE`, поэтому ему неизвестно, какое там выражение написано.

**Пример**

Вывести максимальную и минимальную цену книг каждого автора, кроме Есенина, количество экземпляров книг которого больше 10. 

```sql
SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
WHERE author <> 'Есенин С.А.'
GROUP BY author
HAVING SUM(amount) > 10;
```

Результат:

```
+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Достоевский Ф.М. | 460.00           | 799.01            |
+------------------+------------------+-------------------+
```

Другим способом решения примера является запрос:

```sql
SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(amount) > 10 AND author <> 'Есенин С.А.';
```

Не смотря на то что результат будет одинаковым, так делать не рекомендуется. «Потому что как написано - запрос сначала выбирает всех авторов, потом выводит данные, рассчитывая минимальное и максимальное значение цены для каждого, и только после всего убирает Есенина. Можно убрать Есенина в данном случае раньше и не использовать ресурсы базы для расчета его минимального и максимального значения, как это сделано в первом варианте. На небольшой базе быстродействия не ощутить, но если выполнять такое на продуктивной, то второй вариант значительно проигрывает...».

**Задание**

Посчитать стоимость всех экземпляров каждого автора без учета книг «Идиот» и «Белая гвардия». В результат включить только тех авторов, у которых суммарная стоимость книг (без учета книг «Идиот» и «Белая гвардия») более 5000 руб. 

Вычисляемый столбец назвать `Стоимость`. Результат отсортировать по убыванию стоимости.

```sql
SELECT
    author,
    ROUND(SUM(price * amount), 2) AS Стоимость
FROM
    book
WHERE
    title <> 'Идиот'
    AND title <> 'Белая гвардия'
GROUP BY
    author
HAVING
    SUM(price * amount) > 5000
ORDER BY
    Стоимость DESC;
```

```
+------------------+-----------+
| author           | Стоимость |
+------------------+-----------+
| Есенин С.А.      | 9750.00   |
| Достоевский Ф.М. | 7202.03   |
+------------------+-----------+
```

## TODO

**Задание**

Придумайте один или несколько запросов к нашей таблице book, используя групповые функции. Проверьте, правильно ли они работают.

При желании можно формулировку запросов  разместить в комментариях. 

Размещенные задания можно использовать для закрепления материала урока.

Оценивайте понравившиеся Вам запросы.

В последнем модуле создан отдельный урок, в котором мы разместим запросы, набравшие наибольшее количество лайков. 

Структура и наполнение таблицы `book`:


book_id | title | author | price | amount
-|-|-|-|-
INT PRIMARY KEY AUTO_INCREMENT | VARCHAR(50) | VARCHAR(30) | DECIMAL(8,2) | INT
1 | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3
2 | Белая гвардия | Булгаков М.А. | 540.50 | 5
3 | Идиот | Достоевский Ф.М. | 460.00 | 10
4 | Братья Карамазовы | Достоевский Ф.М. | 799.01 | 3
5 | Игрок | Достоевский Ф.М. | 480.50 | 10
6 | Стихотворения и поэмы | Есенин С.А. | 650.00 | 15

[Содержание](#содержание)

<hr>

# 1.4 Вложенные запросы

SQL позволяет создавать вложенные запросы. Вложенный запрос (подзапрос, внутренний запрос) – это запрос внутри другого запроса SQL.

Вложенный запрос используется для выборки данных, которые будут использоваться в условии отбора записей основного запроса. Его применяют для:
+ сравнения выражения с результатом вложенного запроса;
+ определения того, включено ли выражение в результаты вложенного запроса;
+ проверки того, выбирает ли запрос определенные строки.

Вложенный запрос имеет следующие компоненты:
+ ключевое слово `SELECT`  после которого указываются имена столбцов или выражения (чаще всего список содержит один элемент);
+ ключевое слово `FROM` и имя таблицы, из которой выбираются данные;
+ необязательное предложение `WHERE`;
+ необязательное предложение `GROUP BY`:
+ необязательное предложение `HAVING`.

Вложенные запросы  могут включаться в `WHERE` или `HAVING` так (в квадратных скобках указаны необязательные элементы, через `|` – один из элементов):

+ `WHERE` `|` `HAVING` выражение оператор_сравнения (вложенный запрос);
+ `WHERE` `|` `HAVING` выражение, включающее вложенный запрос;
+ `WHERE` `|` `HAVING` выражение `[NOT] IN` (вложенный запрос);
+ `WHERE` `|` `HAVING` выражение  оператор_сравнения  `ANY | ALL` (вложенный запрос).

Также вложенные запросы могут вставляться в основной запрос после ключевого слова `SELECT`.

**Структура и наполнение таблицы**

Все запросы в данном уроке будут формулироваться для таблицы book(создание, заполнение):

book_id | title | author | price | amount
-|-|-|-|-
INT PRIMARY KEY AUTO_INCREMENT | VARCHAR(50) | VARCHAR(30) | DECIMAL(8,2) | INT
1 | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3
2 | Белая гвардия | Булгаков М.А. | 540.50 | 5
3 | Идиот | Достоевский Ф.М. | 460.00 | 10
4 | Братья Карамазовы | Достоевский Ф.М. | 799.01 | 3
5 | Игрок | Достоевский Ф.М. | 480.50 | 10
6 | Стихотворения и поэмы | Есенин С.А. | 650.00 | 15

## Вложенный запрос, возвращающий одно значение

Вложенный запрос, возвращающий одно значение, может использоваться в условии отбора записей `WHERE` как обычное значение совместно с операциями `=`, `<>`, `>=`, `<=`, `>`, `<`.

**Пример**

Вывести информацию о самых дешевых книгах, хранящихся на складе.

Для реализации этого запроса нам необходимо получить минимальную цену из столбца `price` таблицы `book`, а затем вывести информацию о тех книгах, цена которых  равна минимальной. Первая часть  – поиск  минимума – реализуется вложенным запросом.

Запрос:

```sql
SELECT title, author, price, amount
FROM book
WHERE price = (
         SELECT MIN(price) 
         FROM book
      );
```

Результат:

```
+-------+------------------+--------+--------+
| title | author           | price  | amount |
+-------+------------------+--------+--------+
| Идиот | Достоевский Ф.М. | 460.00 | 10     |
+-------+------------------+--------+--------+
```

Вложенный запрос определяет минимальную цену книг во всей таблице (это 460.00), а затем в основном запросе для каждой записи проверяется, равна ли цена минимальному значению, если равна, информация о книге включается в результирующую таблицу запроса.

`Рекомендация.` При использовании вложенного запроса рекомендуется сначала проверить, правильно ли он работает (занести текст запроса в окно кода и нажать черную кнопку Запустить), если выдается верный результат – использовать код в качестве вложенного запроса.

**Задание**

Вывести информацию (автора, название и цену) о  книгах, цены которых меньше или равны средней цене книг на складе. Информацию вывести в отсортированном по убыванию цены виде. Среднее вычислить как среднее по цене книги.

```sql
SELECT
    author,
    title,
    price
FROM
    book
WHERE
    price <= (
        SELECT
            AVG(price)
        FROM
            book
    )
ORDER BY
    price DESC;
```

Результат
```
+------------------+---------------+--------+
| author           | title         | price  |
+------------------+---------------+--------+
| Булгаков М.А.    | Белая гвардия | 540.50 |
| Достоевский Ф.М. | Игрок         | 480.50 |
| Достоевский Ф.М. | Идиот         | 460.00 |
+------------------+---------------+--------+
```

[Содержание](#содержание)

<hr>

## Использование вложенного запроса в выражении

Вложенный запрос, возвращающий одно значение, может использоваться в выражениях как обычный операнд, например, к нему можно что-то прибавить, вычесть и пр.

**Пример**

Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3. То есть нужно вывести и те книги, количество экземпляров которых меньше среднего на 3, или больше среднего на 3.

Запрос:

```sql
SELECT title, author, amount 
FROM book
WHERE ABS(amount - (SELECT AVG(amount) FROM book)) > 3;
```

Результат:

```
+-----------------------+------------------+--------+
| title                 | author           | amount |
+-----------------------+------------------+--------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      |
| Братья Карамазовы     | Достоевский Ф.М. | 3      |
| Стихотворения и поэмы | Есенин С.А.      | 15     |
+-----------------------+------------------+--------+
```

**Задание**

Вывести информацию (автора, название и цену) о тех книгах, цены которых превышают минимальную цену книги на складе не более чем на 150 рублей в отсортированном по возрастанию цены виде.

```sql
SELECT
    author,
    title,
    price
FROM
    book
WHERE
    price <= (
        SELECT
            MIN(price)
        FROM
            book
    ) + 150
ORDER BY
    price;
```

Результат
```
+------------------+----------------+--------+
| author           | title          | price  |
+------------------+----------------+--------+
| Достоевский Ф.М. | Идиот          | 460.00 |
| Достоевский Ф.М. | Игрок          | 480.50 |
| Булгаков М.А.    | Белая гвардия  | 540.50 |
| Пушкин А.С.      | Евгений Онегин | 610.00 |
+------------------+----------------+--------+
```

[Содержание](#содержание)

<hr>

## Вложенный запрос, оператор IN

Вложенный запрос может возвращать несколько значений одного столбца.  Тогда его можно использовать в разделе `WHERE` совместно с оператором `IN`.

```sql
WHERE имя_столбца IN (вложенный запрос, возвращающий один столбец)
```

Оператор `IN` определяет, совпадает ли значение столбца с одним из значений, содержащихся во вложенном запросе. При этом логическое выражение после `WHERE` получает значение истина. Оператор `NOT IN` выполняет обратное действие – выражение истинно, если значение столбца не содержится во вложенном запросе.

Пример

Вывести информацию о книгах тех авторов, общее количество экземпляров книг которых не менее 12.

Запрос:

```sql
SELECT title, author, amount, price
FROM book
WHERE author IN (
        SELECT author 
        FROM book 
        GROUP BY author 
        HAVING SUM(amount) >= 12
      );
```

Результат:

```
+-----------------------+------------------+--------+--------+
| title                 | author           | amount | price  |
+-----------------------+------------------+--------+--------+
| Идиот                 | Достоевский Ф.М. | 10     | 460.00 |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 799.01 |
| Игрок                 | Достоевский Ф.М. | 10     | 480.50 |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 650.00 |
+-----------------------+------------------+--------+--------+
```

Вложенный запрос отбирает двух авторов (Достоевского и Есенина). А в основном запросе для каждой записи таблицы `book`  проверяется, входит ли автор книги в отобранный список, если входит - информация о книге включается в запрос.

**Задание**

Вывести информацию (автора, книгу и количество) о тех книгах, количество экземпляров которых в таблице `book` не дублируется.

**Пояснение к заданию**

В таблице `book` в столбце `amount` хранится количество экземпляров каждой книги:

```
+-----------------------+--------+
| title                 | amount |
+-----------------------+--------+
| Мастер и Маргарита    | 3      |
| Белая гвардия         | 5      |
| Идиот                 | 10     |
| Братья Карамазовы     | 3      |
| Игрок                 | 10     |
| Стихотворения и поэмы | 15     |
+-----------------------+--------+
```

В соответствии с этой таблицей:
+ количество экземпляров книг "Мастер и Маргарита" и "Братья Карамазовы" одинаково и равно 3 (так как число 3 встречается в таблице два раза, книги с таким количеством не подходят под условие);
+ количество экземпляров книг "Идиот" и "Игрок" тоже одинаково и равно 10 (не подходят под условие);
+ количество экземпляров книги "Белая гвардия равно" 5, при этом в таблице нет других книг, количество экземпляров которых равно 5, следовательно, эта книга подходит под условие задачи (так как количество экземпляров 5 в таблице не дублируется);
количество экземпляров книги "Стихотворение и поэмы"  - 15, в таблице нет других книг, количество экземпляров которых тоже равно 15, следовательно, и эта книга подходит под условие.
+ Таким образом, необходимо вывести те строки таблицы, у которых числа в столбце `amount` не повторяются.

```sql
SELECT
    author,
    title,
    amount
FROM
    book
WHERE
    amount IN (
        SELECT
            amount
        FROM
            book
        GROUP BY
            amount
        HAVING
            COUNT(amount) = 1
    );
```

Результат
```
+---------------+-----------------------+--------+
| author        | title                 | amount |
+---------------+-----------------------+--------+
| Булгаков М.А. | Белая гвардия         | 5      |
| Есенин С.А.   | Стихотворения и поэмы | 15     |
+---------------+-----------------------+--------+
```

**Пояснение к решению**

Во вложенном запросе отберите те значения столбца `amount`, количество которых, вычисленное с помощью функции `count()`, равно 1. 

[Содержание](#содержание)

<hr>

## Вложенный запрос, операторы ANY и ALL

Вложенный запрос, возвращающий несколько значений одного столбца, можно использовать для отбора записей с помощью операторов `ANY` и `ALL` совместно с операциями отношения (`=`, `<>`, `<=`, `>=`, `<`, `>`).

Операторы `ANY` и `ALL` используются  в SQL для сравнения некоторого значения с результирующим набором вложенного запроса, состоящим из одного столбца. При этом тип данных столбца, возвращаемого вложенным запросом, должен совпадать с типом данных столбца (или выражения), с которым происходит сравнение.

При использовании оператора `ANY` в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно хотя бы для одного элемента результирующего запроса. Как работает оператор `ANY`:
+ `amount` `>` `ANY (10, 12)` эквивалентно `amount` `>` `10`
+ `amount` `<` `ANY (10, 12)` эквивалентно `amount < 12`
+ `amount` `=` `ANY (10, 12)` эквивалентно `(amount = 10) OR (amount = 12)`, а также amount `IN  (10,12)`
+ `amount` `<>` `ANY (10, 12)` вернет все записи с любым значением `amount`, включая `10` и `12`

При использовании оператора `ALL` в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно для всех элементов результирующего запроса. Как работает оператор `ALL`:

+ `amount` `>` `ALL (10, 12)` эквивалентно `amount > 12`
+ `amount` `<` `ALL (10, 12)` эквивалентно `amount < 10`
+ `amount` `=` `ALL (10, 12)` не вернет ни одной записи, так как эквивалентно `(amount = 10) AND (amount = 12)`
+ `amount` `<>` `ALL (10, 12)` вернет все записи кроме тех,  в которых `amount` равно `10` или `12`

**Важно!** Операторы `ALL` и `ANY` можно использовать только с вложенными запросами. В примерах выше `(10, 12)` приводится как результат вложенного запроса просто для того, чтобы показать как эти операторы работают. В запросах так записывать нельзя.

**Пример**

Вывести информацию о тех книгах, количество которых меньше самого маленького среднего количества книг каждого автора.

Запрос:

```sql
SELECT title, author, amount, price
FROM book
WHERE amount < ALL (
        SELECT AVG(amount) 
        FROM book 
        GROUP BY author 
      );
```

Результат:

```
+--------------------+------------------+--------+--------+
| title              | author           | amount | price  |
+--------------------+------------------+--------+--------+
| Мастер и Маргарита | Булгаков М.А.    | 3      | 670.99 |
| Братья Карамазовы  | Достоевский Ф.М. | 3      | 799.01 |
+--------------------+------------------+--------+--------+
```

**Пояснение**

1. Вложенный запрос

```sql
SELECT AVG(amount) 
        FROM book 
        GROUP BY author
```

отбирает следующие записи:

```
+-------------+
| AVG(amount) |
+-------------+
| 4.0000      |
| 7.6667      |
| 15.0000     |
+-------------+
```

2. Условие отбора в основном запросе

```sql
amount < ALL (
        SELECT AVG(amount) 
        FROM book 
        GROUP BY author 
      )
```

можно переписать (если заменить вложенный запрос списком отобранных значений):

```sql
amount < ALL ( 4.0000, 7.6667, 15.0000)
```

что в соответствии с определением `ALL`, это значит, что подходят все `amount` меньшие `4.000`.

Таким образом, наш запрос отобрал все книги книги Мастер и Маргарита и Братья Карамазовы, количество которых равно 3. 

**Пример**

Вывести информацию о тех книгах, количество которых меньше самого большого среднего количества книг каждого автора.

Запрос:

```sql
SELECT title, author, amount, price
FROM book
WHERE amount < ANY (
        SELECT AVG(amount) 
        FROM book 
        GROUP BY author 
      );
```

Результат:

```
+--------------------+------------------+--------+--------+
| title              | author           | amount | price  |
+--------------------+------------------+--------+--------+
| Мастер и Маргарита | Булгаков М.А.    | 3      | 670.99 |
| Белая гвардия      | Булгаков М.А.    | 5      | 540.50 |
| Идиот              | Достоевский Ф.М. | 10     | 460.00 |
| Братья Карамазовы  | Достоевский Ф.М. | 3      | 799.01 |
| Игрок              | Достоевский Ф.М. | 10     | 480.50 |
+--------------------+------------------+--------+--------+
```

**Пояснение**

В этом примере `amount < ANY (4.0000, 7.6667, 15.0000)`  означает, что подходят `amount` меньше самого большого значения из списка.

**Задание**

Вывести информацию о книгах(автор, название, цена), цена которых меньше самой большой из минимальных цен, вычисленных для каждого автора.

```sql
SELECT
    author,
    title,
    price
FROM
    book
WHERE
    price < ANY (
        SELECT
            MIN(price)
        FROM
            book
        GROUP BY
            author
    );
```

```
+------------------+---------------+--------+
| author           | title         | price  |
+------------------+---------------+--------+
| Булгаков М.А.    | Белая гвардия | 540.50 |
| Достоевский Ф.М. | Идиот         | 460.00 |
| Достоевский Ф.М. | Игрок         | 480.50 |
+------------------+---------------+--------+
```

[Содержание](#содержание)

<hr>

## Вложенный запрос после SELECT

Вложенный запрос может располагаться после ключевого слова `SELECT`. В этом случае результат выполнения запроса выводится в отдельном столбце результирующей таблицы. При этом результатом запроса может быть только одно значение, тогда оно будет повторяться во всех строках. Также вложенный запрос может использоваться в выражениях.

**Пример**

Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3,  а также указать среднее значение количества экземпляров книг.

Запрос:

```sql
SELECT title, author, amount, 
    (
     SELECT AVG(amount) 
     FROM book
    ) AS Среднее_количество 
FROM book
WHERE abs(amount - (SELECT AVG(amount) FROM book)) >3;
```

**Пояснение**

В запросе используется функция [модуля](#вычисляемые-столбцы-математические-функции), которая позволяет учесть, что количество может отличаться от среднего как в большую, так и в меньшую сторону.

Результат:
```
+-----------------------+------------------+--------+--------------------+
| title                 | author           | amount | Среднее_количество |
+-----------------------+------------------+--------+--------------------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      | 7.6667             |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 7.6667             |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 7.6667             |
+-----------------------+------------------+--------+--------------------+
```

Во вложенном запросе вычисляется среднее количество экземпляров книг на складе. Этот запрос используется и в условии отбора, и для создания столбца `Среднее_количество` в результирующей таблице запроса. Значения  столбца одинаковы во всех строках, поскольку  вложенный запрос возвращает одно значение.

Среднее количество в виде дробного числа выглядит не очень правильно. Полученное значение можно [округлить "вниз"](#вычисляемые-столбцы-математические-функции) - до ближайшего меньшего целого.

Запрос:

```sql
SELECT title, author, amount, 
      FLOOR((SELECT AVG(amount) FROM book)) AS Среднее_количество 
FROM book
WHERE ABS(amount - (SELECT AVG(amount) FROM book)) >3;
```

Результат:

```
+-----------------------+------------------+--------+--------------------+
| title                 | author           | amount | Среднее_количество |
+-----------------------+------------------+--------+--------------------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      | 7                  |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 7                  |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 7                  |
+-----------------------+------------------+--------+--------------------+
```

**Задание**

Посчитать сколько и каких экземпляров книг нужно заказать поставщикам, чтобы на складе стало одинаковое количество экземпляров каждой книги, равное значению самого большего количества экземпляров одной книги на складе. Вывести название книги, ее автора, текущее количество экземпляров на складе и количество заказываемых экземпляров книг. Последнему столбцу присвоить имя **Заказ**. В результат не включать книги, которые заказывать не нужно.

```sql
SELECT
    title,
    author,
    amount,
    (
        SELECT
            MAX(amount)
        FROM
            book
    ) - amount AS Заказ
FROM
    book
WHERE
    amount <> (
        SELECT
            MAX(amount)
        FROM
            book
    );
```

Результат
```
+--------------------+------------------+--------+-------+
| title              | author           | amount | Заказ |
+--------------------+------------------+--------+-------+
| Мастер и Маргарита | Булгаков М.А.    | 3      | 12    |
| Белая гвардия      | Булгаков М.А.    | 5      | 10    |
| Идиот              | Достоевский Ф.М. | 10     | 5     |
| Братья Карамазовы  | Достоевский Ф.М. | 3      | 12    |
| Игрок              | Достоевский Ф.М. | 10     | 5     |
+--------------------+------------------+--------+-------+
```

**Пояснение**

Поскольку книгу с максимальным количеством экземпляров заказывать не нужно, в условии отбора запроса укажите, что книгу с максимальным значением количества в результирующую таблицу не включать. 

[Содержание](#содержание)

<hr>

## TODO

**Задание**

Придумайте один или несколько запросов к нашей таблице `book`, используя вложенные запросы. Проверьте, правильно ли они работают.

При желании можно формулировку запросов  разместить в комментариях. 

Размещенные задания можно использовать для закрепления материала урока.

Оценивайте понравившиеся Вам запросы.

В последнем модуле создан отдельный урок, в котором  мы разместим запросы, набравшие наибольшее количество лайков. 

Структура и наполнение таблицы `book`:

book_id | title | author | price | amount
-|-|-|-|-
INT PRIMARY KEY AUTO_INCREMENT | VARCHAR(50) | VARCHAR(30) | DECIMAL(8,2) | INT
1 | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3
2 | Белая гвардия | Булгаков М.А. | 540.50 | 5
3 | Идиот | Достоевский Ф.М. | 460.00 | 10
4 | Братья Карамазовы | Достоевский Ф.М. | 799.01 | 3
5 | Игрок | Достоевский Ф.М. | 480.50 | 10
6 | Стихотворения и поэмы | Есенин С.А. | 650.00 | 15

[Содержание](#содержание)

<hr>

# 1.5 Запросы корректировки данных

## Содержание урока

SQL позволяет не только выбирать данные из таблиц базы данных, но и корректировать информацию в них. Для этого используются запросы корректировки данных, с помощью которых можно:
+ создать пустую таблицу;
+ добавить в таблицу записи как совокупность значений;
+ добавить записи из другой таблицы;
+ добавить записи из другой таблицы, используя вложенный запрос;
+ изменить значения в одном столбце;
+ изменить значения в нескольких столбцах;
+ изменить данные, используя несколько таблиц;
+ удалить записи из таблицы;
+ создать таблицу на основе данных других таблиц.

[Содержание](#содержание)

<hr>

## Создание пустой таблицы

Создание таблицы осуществляется с помощью запроса `CREATE`, подробно рассмотренного в [первом уроке модуля](#создание-таблицы).

**Задание**

Создать таблицу поставок (`supply`), которая имеет ту же структуру, что и таблица `book`.

Поле | Тип, описание
-|-
supply_id | INT PRIMARY KEY AUTO_INCREMENT
title | VARCHAR(50)
author | VARCHAR(30)
price | DECIMAL(8, 2)
amount | INT

```sql
CREATE TABLE supply(
   supply_id INT PRIMARY KEY AUTO_INCREMENT,
       title VARCHAR(50),
      author VARCHAR(30),
       price DECIMAL(8, 2),
      amount INT
);
```

[Содержание](#содержание)

<hr>

## Добавление записей в таблицу

Добавление одной записи в таблицу осуществляется с помощью запроса `INSERT`, подробно рассмотренного в первом уроке. Запросы обязательно разделять точкой с запятой.

Допускается вставка нескольких записей одновременно, для этого используется SQL запрос следующего вида:

```sql
INSERT INTO имя_таблицы(столбец_1, столбец_2, ..., столбец_N)
VALUES
    (значение_1_1, значение_1_2, ..., значение_1_N),
    (значение_2_1, значение_2_2, ..., значение_2_N),
    ...
    (значение_M_1, значение_M_2, ..., значение_M_N);
```

Например, чтобы добавить в таблицу book две новые записи используется запрос:

```sql
INSERT INTO book (title, author, price, amount) 
VALUES 
    ('Война и мир','Толстой Л.Н.', 1070.20, 2),
    ('Анна Каренина', 'Толстой Л.Н.', 599.90, 3);
```

**Задание**

Занесите в таблицу `supply` четыре записи, чтобы получилась следующая таблица:

supply_id | title | author | price | amount
-|-|-|-|-
1 | Лирика | Пастернак Б.Л. | 518.99 | 2
2 | Черный человек  | Есенин С.А. | 570.20 | 6
3 | Белая гвардия | Булгаков М.А. | 540.50 | 7
4 | Идиот | Достоевский Ф.М. | 360.80 | 3

**Пояснение**

Для просмотра полученной таблицы после запросов (запроса) на добавление  вставить запрос на выборку всех данных из таблицы `supply`.

```sql
INSERT INTO
    supply (title, author, price, amount)
VALUES
    ('Лирика', 'Пастернак Б.Л.', 518.99, 2),
    ('Черный человек', 'Есенин С.А.', 570.20, 6),
    ('Белая гвардия', 'Булгаков М.А.', 540.50, 7),
    ('Идиот', 'Достоевский Ф.М.', 360.80, 3);

SELECT
    *
FROM
    supply;
```

**Результат**

```
Affected rows: 4
Query result:
+-----------+----------------+------------------+--------+--------+
| supply_id | title          | author           | price  | amount |
+-----------+----------------+------------------+--------+--------+
| 1         | Лирика         | Пастернак Б.Л.   | 518.99 | 2      |
| 2         | Черный человек | Есенин С.А.      | 570.20 | 6      |
| 3         | Белая гвардия  | Булгаков М.А.    | 540.50 | 7      |
| 4         | Идиот          | Достоевский Ф.М. | 360.80 | 3      |
+-----------+----------------+------------------+--------+--------+
```

[Содержание](#содержание)

<hr>

## Добавление записей из другой таблицы

С помощью запроса на добавление можно не только добавить в таблицу конкретные значения (список `VALUES`), но и записи из другой таблицы, отобранные с помощью запроса на выборку.  В этом случае вместо раздела `VALUES` записывается запрос на выборку, начинающийся с `SELECT`.  В нем можно использовать `WHERE`, `GROUP BY`, `ORDER BY`.

Правила соответствия между полями таблицы и вставляемыми значениями из запроса:
+ количество полей в таблице и количество полей в запросе должны совпадать;
+ должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках, поэтому первый столбец запроса должен относиться к первому столбцу в списке столбцов таблицы, второй – ко второму столбцу и т.д.
+ типы столбцов запроса должны быть совместимы с типами данных соответствующих столбцов таблицы ( целое число можно занести в поле типа DECIMAL, обратная операция – недопустима).

**Пример**

Занести все книги из таблицы `supply` в таблицу `book`.

Запрос:

```sql
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply;

SELECT * FROM book;
```

**Результат:**

```
Affected rows: 4
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 6       | Лирика                | Пастернак Б.Л.   | 518.99 | 2      |
| 7       | Черный человек        | Есенин С.А.      | 570.20 | 6      |
| 8       | Белая гвардия         | Булгаков М.А.    | 540.50 | 7      |
| 9       | Идиот                 | Достоевский Ф.М. | 360.80 | 3      |
+---------+-----------------------+------------------+--------+--------+
Affected rows: 9
```

С помощью этого запроса в таблицу `book` включены все книги из `supply`, даже те, которые в `book` уже есть («Белая гвардия» и «Идиот»). В результате в таблице одна и та же книга, например «Белая гвардия», имеет код 2 и 8. Для реляционной модели это нежелательная ситуация. Устранить эту проблему можно с помощью вложенных запросов, которые будут рассмотрены в следующем шаге.

**Задание**

Добавить из таблицы `supply` в таблицу `book`, все книги, кроме книг, написанных Булгаковым М.А. и Достоевским Ф.М.

**Пояснение**

Задание нужно выполнить без вложенных запросов.

```sql
INSERT INTO
    book (title, author, price, amount)
SELECT
    title,
    author,
    price,
    amount
FROM
    supply
WHERE
    author <> 'Достоевский Ф.М.'
    and author <> 'Булгаков М.А.';

SELECT
    *
FROM
    book;
```

**Результат**

```
Affected rows: 2
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 6       | Лирика                | Пастернак Б.Л.   | 518.99 | 2      |
| 7       | Черный человек        | Есенин С.А.      | 570.20 | 6      |
+---------+-----------------------+------------------+--------+--------+
```

[Содержание](#содержание)

<hr>

## Добавление записей, вложенные запросы
В запросах на добавление можно использовать вложенные запросы.

**Пример**

Занести из таблицы `supply` в таблицу `book` только те книги, названия которых отсутствуют в таблице `book`.

Запрос:

```sql
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply
WHERE title NOT IN (
        SELECT title 
        FROM book
      );

SELECT * FROM book;
```

**Результат:**

```
Affected rows: 2
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 6       | Лирика                | Пастернак Б.Л.   | 518.99 | 2      |
| 7       | Черный человек        | Есенин С.А.      | 570.20 | 6      |
+---------+-----------------------+------------------+--------+--------+
```

Вложенным запросом отбираются все названия книг, которые есть в таблице `book`. Основным запросом `SELECT` из таблицы `supply` выбираются книги, названия которых нет в результате вложенного запроса. Отобранные записи добавляются в конец таблицы `book` запросом на добавление `INSERT`.

**Задание**

Занести из таблицы `supply` в таблицу `book` только те книги, авторов которых нет в `book`.

```sql
INSERT INTO book (title, author, price, amount) 
     SELECT title, author, price, amount 
       FROM supply
      WHERE author NOT IN (
            SELECT author 
              FROM book
      );

SELECT * 
  FROM book;
```

**Результат**

```
Affected rows: 1

Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 6       | Лирика                | Пастернак Б.Л.   | 518.99 | 2      |
+---------+-----------------------+------------------+--------+--------+
```

[Содержание](#содержание)

<hr>

## Запросы на обновление

Под обновлением данных подразумевается изменение значений в существующих записях таблицы. При этом возможно как изменение значений полей в группе строк (даже всех строк таблицы), так и правка значения поля отдельной строки.

Изменение записей в таблице реализуется с помощью запроса `UPDATE`. Простейший запрос на  обновление выглядит так:

```sql
UPDATE таблица SET поле = выражение
```
где 
+ **таблица** – имя таблицы, в которой будут проводиться изменения;
+ **поле** – поле таблицы, в которое будет внесено изменение;
+ **выражение** – выражение,  значение которого будет занесено в поле.

**Пример**

Уменьшить на 30% цену книг в таблице `book`.

Запрос:

```sql
UPDATE book 
SET price = 0.7 * price;

SELECT * FROM book;
```

**Результат:**

```
Affected rows: 5
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 469.69 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 378.35 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 322.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 559.31 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 455.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
```

С помощью запросов на обновление можно изменять не все записи в таблице (как в предыдущем запросе), а только часть из них. Для этого в запрос включается ключевое слово `WHERE`, после которого указывается условие отбора строк для изменения.

**Пример**

Уменьшить на 30% цену тех книг в таблице `book`, количество которых меньше `5`.

Запрос:

```sql
UPDATE book 
SET price = 0.7 * price 
WHERE amount < 5;

SELECT * FROM book;
```

Результат:

```
Affected rows: 2
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 469.69 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 559.31 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
```

В этом запросе обновляется только `2` записи (цена книг «Мастер и Маргарита» и «Братья Карамазовы»).

**Задание**

Уменьшить на 10% цену тех книг в таблице `book`, количество которых принадлежит интервалу от 5 до 10, включая границы.

```sql
UPDATE
    book
SET
    price = 0.9 * price
WHERE
    amount BETWEEN 5
    AND 10;

SELECT
    *
FROM
    book;
```

***Результат***

```
Affected rows: 2
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 486.45 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 414.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
```

[Содержание](#содержание)

<hr>

## Запросы на обновление нескольких столбцов

Запросом `UPDATE` можно обновлять значения нескольких столбцов одновременно. В этом случае простейший запрос будет выглядеть так:

```sql
UPDATE таблица SET поле1 = выражение1, поле2 = выражение2
```

На складе, кроме хранения и получения книг, выполняется их оптовая продажа. Для реализации этого действия включим дополнительный столбец `buy`  в таблицу `book`:

book_id | title | author | price | amount | buy
-|-|-|-|-|-
INT PRIMARY KEY AUTO_INCREMENT | VARCHAR(50) | VARCHAR(30) | DECIMAL(8,2) | INT | int
1 | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3 | 0
2 | Белая гвардия | Булгаков М.А. | 540.50 | 5 | 3
3 | Идиот | Достоевский Ф.М. | 460.00 | 10 | 8
4 | Братья Карамазовы | Достоевский Ф.М. | 799.01 | 2 | 0
5 | Стихотворения и поэмы | Есенин С.А. | 650.00 | 15 | 18

**Пример**

В столбце `buy` покупатель указывает количество книг, которые он хочет приобрести. Для каждой книги, выбранной покупателем, необходимо уменьшить ее количество на складе на указанное в столбце `buy` количество, а в столбец `buy` занести 0.

Запрос:

```sql
UPDATE book 
SET amount = amount - buy,
    buy = 0;

SELECT * FROM book;
```

Результат:

```
Affected rows: 3
Query result:
+---------+-----------------------+------------------+--------+--------+-----+
| book_id | title                 | author           | price  | amount | buy |
+---------+-----------------------+------------------+--------+--------+-----+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      | 0   |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 2      | 0   |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 2      | 0   |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      | 0   |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | -3     | 0   |
+---------+-----------------------+------------------+--------+--------+-----+
```

Как видно из таблицы, без проверки данных, которые занесены в столбец,  нельзя запускать запрос на обновление (может получиться отрицательное значение количества).

**Задание**

В таблице `book` необходимо скорректировать значение для покупателя в столбце `buy` таким образом, чтобы оно не превышало количество экземпляров книг, указанных в столбце `amount`. А цену тех книг, которые покупатель не заказывал, снизить на `10%`.

**Пояснение**

Запрос на обновление количества книг должен корректировать значения в столбце `buy` таблицы `book` следующим образом:
+ если покупатель заказал количество книг больше, чем есть на складе, то заменить значение `buy` на имеющееся на складе количество `amount`;
+ если покупатель хочет купить количество книг меньшее или равное количеству книг на складе, то значение `buy` изменять не надо.

Для реализации этого запроса можно  использовать функцию `if()`.  Синтаксис раздела `SET` при использовании функции `if()` следующий:

```sql
SET столбец = IF(условие, выражение_1, выражение_2)
```

Выполняется этот оператор так:
+ сначала вычисляется условие;
+ если условие ИСТИНА, то вычисляется выражение_1, в противном случае (если условие ЛОЖНО) вычисляется выражение_2;
+ в столбец заносится результат выполнения функции (либо значение выражения_1, либо значение выражения_2 в зависимости от условия).

Например, для увеличения на 10% только цен книг Булгакова используется запрос:

```sql
UPDATE book 
SET price = IF(author = "Булгаков М.А.", price * 1.1, price);
```

```sql
UPDATE
    book
SET
    buy = IF (amount < buy, amount, buy),
    price = IF (buy = 0, price * 0.9, price);
    
SELECT
    *
FROM
    book;
```

**Результат**

```
Affected rows: 3
Query result:
+---------+-----------------------+------------------+--------+--------+-----+
| book_id | title                 | author           | price  | amount | buy |
+---------+-----------------------+------------------+--------+--------+-----+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 603.89 | 3      | 0   |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      | 3   |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     | 8   |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 719.11 | 2      | 0   |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     | 15  |
+---------+-----------------------+------------------+--------+--------+-----+
```

[Содержание](#содержание)

<hr>

## Запросы на обновление нескольких таблиц

В запросах на обновление можно использовать несколько таблиц, но тогда
+ для столбцов, имеющих одинаковые имена, необходимо указывать имя таблицы, к которой они относятся, например, `book.price` – столбец `price` из таблицы `book`, `supply.price` – столбец `price` из таблицы `supply`;
+ все таблицы, используемые в запросе, нужно перечислить после ключевого слова `UPDATE`;
+ в запросе обязательно условие `WHERE`, в котором указывается условие при котором обновляются данные.

**Пример**

Если в таблице `supply`  есть те же книги, что и в таблице `book`, добавлять эти книги в таблицу `book` не имеет смысла. Необходимо увеличить их количество на значение столбца `amount` таблицы `supply`.

Запрос:

```sql
UPDATE book, supply 
SET book.amount = book.amount + supply.amount
WHERE book.title = supply.title AND book.author = supply.author;

SELECT * FROM book;
```

Результат:

```
Affected rows: 2
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 12     |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 13     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
```

В этом запросе увеличилось количество двух книг: «Белая гвардия», которая в `supply` имеет ту же цену, и «Идиот», но цена этой книги в таблицах `book` и `supply` отличается. Для этой книги нужно пересчитать цену.

**Задание**

Для тех книг в таблице `book` , которые есть в таблице `supply`, не только увеличить их количество в таблице `book` ( увеличить их количество на значение столбца `amount` таблицы `supply`), но и пересчитать их цену (для каждой книги найти сумму цен из таблиц `book` и `supply` и разделить на `2`).

**Пояснение**

Пересчет для книг с одинаковым названием и ценой не повлияет на результат, поэтому в запросе не обязательно рассматривать два случая: когда цена у одинаковых книг равна и когда нет.

```sql
UPDATE
    book,
    supply
SET
    book.amount = book.amount + supply.amount,
    book.price = (book.price + supply.price) / 2
WHERE
    book.title = supply.title
    AND book.author = supply.author;

SELECT
    *
FROM
    book;
```

**Результат**

```
Affected rows: 2
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 12     |
| 3       | Идиот                 | Достоевский Ф.М. | 410.40 | 13     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
```

[Содержание](#содержание)

<hr>

## Запросы на удаление

Запросы корректировки данных позволяют удалить одну или несколько записей из  таблицы. Простейший запрос на удаление имеет вид:

```sql
DELETE FROM таблица;
```

Этот запрос удаляет все записи из указанной после `FROM` таблицы.

**Пример**

После того, как информация о книгах из таблицы `supply` перенесена в book , необходимо очистить таблицу  `supply`.

**Запрос:**

```sql
DELETE FROM supply;

SELECT * FROM supply;
```

**Результат:**

```
Affected rows: 4
Affected rows: 0
```

Из таблицы удалены все записи. Запрос на выборку отобрал 0 записей.

Запрос на удаления позволяет удалить не все записи таблицы, а только те, которые удовлетворяют условию, указанному после ключевого слова `WHERE`:

```sql
DELETE FROM таблица
WHERE условие;
```

**Пример**

Удалить из таблицы `supply` все книги, названия которых есть в таблице `book`.

Запрос:

```sql
DELETE FROM supply 
WHERE title IN (
        SELECT title 
        FROM book
      );

SELECT * FROM supply;
```

Результат:

```
Affected rows: 2

Query result:
+-----------+--------------------------+------------------+--------+--------+
| supply_id | title                    | author           | price  | amount |
+-----------+--------------------------+------------------+--------+--------+
| 1         | Лирика                   | Пастернак Б.Л.   | 518.99 | 2      |
| 2         | Черный человек           | Есенин С.А.      | 570.20 | 6      |
+-----------+--------------------------+------------------+--------+--------+
```

Из таблицы `supply` удалены две записи о книгах «Белая гвардия» и «Идиот».

**Задание**

Удалить из таблицы `supply` книги тех авторов, общее количество экземпляров книг которых в таблице `book` превышает `10`.

```sql
DELETE FROM
    supply
WHERE
    author IN (
        SELECT
            author
        FROM
            book
        GROUP BY
            author
        HAVING
            SUM(amount) > 10
    );

SELECT
    *
FROM
    supply;
```

**Результат**

```
Affected rows: 2

Query result:
+-----------+---------------+----------------+--------+--------+
| supply_id | title         | author         | price  | amount |
+-----------+---------------+----------------+--------+--------+
| 1         | Лирика        | Пастернак Б.Л. | 518.99 | 2      |
| 3         | Белая гвардия | Булгаков М.А.  | 540.50 | 7      |
+-----------+---------------+----------------+--------+--------+
```

[Содержание](#содержание)

<hr>

## Запросы на создание таблицы

Новая таблица может быть создана на основе данных из другой таблицы. Для этого используется запрос `SELECT`, результирующая таблица которого и будет новой таблицей базы данных. При этом имена столбцов запроса становятся именами столбцов новой таблицы. Запрос на создание новой таблицы имеет вид:

```sql
CREATE TABLE имя_таблицы AS
SELECT ...
```

**Пример**

Создать таблицу заказ (`ordering`), куда включить авторов и названия тех книг, количество экземпляров которых в таблице `book` меньше `4`. Для всех книг указать одинаковое количество экземпляров `5`.

Запрос:

```sql
CREATE TABLE ordering AS
SELECT author, title, 5 AS amount
FROM book
WHERE amount < 4;

SELECT * FROM ordering;
```

**Результат:**

```
Affected rows: 2
Query result:
+------------------+--------------------+--------+
| author           | title              | amount |
+------------------+--------------------+--------+
| Булгаков М.А.    | Мастер и Маргарита | 5      |
| Достоевский Ф.М. | Братья Карамазовы  | 5      |
+------------------+--------------------+--------+
```

При создании таблицы можно использовать вложенные запросы как после `SELECT`, так и после `WHERE`.

**Пример**

Создать таблицу заказ (`ordering`), куда включить авторов и названия тех книг, количество экземпляров которых в таблице `book` меньше 4. Для всех книг указать одинаковое значение - среднее количество экземпляров книг в таблице `book`.

Запрос:

```sql
CREATE TABLE ordering AS
SELECT author, title, 
   (
    SELECT ROUND(AVG(amount)) 
    FROM book
   ) AS amount
FROM book
WHERE amount < 4;

SELECT * FROM ordering;
```

Результат:

```
Affected rows: 2
Query result:
+------------------+--------------------+--------+
| author           | title              | amount |
+------------------+--------------------+--------+
| Булгаков М.А.    | Мастер и Маргарита | 7      |
| Достоевский Ф.М. | Братья Карамазовы  | 7      |
+------------------+--------------------+--------+
```

**Задание**

Создать таблицу заказ (`ordering`), куда включить авторов и названия тех книг, количество экземпляров которых в таблице `book` меньше среднего количества экземпляров книг в таблице `book`. В таблицу включить столбец   `amount`, в котором для всех книг указать одинаковое значение - среднее количество экземпляров книг в таблице `book`.

```sql
CREATE TABLE ordering AS
SELECT
    author,
    title,
    (
        SELECT
            ROUND(AVG(amount))
        FROM
            book
    ) AS amount
FROM
    book
WHERE
    amount < (
        SELECT
            ROUND(AVG(amount))
        FROM
            book
    );

SELECT
    *
FROM
    ordering;
```

**Результат**

```
Affected rows: 3
Query result:
+------------------+--------------------+--------+
| author           | title              | amount |
+------------------+--------------------+--------+
| Булгаков М.А.    | Мастер и Маргарита | 7      |
| Булгаков М.А.    | Белая гвардия      | 7      |
| Достоевский Ф.М. | Братья Карамазовы  | 7      |
+------------------+--------------------+--------+
```

[Содержание](#содержание)

<hr>

## TODO

**Задание**

Придумайте один или несколько запросов корректировки данных к  таблицам `book` и  `supply` . Проверьте, правильно ли они работают.

При желании можно формулировку запросов  разместить в комментариях. 

Размещенные задания можно использовать для закрепления материала урока.

Оценивайте понравившиеся Вам запросы.

В последнем модуле создан отдельный урок, в котором мы разместим запросы, набравшие наибольшее количество лайков.

Структура и наполнение таблиц:

Таблица `book`

book_id | title | author | price | amount
-|-|-|-|-
1 | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3
2 | Белая гвардия | Булгаков М.А. | 540.50 | 5
3 | Идиот | Достоевский Ф.М. | 460.00 | 10
4 | Братья Карамазовы | Достоевский Ф.М. | 799.01 | 2
5 | Стихотворения и поэмы | Есенин С.А. | 650.00 | 15

Таблица `supply` :

supply_id | title | author | price | amount
-|-|-|-|-
1 | Лирика | Пастернак Б.Л. | 518.99 | 2
2 | Черный человек  | Есенин С.А. | 570.20 | 6
3 | Белая гвардия | Булгаков М.А. | 540.50 | 7
4 | Идиот | Достоевский Ф.М. | 360.80 | 3

# 1.6 Таблица "Командировки", запросы на выборку

[Содержание](#содержание)

<hr>

# 1.7 Таблица "Нарушения ПДД", запросы корректировки

[Содержание](#содержание)

<hr>

# 1.8 Глоссарий и поиск по курсу

[Содержание](#содержание)

<hr>
