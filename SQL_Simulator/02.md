# 2. Запросы SQL к связанным таблицам

В модуле рассматриваются связи между таблицами реляционной базы данных, а также различные виды запросов, построенных на связанных таблицах

## Содержание

+ [2.1 Связи между таблицами](#21-связи-между-таблицами)
    + [Связь «один ко многим»](#связь-один-ко-многим)
    + [Связь «многие ко многим»](#связь-многие-ко-многим)
    + [Создание таблицы с внешними ключами](#создание-таблицы-с-внешними-ключами)
    + [Действия при удалении записи главной таблицы](#действия-при-удалении-записи-главной-таблицы)
    + [Заполнение таблицы с внешними ключами](#заполнение-таблицы-с-внешними-ключами)
    + [Добавьте три последние записи ](#добавьте-три-последние-записи)
+ [2.2 Запросы на выборку, соединение таблиц](#22-запросы-на-выборку-соединение-таблиц)
    + [Соединение INNER JOIN](#соединение-inner-join)
    + [Внешнее соединение LEFT и RIGHT OUTER JOIN](#внешнее-соединение-left-и-right-outer-join)
    + [Перекрестное соединение CROSS JOIN](#перекрестное-соединение-cross-join)
    + [Запросы для нескольких таблиц с группировкой](#запросы-для-нескольких-таблиц-с-группировкой)
    + [Запросы для нескольких таблиц со вложенными запросами](#запросы-для-нескольких-таблиц-со-вложенными-запросами)
    + [Вложенные запросы в операторах соединения](#вложенные-запросы-в-операторах-соединения)
    + []()
    + []()
+ [2.3 Запросы корректировки, соединение таблиц](#23-запросы-корректировки-соединение-таблиц)
+ [2.4 База данных «Интернет-магазин книг», запросы на выборку](#24-база-данных-интернет-магазин-книг-запросы-на-выборку)
+ [2.5 База данных «Интернет-магазин книг», запросы корректировки](#25-база-данных-интернет-магазин-книг-запросы-корректировки)

[Оглавление](/SQL_Simulator/README.MD)

# 2.1 Связи между таблицами

**Содержание урока**

Средствами SQL запросов можно выбирать и обрабатывать данные не только из одной таблицы, но из нескольких связанных таблиц. В данном уроке мы рассмотрим способы соединения таблиц:
+ связь между таблицами «один ко многим»;
+ связь между таблицами «многие ко многим»;
+ создание таблицы с внешними ключами;
+ действия при удалении записи главной таблицы;
+ заполнение таблицы с внешними ключами;
+ добавление данных в таблицу с внешними ключами.

[Содержание](#содержание)

<hr>

## Связь «один ко многим»

Рассмотрим таблицу `book`(в ней столбец `author` переименован в `name_author`):

book_id | title | name_author | price | amount
-|-|-|-|-
1 | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3
2 | Белая гвардия | Булгаков М.А. | 540.50 | 5
3 | Идиот | Достоевский Ф.М. | 460.00 | 10
4 | Братья Карамазовы | Достоевский Ф.М. | 799.01 | 2
5 | Стихотворения и поэмы | Есенин С.А. | 650.00 | 15

В этой таблице фамилии авторов повторяются для нескольких книг. А что, если придется вместо инициалов для каждого автора хранить его полное имя и отчество? Тогда, если в таблице содержится информация о 50 книгах Достоевского, придется 50 раз исправлять «Ф.М.» на «Федор Михайлович». При этом, если в некоторых записях использовать «Фёдор Михайлович» (c буквой ё), то мы вообще получим двух разных авторов... 

Чтобы устранить эту проблему в реляционных базах данных создается новая таблица `author`,  в которой перечисляются все различные авторы, а затем эта таблица связывается с таблицей `book`. При этом такая связь называется «один ко многим», таблица `author` называется главной, таблица `book` – связанной или подчиненной. 

Связь «один ко многим» имеет место, когда одной записи главной таблицы соответствует несколько записей связанной таблицы, а каждой записи связанной таблицы соответствует только одна запись главной таблицы. Обозначается это так:

![02](/SQL_Simulator/img/02_01.jpg)

**Этапы реализации связи «один ко многим» на следующем примере:**

Один автор может написать несколько книг, а одна книга написана только одним автором. Для каждой книги известны ее количество и цена.

1. Создать таблицу `author`,  в которую включить уникальных авторов книг, хранящихся на складе:

![02](/SQL_Simulator/img/02_02.jpg)

2. Обе таблицы должны содержать первичный ключ, в таблице  `book` он уже есть,  в таблицу `author` добавим ключ `author_id`:

![02](/SQL_Simulator/img/02_03.jpg)

3. Включить в таблицу `book` связанный столбец (внешний ключ, `FOREIGN KEY`), соответствующий по имени и типу ключевому столбцу главной таблицы (в нашем случае это столбец `author_id`). Для наглядности связь на схеме обозначается стрелкой от ключевого столбца главной таблицы к внешнему ключу связной таблицы:

![02](/SQL_Simulator/img/02_04.jpg)

**Задание**

Добавить новую характеристику книги – ее жанр, если считать, что каждая книга относится к одному жанру, то есть между ними определена связь «один ко многим». Расположите в правильном порядке этапы связывания таблицы с жанрами (`genre`) и таблицы `book`.

![02](/SQL_Simulator/img/02_05.jpg)

![02](/SQL_Simulator/img/02_06.jpg)

![02](/SQL_Simulator/img/02_07.jpg)

[Содержание](#содержание)

<hr>

## Связь «многие ко многим»

На предыдущем шаге мы реализовали связь «один ко многим» для книг и авторов. Она означает, что каждый автор написал несколько книг, но каждую книгу написал только один автор. На самом деле, это не совсем верное утверждение. Например, книга «12 стульев» написана двумя авторами Ильфом И.А. и Петровым Е.П. С другой стороны, эти авторы написали и другие книги, например «Золотой теленок».

Для соединения таких таблиц используется связь «многие ко многим».

Связь «многие ко многим» имеет место когда каждой записи одной таблицы соответствует несколько записей во второй, и наоборот, каждой записи второй таблицы соответствует несколько записей в первой. Обозначается это так:

![02](/SQL_Simulator/img/02_08.jpg)

**Этапы реализации связи «многие ко многим»**  на следующем примере:

Один автор может написать несколько книг, а одна книга может быть написана несколькими авторами. Для каждой книги известны ее количество и цена.

1. Создать таблицу ``author``,  в которую включить уникальных авторов книг, хранящихся на складе:

![02](/SQL_Simulator/img/02_09.jpg)

2. В обеих таблицах необходимо определить первичный ключ, в нашем случае в таблице `book` он уже есть, поэтому достаточно включить первичный ключ `author_id` в таблицу `author`:

![02](/SQL_Simulator/img/02_10.jpg)

3. Создать новую таблицу-связку, состоящую из двух столбцов, соответствующих по имени и типу ключевым столбцам исходных таблиц. Каждый из этих столбцов является внешним ключом (`FOREIGN KEY`)  и связан с ключевым столбцом каждой таблицы. Для наглядности связи на схеме обозначаются стрелкой от ключевого столбца исходной таблицы к внешнему ключу связной таблицы.

![02](/SQL_Simulator/img/02_11.jpg)

4. Дальше необходимо определиться с первичным ключом таблицы-связки. Можно сделать два ключевых столбца, тогда все записи в этой таблице должны быть уникальными, то есть не повторяться. Для связи автор-книга этот вариант подходит. Но в некоторых случаях записи в таблице-связке могут повторяться, например, если мы будем продавать книги покупателям (один человек может купить несколько книг, а одну и ту же книгу могут купить несколько человек). Тогда в таблицу-связку включают дополнительные столбцы для идентификации записей, например, дату продажи,  также в таблицу-связку добавляют первичный ключ. Мы воспользуемся вторым способом:

![02](/SQL_Simulator/img/02_12.jpg)

**Задание**

Добавить новую характеристику книги – ее жанр, если считать, что каждая книга может относиться к нескольким жанрам, а каждый жанр включает несколько книг, то есть между ними определена связь «многие ко многим».

Расположите в правильном порядке этапы связывания таблиц `genre` и `book`.

![02](/SQL_Simulator/img/02_13.jpg)

![02](/SQL_Simulator/img/02_14.jpg)

![02](/SQL_Simulator/img/02_15.jpg)

![02](/SQL_Simulator/img/02_16.jpg)

**Задание**

Выберите тип связи, который подходит для описания пар информационных объектов.

В группе учатся студенты, каждый студент может учиться только в одной группе: <br>
`студент <--- группа`

Студенты изучают несколько дисциплин, одну и ту же дисциплину могут изучать несколько студентов:<br>
`студент <---> дисциплина`

В библиотеке студент может взять несколько книг, одну и ту же книгу могут взять несколько студентов (в разное время): <br>
`студент <---> книга`

Каждый студент родился в определенном городе, в одном городе родились несколько студентов: <br>
`город ---> студент`

Каждый город относится к определенной стране, в каждой стране есть несколько городов: <br>
`страна ---> город`

**Задание**

Дана таблица `trip`. Выберите одну или несколько схем, которые позволяют правильно представить информацию из этой таблицы в виде нескольких связанных таблиц.

trip_id | name | city | per_diem | date_first | date_last
-|-|-|-|-|-
1 | Баранов П.Е. | Москва | 700 | 2020-01-12 | 2020-01-17
2 | Абрамова К.А. | Владивосток | 450 | 2020-01-14 | 2020-01-27
3 | Семенов И.В. | Москва | 700 | 2020-01-23 | 2020-01-31
4 | Семенов И.В. | Владивосток | 450 | 2020-02-12 | 2020-02-22

**Пояснение**

Для решения этой задачи необходимо:
1. Проанализировать информацию и выделить повторяющиеся данные в отдельные таблицы. Это будут Сотрудники и Города.
2. Определить тип связи между таблицами (многие ко многим или один ко многим), который позволит описать командировки сотрудников - выбрать верный вариант из предложенных. При этом связь один ко многим обозначается стрелкой (например,  для Дома и Квартиры определена связь один ко многим, которая обозначается как `Дом --> Квартира`).
3. Определить, как данная связь реализуется в реляционной модели - выбрать верный вариант. 

Здесь нужно выбрать не полностью готовую схему БД, а все адекватные связи, которые могли бы быть между этими таблицами (среди них 1-полная схема из 3 таблиц). Обращайте внимание на направление стрелочек.

![02](/SQL_Simulator/img/02_17.jpg)

![02](/SQL_Simulator/img/02_18.jpg)

**Задание**

Создать таблицу `author` следующей структуры:

Поле | Тип, описание
-|-
author_id | INT PRIMARY KEY AUTO_INCREMENT
name_author | VARCHAR(50)

```sql
CREATE TABLE author(
    author_id INT PRIMARY KEY AUTO_INCREMENT,
    name_author VARCHAR(50)
);
```

**Задание**

Заполнить таблицу `author`. В нее включить следующих авторов:

+ Булгаков М.А.
+ Достоевский Ф.М.
+ Есенин С.А.
+ Пастернак Б.Л.

```sql
INSERT INTO
    author (name_author)
VALUES
    ('Булгаков М.А.'),
    ('Достоевский Ф.М.'),
    ('Есенин С.А.'),
    ('Пастернак Б.Л.');

SELECT
    *
FROM
    author;
```

**Результат**

```
Affected rows: 4
Query result:
+-----------+------------------+
| author_id | name_author      |
+-----------+------------------+
| 1         | Булгаков М.А.    |
| 2         | Достоевский Ф.М. |
| 3         | Есенин С.А.      |
| 4         | Пастернак Б.Л.   |
+-----------+------------------+
Affected rows: 4
```

[Содержание](#содержание)

<hr>

## Создание таблицы с внешними ключами

При создании зависимой таблицы (таблицы, которая содержит внешние ключи) необходимо учитывать, что :
+ каждый внешний ключ должен иметь такой же тип данных, как связанное поле главной таблицы (в наших примерах это `INT`);
+ необходимо указать главную для нее таблицу и столбец, по которому осуществляется связь:

```sql
FOREIGN KEY (связанное_поле_зависимой_таблицы)  
REFERENCES главная_таблица (связанное_поле_главной_таблицы)
```

По умолчанию любой столбец, кроме ключевого, может содержать значение `NULL`. При создании таблицы это можно переопределить,  используя  ограничение `NOT NULL` для этого столбца:

```sql
CREATE TABLE таблица (
    столбец_1 INT NOT NULL, 
    столбец_2 VARCHAR(10) 
);
```

В созданной таблице в `столбец_1` не может содержать пустое значение, а `столбец_2` - может.

Для внешних ключей рекомендуется устанавливать ограничение `NOT NULL` (если это совместимо с другими опциями, которые будут рассмотрены в следующем шаге).

**Пример**

Создать таблицу `book` следующей структуры:

Поле | Тип, описание | Связи
-|-|-
`book_id` | INT PRIMARY KEY AUTO_INCREMENT |  
`title` | VARCHAR(50) |  
`author_id` | INT  | внешний ключ:<br>главная таблица `author`,<br>связанный столбец `author.author_id`,<br>пустое значение не допускается
`price` | DECIMAL(8, 2) |  
`amount` | INT |  

Запрос:

```sql
CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT, 
    title VARCHAR(50), 
    author_id INT NOT NULL, 
    price DECIMAL(8,2), 
    amount INT, 
    FOREIGN KEY (author_id)  REFERENCES author (author_id) 
);
```

**Задание**

Перепишите запрос на создание таблицы `book` , чтобы ее структура соответствовала структуре, показанной на логической схеме (таблица `genre` уже создана, порядок следования столбцов - как на логической схеме в таблице `book`, `genre_id`  - внешний ключ) . Для `genre_id` ограничение о недопустимости пустых значений не задавать. В качестве главной таблицы для описания поля  `genre_id` использовать таблицу `genre` следующей структуры:

Поле | Тип, описание
-|-
genre_id | INT PRIMARY KEY AUTO_INCREMENT
name_genre | VARCHAR(30)

Логическая схема (нужно создать только таблицу `book`):

![02](/SQL_Simulator/img/02_19.jpg)

```sql
CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT, 
    title VARCHAR(50), 
    author_id INT NOT NULL, 
    genre_id INT,
    price DECIMAL(8,2), 
    amount INT, 
    FOREIGN KEY (author_id)  REFERENCES author (author_id),
    FOREIGN KEY (genre_id)  REFERENCES genre (genre_id) 
);
```

[Содержание](#содержание)

<hr>

## Действия при удалении записи главной таблицы

С помощью выражения `ON DELETE` можно установить действия, которые выполняются для записей подчиненной таблицы при удалении связанной строки из главной таблицы. При удалении можно установить следующие опции:
+ `CASCADE`: автоматически удаляет строки из зависимой таблицы при удалении  связанных строк в главной таблице.
+ `SET NULL`: при удалении  связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение `NULL`. (В этом случае столбец внешнего ключа должен поддерживать установку `NULL`).
+ `SET DEFAULT` похоже на `SET NULL` за тем исключением, что значение  внешнего ключа устанавливается не в `NULL`, а в значение по умолчанию для данного столбца.
+ `RESTRICT`: отклоняет удаление строк в главной таблице при наличии связанных строк в зависимой таблице.

**Важно!** Если для столбца установлена опция `SET NULL`, то при его описании нельзя задать ограничение на пустое значение.

**Пример**

Будем считать, что при удалении автора из таблицы `author`, необходимо удалить все записи о книгах из таблицы `book`, написанные этим автором. Данное действие необходимо прописать при создании таблицы.

Запрос:

```sql
CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT, 
    title VARCHAR(50), 
    author_id INT NOT NULL, 
    price DECIMAL(8,2), 
    amount INT, 
    FOREIGN KEY (author_id)  REFERENCES author (author_id) ON DELETE CASCADE
);
```

**Задание**

Создать таблицу `book` той же структуры, что и на предыдущем шаге. Будем считать, что при удалении автора из таблицы `author`, должны удаляться все записи о книгах из таблицы `book`, написанные этим автором. А при удалении жанра из таблицы `genre` для соответствующей записи `book` установить значение `Null` в столбце `genre_id`. 

```sql
CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(50),
    author_id INT NOT NULL,
    genre_id INT,
    price DECIMAL(8, 2),
    amount INT,
    FOREIGN KEY (author_id) REFERENCES author (author_id) ON DELETE CASCADE,
    FOREIGN KEY (genre_id) REFERENCES genre (genre_id) ON DELETE SET NULL
);
```

[Содержание](#содержание)

<hr>

## Заполнение таблицы с внешними ключами

На предыдущих шагах были созданы и заполнены таблицы `author`:

author_id | name_author
-|-
1 | Булгаков М.А.
2 | Достоевский Ф.М.
3 | Есенин С.А.
4 | Пастернак Б.Л.

и  `genre`:

genre_id | name_genre
-|-
1 | Роман
2 | Поэзия

Эти таблицы являются главными для таблицы `book` и связаны с ней через внешние ключи:

![02](/SQL_Simulator/img/02_20.jpg)

При заполнении таблицы `book` в связанные столбцы необходимо заносить значения ключей главной таблицы. Например, Книгу «Игрок» написал Достоевский, поэтому значение поля `author_id` для этой записи должно быть  `2`, так как значение ключа для этого автора в таблице `author` равно `2`. Значение поля `genre_id` для книги «Игрок» – `1`, так как эта книга относится к жанру «Роман».

**Задание**

Для каждой строки таблицы `book` занесите значения в поля `author_id` и `genre_id`. Считать, что книга Есенина относится к жанру «Поэзия», остальные книги – к жанру «Роман».

Через запятую перечислены значения полей `book_id`,  `title`, `author_id`, `genre_id`,  `price`, `amount` каждой записи таблицы `book`. Заполните пропуски.

Авторы и их произведения:

Название книги | Автор | Цена | Количество
-|-|-|-
Мастер и Маргарита | Булгаков М.А. | 670.99 | 3
Белая гвардия | Булгаков М.А. | 540.50 | 5
Идиот | Достоевский Ф.М. | 460.00 | 10
Братья Карамазовы | Достоевский Ф.М. | 799.01 | 3
Игрок | Достоевский Ф.М. | 480.50 | 10
Стихотворения и поэмы | Есенин С.А. | 650.00 | 15

```
1, Мастер и Маргарита,      1,  1,  670.99, 3
2, Белая гвардия,           1,  1,  540.50, 5
3, Идиот,                   2,  1,  460.00, 10
4, Братья Карамазовы,       2,  1,  799.01, 3
5, Игрок,                   2,  1,  480.50, 10
6, Стихотворения и поэмы,   3,  2,  650.00, 15
```

[Содержание](#содержание)

<hr>

## Добавьте три последние записи 

(с ключевыми значениями 6, 7, 8) в таблицу book, первые 5 записей уже добавлены:

book_id | title | author_id | genre_id | price | amount
-|-|-|-|-|-
1 | Мастер и Маргарита | 1 | 1 | 670.99 | 3
2 | Белая гвардия | 1 | 1 | 540.50 | 5
3 | Идиот | 2 | 1 | 460.00 | 10
4 | Братья Карамазовы | 2 | 1 | 799.01 | 3
5 | Игрок | 2 | 1 | 480.50 | 10
6 | Стихотворения и поэмы | 3 | 2 | 650.00 | 15
7 | Черный человек | 3 | 2 | 570.20 | 6
8 | Лирика | 4 | 2 | 518.99 | 2

Логическая схема базы данных:

![02](/SQL_Simulator/img/02_20.jpg)

```sql
INSERT INTO
    book(title, author_id, genre_id, price, amount)
VALUES
    ('Стихотворения и поэмы', 3, 2, 650.00, 15),
    ('Черный человек', 3, 2, 570.20, 6),
    ('Лирика', 4, 2, 518.99, 2);
```

**Результат**

Affected rows: 3
Query result:
```
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 5      |
| 3       | Идиот                 | 2         | 1        | 460.00 | 10     |
| 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
| 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
| 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
| 7       | Черный человек        | 3         | 2        | 570.20 | 6      |
| 8       | Лирика                | 4         | 2        | 518.99 | 2      |
+---------+-----------------------+-----------+----------+--------+--------+
```

[Содержание](#содержание)

<hr>

# 2.2 Запросы на выборку, соединение таблиц

**Содержание урока**

В запросах SQL могут участвовать несколько таблиц базы данных. При этом необходимо указать как эти таблицы соединены между собой. 

Операция соединения `JOIN` предназначена для обеспечения выборки данных из двух таблиц и включения этих данных в один результирующий набор. При необходимости соединения не двух, а нескольких таблиц, операция соединения применяется несколько раз (последовательно).

Операторы соединения входят в раздел `FROM` SQL запросов.

В данном уроке будут созданы запросы:
+ для двух таблиц, внутреннее соединение INNER JOIN;
+ для двух таблиц, внешние соединения LEFT JOIN и RIGHT JOIN;
+ для двух таблиц, перекрестное соединение CROSS JOIN;
+ выборки данных из нескольких таблиц;
+ выборки данных из нескольких таблиц с группировкой;
+ выборки данных с применением вложенных запросов;
+ вложенные запросы в операторах соединения,
+ операторы соединения, использование USING.

**Структура и наполнение таблиц**

Концептуальная схема базы данных:

![02](/SQL_Simulator/img/02_21.jpg)

Логическая схема базы данных:

![02](/SQL_Simulator/img/02_19.jpg)

Таблица `author`:

author_id | name_author
-|-
1 | Булгаков М.А.
2 | Достоевский Ф.М.
3 | Есенин С.А.
4 | Пастернак Б.Л.
5 | Лермонтов М.Ю.

Таблица `genre`:

genre_id | name_genre
-|-
1 | Роман
2 | Поэзия
3 | Приключения

Таблица `book`:

book_id | title | author_id | genre_id | price | amount
-|-|-|-|-|-
1 | Мастер и Маргарита | 1 | 1 | 670.99 | 3
2 | Белая гвардия | 1 | 1 | 540.50 | 5
3 | Идиот | 2 | 1 | 460.00 | 10
4 | Братья Карамазовы | 2 | 1 | 799.01 | 3
5 | Игрок | 2 | 1 | 480.50 | 10
6 | Стихотворения и поэмы | 3 | 2 | 650.00 | 15
7 | Черный человек | 3 | 2 | 570.20 | 6
8 | Лирика | 4 | 2 | 518.99 | 2

[Содержание](#содержание)

<hr>

## Соединение INNER JOIN

Оператор внутреннего соединения `INNER JOIN` соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным.

```sql
SELECT
 ...
FROM
    таблица_1 INNER JOIN  таблица_2
    ON условие
...
```

Результат запроса формируется так:
+ каждая строка одной таблицы сопоставляется с каждой строкой второй таблицы;
+ для полученной «соединённой» строки проверяется условие соединения;
+ если условие истинно, в таблицу результата добавляется соответствующая «соединённая» строка;

**Пример**

Вывести название книг и их авторов.

Запрос:

```sql
SELECT title, name_author
FROM 
    author INNER JOIN book
    ON author.author_id = book.author_id;
```

Поскольку поля `author_id` в таблицах `book` и `author` называются одинаково, необходимо в запросах указывать полную ссылку на них (`book.author_id` и `author.author_id`).


**Результат:**

```
+-----------------------+------------------+
| title                 | name_author      |
+-----------------------+------------------+
| Мастер и Маргарита    | Булгаков М.А.    |
| Белая гвардия         | Булгаков М.А.    |
| Идиот                 | Достоевский Ф.М. |
| Братья Карамазовы     | Достоевский Ф.М. |
| Игрок                 | Достоевский Ф.М. |
| Стихотворения и поэмы | Есенин С.А.      |
| Черный человек        | Есенин С.А.      |
| Лирика                | Пастернак Б.Л.   |
+-----------------------+------------------+
```

В данном запросе осуществляется соединение главной таблицы `author` и зависимой таблицы `book` по ключевому столбцу `author.author_id` и внешнему ключу `book.author_id`. При этом в результирующую таблицу запроса включаются все строки, в которых значения этих столбцов совпадают. Другими словами строки зависимой таблицы `book` дополняются фамилией и инициалами авторов из таблицы `author`.

**Задание**

Вывести название, жанр и цену тех книг, количество которых больше 8, в отсортированном по убыванию цены виде.

Логическая схема базы данных:

![02](/SQL_Simulator/img/02_19.jpg)

```sql
SELECT
    title,
    name_genre,
    price
FROM
    genre
    INNER JOIN book ON genre.genre_id = book.genre_id
WHERE
    amount > 8
ORDER BY
    price DESC;
```

**Результат**

```
+-----------------------+------------+--------+
| title                 | name_genre | price  |
+-----------------------+------------+--------+
| Стихотворения и поэмы | Поэзия     | 650.00 |
| Игрок                 | Роман      | 480.50 |
| Идиот                 | Роман      | 460.00 |
+-----------------------+------------+--------+
```

[Содержание](#содержание)

<hr>

## Внешнее соединение LEFT и RIGHT OUTER JOIN

Оператор внешнего соединения `LEFT OUTER JOIN`  (можно использовать `LEFT JOIN`) соединяет две таблицы. Порядок таблиц для оператора важен, поскольку оператор не является симметричным.

```sql
SELECT
 ...
FROM
    таблица_1 LEFT JOIN  таблица_2
    ON условие
...
```

Результат запроса формируется так:
+ в результат включается внутреннее соединение (`INNER JOIN`) первой и второй таблицы в соответствии с условием;
+ затем в результат добавляются те записи первой таблицы, которые не вошли во внутреннее соединение на шаге `1`, для таких записей соответствующие поля второй таблицы заполняются значениями `NULL`.

Соединение `RIGHT JOIN` действует аналогично, только в пункте `2` первая таблица меняется на вторую и наоборот.

**Пример**

Вывести название всех книг каждого автора, если книг некоторых авторов в данный момент нет на складе – вместо названия книги указать `Null`.

Запрос:

```sql
SELECT name_author, title 
FROM author LEFT JOIN book
     ON author.author_id = book.author_id
ORDER BY name_author;     
```

Результат:

```
+------------------+-----------------------+
| name_author      | title                 |
+------------------+-----------------------+
| Булгаков М.А.    | Мастер и Маргарита    |
| Булгаков М.А.    | Белая гвардия         |
| Достоевский Ф.М. | Игрок                 |
| Достоевский Ф.М. | Идиот                 |
| Достоевский Ф.М. | Братья Карамазовы     |
| Есенин С.А.      | Стихотворения и поэмы |
| Есенин С.А.      | Черный человек        |
| Лермонтов М.Ю.   | NULL                  |
| Пастернак Б.Л.   | Лирика                |
+------------------+-----------------------+
```

Так как в таблице `book` нет книг Лермонтова, напротив этой фамилии стоит `Null`.

**Задание**

Вывести все жанры, которые не представлены в книгах на складе.

Логическая схема базы данных:

![02](/SQL_Simulator/img/02_19.jpg)

**Пояснение**

1. При использовании внешнего соединения названия книг и другие столбцы таблицы `book` для жанра тех книг, которого нет на складе, будут содержать значение `Null`.
2. Для сравнения с пустым значением используется запись `IS Null` (написать `=` `Null` нельзя).

```sql
SELECT
    name_genre
FROM
    genre
    LEFT JOIN book ON genre.genre_id = book.genre_id
WHERE
    amount IS NULL;
```

**Результат**

```
+-------------+
| name_genre  |
+-------------+
| Приключения |
+-------------+
```

[Содержание](#содержание)

<hr>

## Перекрестное соединение CROSS JOIN

Оператор перекрёстного соединения, или декартова произведения `CROSS JOIN` (в запросе вместо ключевых слов можно поставить запятую между таблицами) соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным. Его структура:

```sql
SELECT
 ...
FROM
    таблица_1 CROSS JOIN  таблица_2
...
```

или

```sql
SELECT
 ...
FROM
    таблица_1, таблица_2
...
```

Результат запроса формируется так: каждая строка одной таблицы соединяется с каждой строкой другой таблицы, формируя  в результате все возможные сочетания строк двух таблиц.

Например, запрос:

```sql
SELECT name_author, name_genre
FROM 
    author, genre;
```

каждому автору из таблицы `author` поставит в соответствие все возможные жанры из таблицы `genre`:

```
+------------------+-------------+
| name_author      | name_genre  |
+------------------+-------------+
| Булгаков М.А.    | Роман       |
| Булгаков М.А.    | Поэзия      |
| Булгаков М.А.    | Приключения |
| Достоевский Ф.М. | Роман       |
| Достоевский Ф.М. | Поэзия      |
| Достоевский Ф.М. | Приключения |
| Есенин С.А.      | Роман       |
| Есенин С.А.      | Поэзия      |
| Есенин С.А.      | Приключения |
| Пастернак Б.Л.   | Роман       |
| Пастернак Б.Л.   | Поэзия      |
| Пастернак Б.Л.   | Приключения |
| Лермонтов М.Ю.   | Роман       |
| Лермонтов М.Ю.   | Поэзия      |
| Лермонтов М.Ю.   | Приключения |
+------------------+-------------+
```

**Задание**

Есть список городов, хранящийся в таблице `city`:

city_id | name_city
-|-
1 | Москва
2 | Санкт-Петербург
3 | Владивосток

Необходимо в каждом городе провести выставку книг каждого автора в течение 2020 года. Дату проведения выставки выбрать случайным образом. Создать запрос, который выведет город, автора и дату проведения выставки. Последний столбец назвать Дата. Информацию вывести, отсортировав сначала в алфавитном порядке по названиям городов, а потом по убыванию дат проведения выставок.

Структура таблицы:

![02](/SQL_Simulator/img/02_22.jpg)

**Пояснение**

1. Для генерации случайной даты можно к первому числу года ('2020-01-01') прибавить целое случайное число в интервале от 0 до 365.

Генерации случайных чисел в интервале от 0 до 1 (не включительно) осуществляется с помощью функции `RAND()`. Если эту функцию умножить на `365`, то она будет генерировать вещественные числа от `0` до `365` (не включительно). Осталось только отбросить дробную часть. Это можно сделать с помощью функции `FLOOR()`, которая возвращает наибольшее целое число, меньшее или равное указанному числовому значению. Таким образом, случайное число от `0` до `365` можно получить с помощью выражения:

`FLOOR(RAND() * 365)`

**Важно!** Даты должны быть за 2020 год, первое число года - 1 января 2020 года.

2. Для сложения  даты с числом используется функция:

```
DATE_ADD(дата, INTERVAL число единица_измерения),
```
где
  + **единица_измерения** (использовать прописные буквы) – это день (DAY), месяц(MONTH), неделя(WEEK) и пр., 
  + **число** – целое число,
  + **дата** – значение даты или даты и времени.

Функция к дате  прибавляет указанное число, выраженное в днях, месяцах и пр. , в зависимости от заданного интервала, и возвращает новую дату.

Например:

`DATE_ADD('2020-02-02', INTERVAL 45 DAY)` возвращает 18 марта 2020 года
`DATE_ADD('2020-02-02', INTERVAL 6 MONTH)` возвращает 2 августа 2020 года

```sql
SELECT
    name_city,
    name_author,
    (
        DATE_ADD('2020-01-01', INTERVAL FLOOR(RAND() * 365) DAY)
    ) as Дата
FROM
    author,
    city
ORDER BY
    name_city ASC,
    Дата DESC;
```

**Результат**

Примечание: даты при каждом запуске получаются разными, и не должны совпадать с приведенными значениями.

```
Query result:
+-----------------+------------------+------------+
| name_city       | name_author      | Дата       |
+-----------------+------------------+------------+
| Владивосток     | Есенин С.А.      | 2020-12-27 |
| Владивосток     | Достоевский Ф.М. | 2020-10-07 |
| Владивосток     | Булгаков М.А.    | 2020-07-15 |
| Владивосток     | Пастернак Б.Л.   | 2020-07-11 |
| Владивосток     | Лермонтов М.Ю.   | 2020-05-20 |
| Москва          | Булгаков М.А.    | 2020-12-09 |
| Москва          | Достоевский Ф.М. | 2020-10-23 |
| Москва          | Есенин С.А.      | 2020-08-12 |
| Москва          | Пастернак Б.Л.   | 2020-05-07 |
| Москва          | Лермонтов М.Ю.   | 2020-03-27 |
| Санкт-Петербург | Лермонтов М.Ю.   | 2020-11-16 |
| Санкт-Петербург | Пастернак Б.Л.   | 2020-10-13 |
| Санкт-Петербург | Есенин С.А.      | 2020-07-08 |
| Санкт-Петербург | Булгаков М.А.    | 2020-04-23 |
| Санкт-Петербург | Достоевский Ф.М. | 2020-01-09 |
+-----------------+------------------+------------+
Affected rows: 15
```

[Содержание](#содержание)

<hr>

## Запросы на выборку из нескольких таблиц

Запрос на выборку может выбирать данные из двух и более таблиц базы данных. При этом таблицы должны быть логически связаны между собой. Для каждой пары таблиц, включаемых в запрос, необходимо указать свой оператор соединения. Наиболее распространенным является внутреннее соединение `INNER JOIN`, поэтому в примерах будем использовать его.

Пусть таблицы связаны между собой следующим образом:

![02](/SQL_Simulator/img/02_23.jpg)

тогда запрос на выборку для этих таблиц будет иметь вид:

```sql
SELECT
 ...
FROM
    first 
    INNER JOIN  second ON first.first_id = second.first_id
    INNER JOIN  third  ON second.second_id = third.second_id
...
```

Если же таблицы связаны так:

![02](/SQL_Simulator/img/02_24.jpg)

то запрос на выборку выглядит следующим образом:

```sql
SELECT
 ...
FROM
    first 
    INNER JOIN  third ON first.first_id = third.first_id
    INNER JOIN second ON third.second_id = second.second_id 
...
```

В этом случае рекомендуется соединение таблиц записывать последовательно, «по кругу»: `first → third → second`.

**Пример**

Вывести информацию о тех книгах, их авторах и жанрах, цена которых принадлежит интервалу от 500  до 700 рублей  включительно.

Запрос:

```sql
SELECT title, name_author, name_genre, price, amount
FROM
    author 
    INNER JOIN  book ON author.author_id = book.author_id
    INNER JOIN genre ON genre.genre_id = book.genre_id
WHERE price BETWEEN 500 AND 700;
```

Результат:

```
+-----------------------+----------------+------------+--------+--------+
| title                 | name_author    | name_genre | price  | amount |
+-----------------------+----------------+------------+--------+--------+
| Мастер и Маргарита    | Булгаков М.А.  | Роман      | 670.99 | 3      |
| Белая гвардия         | Булгаков М.А.  | Роман      | 540.50 | 5      |
| Стихотворения и поэмы | Есенин С.А.    | Поэзия     | 650.00 | 15     |
| Черный человек        | Есенин С.А.    | Поэзия     | 570.20 | 6      |
| Лирика                | Пастернак Б.Л. | Поэзия     | 518.99 | 2      |
+-----------------------+----------------+------------+--------+--------+
```

**Задание**

Вывести информацию о книгах (жанр, книга, автор), относящихся к жанру, включающему слово «роман» в отсортированном по названиям книг виде.

Логическая схема базы данных:

![02](/SQL_Simulator/img/02_19.jpg)

```sql
SELECT
    name_genre,
    title,
    name_author
FROM
    author
    INNER JOIN book ON author.author_id = book.author_id
    INNER JOIN genre ON genre.genre_id = book.genre_id
WHERE
    name_genre = 'Роман'
ORDER BY
    title;
```

**Результат**

```
+------------+--------------------+------------------+
| name_genre | title              | name_author      |
+------------+--------------------+------------------+
| Роман      | Белая гвардия      | Булгаков М.А.    |
| Роман      | Братья Карамазовы  | Достоевский Ф.М. |
| Роман      | Игрок              | Достоевский Ф.М. |
| Роман      | Идиот              | Достоевский Ф.М. |
| Роман      | Мастер и Маргарита | Булгаков М.А.    |
+------------+--------------------+------------------+
```

[Содержание](#содержание)

<hr>

## Запросы для нескольких таблиц с группировкой

В запросах с групповыми функциями могут использоваться несколько таблиц, между которыми используются различные типы соединений.

**Пример**

Вывести количество различных книг каждого автора. Информацию отсортировать в алфавитном порядке по фамилиям  авторов.

Запрос:

```sql
SELECT name_author, count(title) AS Количество
FROM 
    author INNER JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
ORDER BY name_author;    
```

Результат

```
+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Булгаков М.А.    | 2          |
| Достоевский Ф.М. | 3          |
| Есенин С.А.      | 2          |
| Пастернак Б.Л.   | 1          |
+------------------+------------+
```

При использовании соединения `INNER JOIN` мы не можем узнать, что книг Лермонтова на складе нет, но предполагается, что они могут быть.  Чтобы автор Лермонтов был включен в результат, нужно изменить соединение таблиц.

Запрос:

```sql
SELECT name_author, count(title) AS Количество
FROM 
    author LEFT JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
ORDER BY name_author;   
```

Результат:

```
+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Булгаков М.А.    | 2          |
| Достоевский Ф.М. | 3          |
| Есенин С.А.      | 2          |
| Лермонтов М.Ю.   | 0          |
| Пастернак Б.Л.   | 1          |
+------------------+------------+
```

**Задание**

Посчитать количество экземпляров  книг каждого автора из таблицы `author`.  Вывести тех авторов,  количество книг которых меньше `10`, в отсортированном по возрастанию количества виде. Последний столбец назвать Количество.

Логическая схема базы данных:

![02](/SQL_Simulator/img/02_19.jpg)

**Пояснение**

Чтобы в результат были включены авторы, книг которых на складе нет, необходимо в условии отбора, кроме того, что общее количество книг каждого автора меньше 10, учесть, что у автора вообще может не быть книг (то есть `COUNT(title) = 0`).

```sql
SELECT
    name_author,
    SUM(amount) AS Количество
FROM
    author
    LEFT JOIN book on author.author_id = book.author_id
GROUP BY
    name_author
HAVING
    SUM(amount) < 10
    OR Количество is NULL
ORDER BY
    Количество;
```

**Результат**

```
+----------------+------------+
| name_author    | Количество |
+----------------+------------+
| Лермонтов М.Ю. | NULL       |
| Пастернак Б.Л. | 2          |
| Булгаков М.А.  | 8          |
+----------------+------------+
```

[Содержание](#содержание)

<hr>

## Запросы для нескольких таблиц со вложенными запросами

В запросах, построенных на нескольких таблицах, можно использовать вложенные запросы. Вложенный запрос может быть включен:  после ключевого слова `SELECT`,  после `FROM` и в условие отбора после `WHERE` (`HAVING`).

**Пример**

Вывести авторов, общее количество книг которых на складе максимально.

Это достаточно сложный запрос, поэтому будем решать его по шагам (реализуя каждый запрос по отдельности), а потом объединим все запросы в один.

**Шаг 1.** Найдем суммарное количество книг на складе по каждому автору. Поскольку фамилии автора в этой таблице нет, то группировку будем осуществлять по `author_id`.

Запрос:

```sql
SELECT author_id, SUM(amount) AS sum_amount FROM book GROUP BY author_id
```

Результат:

```
+-----------+------------+
| author_id | sum_amount |
+-----------+------------+
| 1         | 8          |
| 2         | 23         |
| 3         | 21         |
| 4         | 2          |
+-----------+------------+
```

**Шаг 2.** В результирующей таблице предыдущего запроса необходимо найти максимальное значение, то есть `23`. Для этого запросу, созданному на шаге `1`, необходимо присвоить имя (например, `query_in`) и использовать его в качестве таблицы-источника после `FROM`. Затем уже находить максимум по столбцу `sum_amount`.

Запрос:  

```sql
SELECT MAX(sum_amount) AS max_sum_amount
FROM 
    (
     SELECT author_id, SUM(amount) AS sum_amount 
     FROM book 
     GROUP BY author_id
    ) query_in
```

Результат:

```
+----------------+
| max_sum_amount |
+----------------+
| 23             |
+----------------+
```

***Шаг 3.*** Выведем фамилию автора и общее количество книг для него.

Запрос:  

```sql
SELECT name_author, SUM(amount) as Количество
FROM 
    author INNER JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
```

Результат:

```
+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Булгаков М.А.    | 8          |
| Достоевский Ф.М. | 23         |
| Есенин С.А.      | 21         |
| Пастернак Б.Л.   | 2          |
+------------------+------------+
```

`Шаг 4.`  Включим запрос с шага `2` в условие отбора запроса с шага `3`. И получим всех авторов, общее количество книг которых максимально.

Запрос:  

```sql
SELECT name_author, SUM(amount) as Количество
FROM 
    author INNER JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
HAVING SUM(amount) = 
     (/* вычисляем максимальное из общего количества книг каждого автора */
      SELECT MAX(sum_amount) AS max_sum_amount
      FROM 
          (/* считаем количество книг каждого автора */
            SELECT author_id, SUM(amount) AS sum_amount 
            FROM book GROUP BY author_id
          ) query_in
      );
```

Результат:

```
+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Достоевский Ф.М. | 23         |
+------------------+------------+
```

**Задание**

Вывести в алфавитном порядке всех авторов, которые пишут только в одном жанре. Поскольку у нас в таблицах так занесены данные, что у каждого автора книги только в одном жанре,  для этого запроса внесем изменения в таблицу `book`. Пусть у нас  книга Есенина «Черный человек» относится к жанру «Роман», а книга Булгакова «Белая гвардия» к «Приключениям» (эти изменения в таблицы уже внесены).

Логическая схема базы данных:

![02](/SQL_Simulator/img/02_19.jpg)

```sql
SELECT
    name_author
FROM
    author
    INNER JOIN book on author.author_id = book.author_id
GROUP BY
    name_author
HAVING
    COUNT(DISTINCT genre_id) = 1;
```

**Результат**

```
+------------------+
| name_author      |
+------------------+
| Достоевский Ф.М. |
| Пастернак Б.Л.   |
+------------------+
```

[Содержание](#содержание)

<hr>

## Вложенные запросы в операторах соединения

Вложенные запросы могут использоваться в операторах соединения `JOIN`.  При этом им необходимо присваивать имя, которое записывается сразу после закрывающей скобки вложенного запроса.

```sql
SELECT
 ...
FROM
    таблица ... JOIN  
       (
        SELECT ...
       ) имя_вложенного_запроса
    ON условие
...
```

Вложенный запрос может стоять как справа, так и слева от оператора `JOIN`. Допускается использование двух запросов в операторах соединения.

**Пример**

Вывести авторов, пишущих книги в самом популярном жанре. Указать этот жанр.

Самым популярным считать жанр, общее количество экземпляров книг которого на складе максимально. Таких жанров может быть несколько, если они имеют одинаковое максимальное значение общего количества экземпляров. Только для этого шага изменена запись в таблице `book`.

book_id | title | author_id | genre_id | price | amount
-|-|-|-|-|-
8 | Лирика | 4 | 2 | 518.9910 | 10

А также добавлены новые записи:

book_id | title | author_id | genre_id | price | amount
-|-|-|-|-|-
9 | Герой нашего времени | 5 | 3 | 570.59 | 2
10 | Доктор Живаго | 4 | 3 | 740.50 | 5

Рассмотрим реализацию этого запроса по шагам.

**Шаг 1.** Найдем общее количество книг по каждому жанру, отсортируем его по убыванию и ограничим вывод одной строкой. Рекомендуется, если запрос будет использоваться в качестве вложенного (особенно в операциях соединения), вычисляемым полям запроса давать собственное имя.

Запрос:

```sql
SELECT genre_id, SUM(amount) AS sum_amount
FROM book
GROUP BY genre_id
ORDER BY sum_amount DESC
LIMIT 1
```

Результат:

```
+---------------+------------+
|  genre_id     | sum_amount |
+---------------+------------+
| 1             | 31         |
+---------------+------------+
```

Кажется, что, уже используя этот запрос, можно получить `id` самого популярного жанра. Но это не так, поскольку несколько жанров могут иметь одинаковую популярность. Поэтому нам необходим запрос, который отберет ВСЕ жанры, суммарное количество книг которых равно `sum_amount`.

**Шаг 2.** Используя запрос с предыдущего шага, найдем `id` самых популярных жанров.

Запрос:

```sql
SELECT query_in_1.genre_id
FROM 
    (/* выбираем код жанра и количество произведений, относящихся к нему */
      SELECT genre_id, SUM(amount) AS sum_amount
      FROM book
      GROUP BY genre_id 
    )query_in_1
    INNER JOIN
    (/* выбираем запись, в которой указан код жанр с максимальным количеством книг */
      SELECT genre_id, SUM(amount) AS sum_amount
      FROM book
      GROUP BY genre_id
      ORDER BY sum_amount DESC
      LIMIT 1
     ) query_in_2
     ON query_in_1.sum_amount= query_in_2.sum_amount              
```

Результат:

```
+----------+
| genre_id |
+----------+
| 1        |
| 2        |
+----------+
```

`Шаг 3.` Используя запрос с шага 2, выведем фамилии авторов, которые пишут в самых популярных жанрах, и названия этих жанров. В этом запросе обязательно выполнить группировку по фамилиям авторов и `id` жанров, так как без этого фамилии авторов будут повторяться, поскольку в таблице book есть разные книги, написанные автором в одном жанре.

Запрос:

```sql
SELECT  name_author, name_genre
FROM 
    author 
    INNER JOIN book ON author.author_id = book.author_id
    INNER JOIN genre ON  book.genre_id = genre.genre_id
GROUP BY name_author,name_genre, genre.genre_id
HAVING genre.genre_id IN
         (/* выбираем автора, если он пишет книги в самых популярных жанрах*/
          SELECT query_in_1.genre_id
          FROM 
              ( /* выбираем код жанра и количество произведений, относящихся к нему */
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
               )query_in_1
          INNER JOIN 
              ( /* выбираем запись, в которой указан код жанр с максимальным количеством книг */
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
                ORDER BY sum_amount DESC
                LIMIT 1
               ) query_in_2
          ON query_in_1.sum_amount= query_in_2.sum_amount
         );   
```

**Важно!**

Обратите внимание, что в группировку включен столбец `genre_id`, который используется в `HAVING`. Это связано с тем, что в `HAVING` можно использовать либо столбцы, перечисленные в `GROUP BY`, либо вычисляемые с помощью групповых функций столбцы. Добавление столбца `genre_id` не влияет на группировку, так как между названием жанра и его `id` - взаимно-однозначное соответствие.

Название столбца `genre_id` задается с указанием имени таблицы (`genre.genre_id`), так как этот столбец входит в структуру двух таблиц `book` и `genre`.  Для этого запроса можно было бы указать и `book.genre_id`, так как эти таблицы связаны внутренним соединением `INNER JOIN` и имеют одинаковые значения в полях `genre.genre_id` и `book.genre_id`.

Результат:

```
+------------------+------------+
| name_author      | name_genre |
+------------------+------------+
| Достоевский Ф.М. | Роман      |
| Булгаков М.А.    | Роман      |
| Пастернак Б.Л.   | Поэзия     |
| Есенин С.А.      | Поэзия     |
+------------------+------------+
```

**Задание**

Вывести информацию о книгах (название книги, фамилию и инициалы автора, название жанра, цену и количество экземпляров книги), написанных в самых популярных жанрах, в отсортированном в алфавитном порядке по названию книг виде. Самым популярным считать жанр, общее количество экземпляров книг которого на складе максимально.

Логическая схема базы данных:

![02](/SQL_Simulator/img/02_19.jpg)

```sql
SELECT
    title,
    name_author,
    name_genre,
    price,
    amount
FROM
    author
    INNER JOIN book ON author.author_id = book.author_id
    INNER JOIN genre ON book.genre_id = genre.genre_id
WHERE
    genre.genre_id IN (
        /* выбираем автора, если он пишет книги в самых популярных жанрах*/
        SELECT
            query_in_1.genre_id
        FROM
            (
                /* выбираем код жанра и количество произведений, относящихся к нему */
                SELECT
                    genre_id,
                    SUM(amount) AS sum_amount
                FROM
                    book
                GROUP BY
                    genre_id
            ) query_in_1
            INNER JOIN (
                /* выбираем запись, в которой указан код жанр с максимальным количеством книг */
                SELECT
                    genre_id,
                    SUM(amount) AS sum_amount
                FROM
                    book
                GROUP BY
                    genre_id
                ORDER BY
                    sum_amount DESC
                LIMIT
                    1
            ) query_in_2 ON query_in_1.sum_amount = query_in_2.sum_amount
    )
ORDER BY
    title;
```

[Содержание](#содержание)

<hr>

## Операция соединение, использование USING()

При описании соединения таблиц с помощью `JOIN` в некоторых случаях вместо `ON` и следующего за ним условия можно использовать оператор `USING()`.

`USING` позволяет указать набор столбцов, которые есть в обеих объединяемых таблицах. Если база данных хорошо спроектирована, а каждый внешний ключ имеет такое же имя, как и соответствующий первичный ключ (например, `genre.genre_id` = `book.genre_id`), тогда можно использовать предложение `USING` для реализации операции `JOIN`. 

При этом после `SELECT`, при использовании столбцов из `USING()`, необязательно указывать, из какой именно таблицы берется столбец.

**Пример**

Вывести название книг, фамилии и `id` их авторов.

Запрос:

Вариант с `ON`

```sql
SELECT title, name_author, author.author_id /* явно указать таблицу - обязательно */
FROM 
    author INNER JOIN book
    ON author.author_id = book.author_id;
```
Вариант с USING

```sql
SELECT title, name_author, author_id /* имя таблицы, из которой берется author_id, указывать не обязательно*/
FROM 
    author INNER JOIN book
    USING(author_id);
Результат (одинаковый для обоих запросов):
```

```
+-----------------------+------------------+-----------+
| title                 | name_author      | author_id |
+-----------------------+------------------+-----------+
| Мастер и Маргарита    | Булгаков М.А.    | 1         |
| Белая гвардия         | Булгаков М.А.    | 1         |
| Идиот                 | Достоевский Ф.М. | 2         |
| Братья Карамазовы     | Достоевский Ф.М. | 2         |
| Игрок                 | Достоевский Ф.М. | 2         |
| Стихотворения и поэмы | Есенин С.А.      | 3         |
| Черный человек        | Есенин С.А.      | 3         |
| Лирика                | Пастернак Б.Л.   | 4         |
+-----------------------+------------------+-----------+
```

Запись условия соединения с `ON` является более общим случаем, так как
+ позволяет задавать соединение не только по одноименным полям;
+ позволяет использовать произвольное условие на соединение таблиц, при этом в условие может включаться произвольное выражение, например, можно указать связь двух таблиц по двум и более столбцам.

Пример

В таблице `supply` занесена информация о книгах, поступивших на склад.

supply_id | title | author | price | amount
-|-|-|-|-
1 | Доктор Живаго | Пастернак Б.Л. | 618.99 | 3
2 | Черный человек  | Есенин С.А. | 570.20 | 6
3 | Евгений Онегин | Пушкин А.С. | 440.80 | 5
4 | Идиот | Достоевский Ф.М. | 360.80 | 3

Если в таблицах `supply`  и `book` есть одинаковые книги,  вывести их название и автора. При этом учесть, что у нескольких авторов могут быть книги с одинаковым названием.

Важно. В данном примере для соединения `book` и `supply` использовать `USING` нельзя, так как: 
+ в таблице book фамилий авторов вообще нет (их необходимо получить из таблицы author, столбец name_author),  а в таблице supply фамилии занесены в столбец author;
+ для однозначной идентификации книги нужно указать, что совпадают не только названия, но и авторы книг.

Запрос:
```sql
SELECT book.title, name_author
FROM 
    author 
    INNER JOIN book USING (author_id)   
    INNER JOIN supply ON book.title = supply.title 
                         and author.name_author = supply.author;
```

Результат:

```
+----------------+------------------+
| title          | name_author      |
+----------------+------------------+
| Идиот          | Достоевский Ф.М. |
| Черный человек | Есенин С.А.      |
+----------------+------------------+
```

Задание

Если в таблицах supply  и book есть одинаковые книги, которые имеют равную цену,  вывести их название и автора, а также посчитать общее количество экземпляров книг в таблицах supply и book,  столбцы назвать Название, Автор  и Количество.

Схема данных:

[Содержание](#содержание)

<hr>

# 2.3 Запросы корректировки, соединение таблиц

[Содержание](#содержание)

<hr>

# 2.4 База данных «Интернет-магазин книг», запросы на выборку

[Содержание](#содержание)

<hr>

# 2.5 База данных «Интернет-магазин книг», запросы корректировки

[Содержание](#содержание)

<hr>

