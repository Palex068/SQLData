# SQL – оконные функции

# Содержание

[Содержание курса](/GB_SQL/README.md)

# Терминология

***Оконная функция в SQL -** функция, которая работает с выделенным набором строк (окном, партицией) и выполняет вычисление для этого набора строк в отдельном столбце.*

***Партиции (окна из набора строк) -** это набор строк, указанный для оконной функции по одному из столбцов или группе столбцов таблицы. Партиции для каждой оконной функции в запросе могут быть разделены по различным колонкам таблицы.*

***Агрегатные функции (агрегации) —** это функции, которые вычисляются от группы значений и объединяют их в одно результирующее.*

***Функции смещения** – это функции, которые позволяют перемещаться и обращаться к разным строкам в окне, относительно текущей строки, а также обращаться к значениям в начале или в конце окна.*

***Аналитические функции** — это функции которые возвращают информацию о распределении данных и используются для статистического анализа.*

***Предикат в SQL это:***

 *****в широком смысле, — любое выражение, результатом которого являются значения булевого типа — TRUE, FALSE, а так же UNKNOWN*

*в узком смысле, — некий уточняющий фильтр. Самым явным примером предиката служит оператор WHERE*

<hr>

[Содержание](#содержание)

Доброго времени суток, уважаемые студенты!

На сегодняшней лекции особое внимание хотелось бы уделить мощному инструменту аналитика - оконным функциям. “Окошки” помогают делать различные аналитические отчеты без участия стороннего ПО (”экселя”). 

Давайте попробуем рассмотреть основную массу задач, которые могут решать оконные функции, затем - разберемся, как же воплотить наши ожидания с помощью кода:

- Ранжирование. Составление всевозможных рейтингов: топ-100 популярных треков на какой-то радиостанции
- Просмотр разницы между близкими элементами (2 и 3 человек в топ-5 самых богатых людей мира)
- “Скользящие” агрегаты
- Агрегация (топ самых высоких зарплат)

<hr>

[Содержание](#содержание)

# **Классы оконных функций**

Множество оконных функций можно поделить на 3 группы:

- Агрегирующие (Aggregate)
- Ранжирующие (Ranking)
- Функции смещения (Value)
- Аналитические функции.

**Составление рейтинга по ЗП**

```sql
-- Создание таблицы
CREATE TABLE IF NOT EXISTS staff 
(
    id INT PRIMARY KEY,
    first_name VARCHAR(30),
    post VARCHAR(30),
    discipline VARCHAR(30),
    salary INT
);

-- Заполнение таблицы данными
INSERT staff (id, first_name, post, discipline, salary)
VALUES
	(100,'Антон', 'Преподаватель', 'Программирование', 50),
	(101,'Василий', 'Преподаватель', 'Программирование', 60),
	(103,'Александр', 'Ассистент', 'Программирование', 25),
	(104,'Владимир', 'Профессор', 'Математика', 120),
	(105,'Иван', 'Профессор', 'Математика', 120),
	(106,'Михаил', 'Доцент', 'Физика', 70),
	(107, 'Анна', 'Доцент', 'Физика', 70),
	(108, 'Вероника', 'Доцент', 'ИКТ', 30),
	(109,'Григорий', 'Преподаватель', 'ИКТ', 25),
	(110,'Георгий', 'Ассистент', 'Программирование', 30);
```

![05](/GB_SQL/img/05_01.png)

Как мы видим, одинаковый ранг будет у сотрудников с одинаковой ЗП (допусти, Владимир и Иван в правой таблице, Иван и Михаил, Вероника и Георгий).

![05](/GB_SQL/img/05_02.png)

Давайте попробуем пройтись по всем строчкам  Начнем с 1 и будем проставлять ранг. Для простановки ранга необходимо учитывать только значение конкретного столбца - `salary`. В контексте оконной функции - окно. При обычном запросе все множество строк обрабатывается единым потоком, для которого считаются агрегаты. При работе с оконными функциями наш запрос делится на небольшие части  (окна) и уже для каждой из отдельных частей считаются свои агрегаты.

![05](/GB_SQL/img/05_03.png)

Пример для абстрактной таблицы:

![05](/GB_SQL/img/05_04.png)

Наше окно  - содержимое столбца salary, которое мы отсортировали по убыванию.

**Как же записать это в контексте SQL?**

Для открытия окна используется обязательная инструкция `OVER`:

```sql
SELECT Название_функции (столбец для вычислений) 
OVER 
(
      PARTITION BY столбец для группировки
      ORDER BY столбец для сортировки
      ROWS или RANGE выражение для ограничения строк в пределах группы
)
```

Нашему окну можно так же присвоить имя, которое можно будет использовать в запросе.  Наше окно должно проставлять ранг по убыванию столбца `salary`:

```sql
WINDOW w AS (ORDER BY salary desc)
```

+ `window` — определение окна;
+ `w` — название окна, указываем через пробел, как и псевдоним без AS;
+ ORDER BY salary DESC — сортировка столбца `salary`.

Внутри конкретного окна нужно посчитать ранг (ранг по окну w).

Пусть имеется таблица:

![05](/GB_SQL/img/05_05.png)

Начнем с примера: откроем окно `over` и найдем сумму и количество покупок:

```sql
SELECT shopping_day, department, count,
	SUM(count) OVER() AS 'Sum',
	COUNT(count) OVER() AS 'Count' 
FROM shop;
```

![05](/GB_SQL/img/05_06.png)

В нашем примере сумма, равная 29 - это общее количество покупок(суммирование всего столбца `count` и подсчет общего количества строк). Если бы мы использовали агрегатную функцию в чистом виде, то получим сужение выборки до 1 сточки. 

**В оконной функции исходное количество строк не уменьшается по сравнению с исходной таблицей. При использовании агрегирующих функций предложение GROUP BY сокращает количество строк в запросе с помощью их группировки.**

```sql
SELECT 
	SUM(count)  AS 'Sum', 
	COUNT(count) AS 'Count' 
FROM shop;
```

![05](/GB_SQL/img/05_07.png)

![05](/GB_SQL/img/05_08.png)

Внутри окна так же возможно применить сортировку и группировку.

- **Группировка**

Для группировка используется  `PARTITION BY` , которая определяет столбец для группировки в окне:

![05](/GB_SQL/img/05_09.png)

```sql
SELECT shopping_day, department, count,
	SUM(count) OVER(PARTITION BY shopping_day) AS 'Sum' 
FROM shop;
```

![05](/GB_SQL/img/05_10.png)

Инструкция `PARTITION BY` сгруппировала строки по полю «**shopping_day**»и  каждой группы рассчитывается сумма значений по столбцу «**count**».

- **Сортировка**

![05](/GB_SQL/img/05_11.png)

Добавим к `PARTITION BY` сортировку по столбцу `«department»` (`ORDER BY department`). В данной ситуации мы будем считать нарастающий итог: для каждого значения «count» мы ищем сумму всех значений с предыдущими.

```sql
SELECT shopping_day, department, count,
	SUM(count) OVER(PARTITION BY shopping_day ORDER BY department) AS 'Sum' 
FROM shop;
```

![05](/GB_SQL/img/05_12.png)

И вишенка на тортике - ограничение строк в окне :)

Инструкция `rows` ограничивает строки в окне, указывается определенное количество строк, предшествующих или следующих за текущей.

Инструкция `range` , в отличие от `rows` , работает не со строками, а с диапазоном строк в инструкции ORDER BY. 

Обе инструкции `rows` и `range` всегда используются вместе с ORDER BY.

![05](/GB_SQL/img/05_13.png)

- **`UNBOUNDED PRECEDING`** – указывает, что окно начинается с первой строки группы;
- **`n PRECEDING`** – **n** строк перед текущей строкой.
- **`CURRENT ROW`** – окно начинается или заканчивается на текущей строке;
- **`n FOLLOWING`** – определяет число строк после текущей строки (не допускается в предложении RANGE). **n** строк после текущей строки.
- **`UNBOUNDED FOLLOWING`** – C помощью данной инструкции можно указать, что окно заканчивается на последней строке группы

Сумма рассчитывается по текущей и следующей ячейке в окне. А последняя строка в окне имеет то же значение, что и столбец «count»: больше не с чем складывать.

```sql
SELECT shopping_day, department, count,
	SUM(count) OVER(PARTITION BY shopping_day ORDER BY count ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING) AS 'Sum' 
FROM shop;
```

![05](/GB_SQL/img/05_14.png)

<hr>

[Содержание](#содержание)

# Ранжирующие функции

Эти функции позволяют использовать для указания ранга или порядкового номера, который у нас на рукаве 🙂

- `row_number`– задаем номер строки, используется для нумерации;
- `rank`— функция возвращает ранг каждой строки, в случае нахождения одинаковых, возвращается одинаковый ранг с пропуском следующего значения;
- `dense_rank`— функция возвращает так же ранг каждой строки. Но в отличие от функции `rank`, она для одинаковых значений возвращает ранг, не пропуская следующий;
- `ntitle`– это функция, которая позволяет поделить вашу выборку на группы, количество групп задается в скобках.

Пример для тестовой таблицы:

![05](/GB_SQL/img/05_15.png)

```sql
SELECT shopping_day, department, count,
	ROW_NUMBER() OVER(PARTITION BY shopping_day ORDER BY count) AS 'Row_number',
	RANK() OVER(PARTITION BY shopping_day ORDER BY count) AS 'Rank' ,
	DENSE_RANK() OVER(PARTITION BY shopping_day ORDER BY count) AS 'Dense_Rank' ,
	NTILE(3) OVER(PARTITION BY shopping_day ORDER BY count) AS 'Ntile'
FROM shop;
```

![05](/GB_SQL/img/05_16.png)

Вернемся к задаче: проставить ранги по убыванию ЗП (самая маленькая ЗП - самый маленький ранг).

Для подсчета ранга в нашем случае используем функцию dense_rank(). В нашем случае пропуск ранга не нужен: начинаем с 1 и увеличиваем ранг при отличии от предыдущего. Слово rank выделяем в экранированные кавычки: название столбца совпадает с функцией ранжирования, `rank` будет считаться как имя столбца:

```sql
SELECT 
	DENSE_RANK() OVER W AS `rank`, -- W = OVER(ORDER BY salary DESC)
  first_name, discipline, 
  salary
FROM staff
WINDOW  w AS (ORDER BY salary DESC)
ORDER BY `rank`, id;
```

![05](/GB_SQL/img/05_17.png)

Обратите внимание, что `order by` в окне задает сортировку окна, а `order by` в основном запросе — сортировку результатов всего запроса после отработки окна. 

Пусть целью моего запроса будет проставить ранг по возрастанию зарплаты, а сортировка - по убыванию:

```sql
SELECT 
	DENSE_RANK() OVER W AS `rank`, 
	first_name, discipline, 
  salary
FROM staff
WINDOW w AS (ORDER BY salary ASC)
ORDER BY salary DESC;
```

![05](/GB_SQL/img/05_17.png)

<hr>

[Содержание](#содержание)

# Агрегирующие оконные функции

Следующий вид оконных функций - агрегирующие. 

Они используются для учета средней зарплаты, подсчета количества сотрудников, максимальную и минимальную ЗП и сумму по чеку. Эти функции выполняют манипуляции с набором данных  и возвращают  итоговое значение.
|||
-- | --
`sum()` | сумма значений в столбце;
`count()` | количество значений в столбце (NULL не учитываются);
`avg()` | среднее значение в столбце
`max()` | определяет максимальное значение в столбце;
`min()` | определяет минимальное значение в столбце.

![05](/GB_SQL/img/05_18.png)

```sql
SELECT shopping_day, department, count,
	SUM(count) OVER(PARTITION BY shopping_day) AS 'Sum' ,
	COUNT(count) OVER(PARTITION BY shopping_day) AS 'Count' ,
	AVG(count) OVER(PARTITION BY shopping_day) AS 'Avg' ,
	MAX(count) OVER(PARTITION BY shopping_day) AS 'Max' ,
	MIN(count) OVER(PARTITION BY shopping_day) AS 'Min' 
FROM shop;
```

![05](/GB_SQL/img/05_19.png)

Давайте попробуем применить знания на практике. Каждая группа преподавателей по конкретному предмету получают зарплату. Давайте узнаем, какой процент от суммарной ЗП по отделу получает каждый педагог.

![05](/GB_SQL/img/05_20.png)

```sql
SELECT
  first_name, discipline, salary,
  SUM(salary) OVER w AS payment_fund,
  ROUND(salary * 100.0 / SUM(salary) OVER w) AS percentage 
FROM staff
WINDOW  w AS (PARTITION BY discipline)
ORDER BY discipline, salary, id;
```

Пройдемся по всей таблице. Считаем:
+ `payment_fund` — показывает суммарную ЗП отдела (она одинакова для всех сотрудников департамента);
+ `percentage` — процент зарплаты от этой суммы.

Окно состоит из секций по дисциплинам:

```sql
WINDOW  w AS (PARTITION BY discipline)
```

Чтобы найти суммарную зарплату, мы используем функцию агрегатную функцию `SUM(salary)` по столбцу `salary`. Для расчета процента ЗП будем использовать формулу:  `salary/sum(salary)`

![05](/GB_SQL/img/05_21.png)

<hr>

[Содержание](#содержание)

# **Функции смещения**

Это функции, которые позволяют перемещаться и обращаться к разным строкам в окне, относительно текущей строки, а также обращаться к значениям в начале или в конце окна.

|||
-- | --
`lag(value)` | функция lag()обращается к данным из предыдущей строки окна
`lead(value)` | функция lead()обращается к данным из следующей строки
`first_value()` | с помощью функции first_value() можно получить первое значение в окне, параметр - столбец, который нужно вернуть
`last_value()` | с помощью функции last_value() можно получить последнее значение в окне, параметр - столбец, который нужно вернуть

```sql
SELECT shopping_day, department, count, 
	LAG(count) OVER(PARTITION BY shopping_day ORDER BY shopping_day) AS 'Lag' ,
	LEAD(count) OVER(PARTITION BY shopping_day ORDER BY shopping_day) AS 'Lead' ,
	FIRST_VALUE(count) OVER(PARTITION BY shopping_day ORDER BY shopping_day) AS 'First_Value' ,
	LAST_VALUE(count) OVER(PARTITION BY shopping_day ORDER BY shopping_day) AS 'Last_Value'
FROM shop;
```

![05](/GB_SQL/img/05_22.png)

<hr>

[Содержание](#содержание)

# **Аналитические функции**

Аналитические функции — это функции которые возвращают информацию о распределении данных и используются для статистического анализа. Показывать математику без уточнения деталей будет не очень, уместно:

[MySQL :: MySQL 8.0 Reference Manual :: 12.21.1 Window Function Descriptions](https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html?ff=nopfpls)

<hr>

[Содержание](#содержание)

# Представления (VIEW)

[MySQL :: MySQL 8.0 Reference Manual :: 25.5 Using Views](https://dev.mysql.com/doc/refman/8.0/en/views.html)

При работе с БД требуется многократно  запускать запросы, которые могут быть сложными и требовать обращения к нескольким таблицам.  Чтобы не использовать многократно запросы, имеет смысл обратиться к так называемым представлениям (`view`).  

**Представление (`VIEW`)** — объект базы данных, являющийся результатом выполнения запроса к базе данных, определенного с помощью оператора `SELECT`, в момент обращения к представлению. Представления иногда называют «виртуальными таблицами».

![05](/GB_SQL/img/05_23.png)

**Синтаксис представления:**

```sql
CREATE VIEW name_view
AS
	(
		...
		query
		...
	);
```

В этой команде обязательно имя представления и сам запрос к БД. Попробуем реализовать простое представление. Попробуем реализовать запрос, который выводит дисциплины и количество преподавателей, которые эти предметы ведут:

```sql
SELECT
	discipline, count(first_name)
FROM staff
GROUP BY discipline
ORDER BY count(first_name) DESC;
```

Сделаем этот запрос представлением: 

```sql
CREATE OR REPLACE VIEW count_teacher AS
SELECT
	discipline, count(first_name) AS res
FROM staff
GROUP BY discipline
ORDER BY count(first_name) DESC;
-- "OR REPLACE" заменяет представление, если оно существует
```
​
Теперь вместо указания какого - либо сложного запроса можно вызвать представление:

```sql
SELECT * FROM count_teacher;
```

![05](/GB_SQL/img/05_24.png)

Если данные изменены в базовой таблице, то пользователь получит актуальные данные при обращении к представлению, использующему данную таблицу; кэширования результатов выборки из таблицы при работе представлений не производится. При этом, механизм кэширования запросов (query cache) работает на уровне запросов пользователя безотносительно к тому, обращается ли пользователь к таблицам или представлениям. Представления могут основываться как на таблицах, так и на других представлениях, т.е. могут быть вложенными (до 32 уровней вложенности).

**Операции с представлениями**

- `DROP` :  представление/виртуальную таблицу можно удалить с помощью команды `DROP VIEW`
- Объединение: мы также можем создать представление, объединив несколько таблиц. Это соединение будет извлекать совпадающие записи из обеих таблиц. 
- Создание рассмотрено выше (`CREATE VIEW`)
- Изменение существующего представления -  `ALTER VIEW`

```sql
-- Исключим математиков
ALTER VIEW count_teacher AS
SELECT
	discipline, count(first_name) AS res
FROM staff
WHERE discipline!="Математика"
GROUP BY discipline
ORDER BY count(first_name) DESC;
-- Показ
SELECT * FROM count_teacher;
```

![05](/GB_SQL/img/05_25.png)

<hr>

[Содержание](#содержание)

## **Преимущества использования представлений:**

1. Дает возможность гибкой настройки прав доступа к данным за счет того, что права даются не на таблицу, а на представление. Это очень удобно в случае если пользователю нужно дать права на отдельные строки таблицы или возможность получения не самих данных, а результата каких-то действий над ними.
2. Позволяет разделить логику хранения данных и программного обеспечения. Можно менять структуру данных, не затрагивая программный код, нужно лишь создать представления, аналогичные таблицам, к которым раньше обращались приложения. Это очень удобно когда нет возможности изменить программный код или к одной базе данных обращаются несколько приложений с различными требованиями к структуре данных.
3. Удобство в использовании за счет автоматического выполнения таких действий как доступ к определенной части строк и/или столбцов, получение данных из нескольких таблиц и их преобразование с помощью различных функций.

<hr>

[Содержание](#содержание)

## Полезные ссылки и рекомендации:

- [https://habr.com/ru/company/oleg-bunin/blog/348172/](https://habr.com/ru/post/255361/) - DDL, DCL на **MS SQL Server (1 часть).**
- https://habr.com/ru/post/255523/ - DDL, DCL на **MS SQL Server (2 часть).**
- Руководство по стилю написания SQL: https://www.sqlstyle.guide/ru/
- https://tproger.ru/translations/sql-window-functions/ - оконные функции
- Старайтесь не использовать русские буквы при работе с СУБД

<hr>

[Содержание](#содержание)


+ [ДЗ](#дз)
    + [Задание 1](#задание-1)
    + [Задание 2](#задание-2)
    + [Задание 3](#задание-3)
    + [Задание 4](#задание-4)
    + [Задание 5](#задание-5)


# ДЗ

## Задание 1

Создайте представление, в которое попадут автомобили стоимостью до 25 000 долларов CREATE VIEW CheapCars AS SELECT Name FROM Cars WHERE Cost<25000;

### Решение

Создадим и заполним таблицу

```sql
CREATE TABLE Cars
(
id INT PRIMARY KEY AUTO_INCREMENT,
name VARCHAR(25) NOT NULL,
cost INT NOT NULL
);

INSERT INTO Cars (name, cost)
VALUES
('Audi', 52642),
('Mercedes', 57127),
('Scoda', 9000),
('Volvo', 29000),
('Bentley', 350000),
('Citroen', 21000),
('Hummer', 41400),
('Volkswagen', 21600);
```

![005](/GB_SQL/Pictures/005_001.PNG)

Создайте представление, в которое попадут автомобили стоимостью до 25 000 долларов 

```sql
CREATE VIEW CheapCars AS SELECT Name FROM Cars WHERE Cost<25000;
```

![005](/GB_SQL/Pictures/005_002.PNG)

[Содержание](#содержание)

<hr>

## Задание 2

Изменить в существующем представлении порог для стоимости: пусть цена будет до 30 000 долларов (используя оператор ALTER VIEW) 

```sql
ALTER VIEW CheapCars AS SELECT Name FROM CarsWHERE Cost<30000;
```

![005](/GB_SQL/Pictures/005_003.PNG)

[Содержание](#содержание)

<hr>

## Задание 3

Создайте представление, в котором будут только автомобили марки “Шкода” и “Ауди” (аналогично).

```sql
CREATE VIEW scoda_audi
	AS SELECT *
    FROM cars
    WHERE name = 'Scoda' OR name = 'Audi';
```

![005](/GB_SQL/Pictures/005_004.PNG)

[Содержание](#содержание)

<hr>

## Задание 4
Вывести название и цену для всех анализов, которые продавались 5 февраля 2020 и всю следующую неделю.

Есть таблица анализов Analysis: 

+ an_id — ID анализа;
+ an_name — название анализа;
+ an_cost — себестоимость анализа;
+ an_price — розничная цена анализа;
+ an_group — группа анализов. 

Есть таблица групп анализов Groups:
+ gr_id — ID группы;
+ gr_name — название группы;
+ gr_temp — температурный режим хранения. 

Есть таблица заказов Orders:
+ ord_id — ID заказа;
+ ord_datetime — дата и время заказа;
+ ord_an — ID анализа.

Создадим таблицы

```sql
CREATE TABLE Analysis
(
an_id INT,
an_name VARCHAR(40),
an_cost INT,
an_price INT,
an_group VARCHAR(40)
); 

CREATE TABLE AnalysisGroups
(
gr_id INT,
gr_name VARCHAR(25),
gr_temp INT
);

CREATE TABLE Orders
(
ord_id INT,
ord_datetime VARCHAR(25),
ord_an INT
);
```

Соединим две таблицы Analysis, Orders по ID анализа (an_id и ord_id) и выведем полученое в диапазоне от 05.02.2020 и всю следующую неделю

```sql
SELECT A.an_id, A.an_name, A.an_price, O.ord_datetime
FROM Analysis AS A
JOIN Orders AS O
ON A.an_id = O.ord_an
WHERE O.ord_datetime BETWEEN '05.02.2020' AND '12.02.2020';
```

![005](/GB_SQL/Pictures/005_005.PNG)

[Содержание](#содержание)

<hr>

## Задание 5. 
Добавьте новый столбец под названием «время до следующей станции». 

Чтобы получить это значение, мы вычитаем время станций для пар смежных станций. 

Мы можем вычислить это значение без использования оконной функции SQL, но это может быть очень сложно. 

Проще это сделать с помощью оконной функции LEAD.<br>
Эта функция сравнивает значения из одной строки со следующей строкой, чтобы получить результат. В этом случае функция сравнивает значения в столбце «время» для станции со станцией сразу после нее.

Создадим и заполним таблицу:

```sql
CREATE TABLE timetable
(
train_id INT,
station VARCHAR(40),
station_time TIME
);

INSERT INTO timetable(train_id, station, station_time)
VALUES
(110, 'San Francisco', '10:00:00'),
(110, 'Redwood City', '10:54:00'),
(110, 'Palo Alto', '11:02:00'),
(110, 'San Jose', '12:35:00'),
(120, 'San Francisco', '11:00:00'),
(120, 'Palo Alto', '12:49:00'),
(120, 'San Jose', '13:30:00');
```
![005](/GB_SQL/Pictures/005_006.PNG)

LEAD(station_time) OVER(PARTITION BY train_id) - значение в следующей строке по группам

Функция SUBTIME - для вычисления разницы между TIME значениями.

```sql
SELECT *,
    SUBTIME(LEAD(station_time) 
    OVER(PARTITION BY train_id), station_time) AS 'time_to_next_station'
FROM timetable;
```

![005](/GB_SQL/Pictures/005_007.PNG)

[Содержание](#содержание)

<hr>