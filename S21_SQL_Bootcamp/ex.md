
Дополню по темам:

1. Er-модели. Отношения, атрибуты, связи.
2. Реляционные и нереляционные СУБД. Примеры. 
3. ACID и CAP.
4. CHECK Constraint, индексы, ключи.

В блоке из 15 вопросов с запросами встречалось следующее:
1. NULL в запросах;
2. JOIN (LEFT, RIGHT, FULL, CROSS, NATURAL), UNION, INTERSECT;
3. NULL FIRST, NULL LAST при сортировке;
4. SELECT DISTINCT, LIMIT, NOT EXISTS;
5. ROW_NUMBER, OVER.

30 вопросов по 1 правильному ответу в каждом.

10 первых вопросов имеют общий характер. Советую повторить:
+ Er-модели и их связи,
+ UML диаграммы,
+ СУБД (в частности postgresql)

3 следующих будут про нормальные формы баз данных.
2 вопроса про ACID. 
далее 15 вопросов по типу "что будет получено в результате следующего запроса?". запросы были на картинках, я их не увидел (был баг платформы, который до сих пор не починили), но судя по ответам не очень сложные. 

я сдал на 18/30, это 67%. если отталкиваться, что первые 15 были отвечены правильно, то из последних 15 (которых я не видел) я угадал 3. этого было достаточно.


Мои первые 10 теоретических вопросов:

1. Что концептуально представляют собой атрибуты сущности в ER-модели?
    + имена
    + характеристики (мой ответ)
    + ключевые связи
    + отношения

2. Какой из языков обычно используют для описания логических моделей данных?
    + UML
    + JSON
    + HTML
    + SQL (мой ответ)

3. Какое понятие описывает связь между двумя сущностями в логической модели данных
   + триггер
   + внешний ключ (мой ответ)
   + хэш-код
   + индекс

4. Что предствляет собой первая нормальная форма
   + каждая ячейка имеет только одно название
   + все значения атрибутов в таблице уникальны
   + все атрибуты зависят от первичного ключа (относится к второй форме)
   + каждая таблица имеет первичный ключ

5. Что такое первичный ключ в физической модели данных
   + уникальный идентификатор записи в таблице

6. CHECK CONSTRAINT не прошел
   + операция вставки или обновления будет отклонена

7. Какая DDL-команда используется для создания CHECK CONSTRAIN
   + ALTER TABLE
   + CREATE TABLE

8. Команда для создания FOREIGN KEY
   + INSERT INTO
   + ALTER VIEW
   + ADD CONSTRAIN (+)
   + CREATE INDEX

9. Какая DDL команда поможет создать составной индекс в реляционной базе данных
    + CREATE INDEX index_name ON table_name(column, column)

10. COMMIT - закрывает текущую сессию

11. Что произойдет при попытке удалить запись из родительской таблицы, если существует связанные записи в дочерней таблице ис установленным `FOREIGN KEY` и выставленной политикой `CASCADE`?
   + ошибка
   + удаление будет отклонено
   + **удаление дочерних и родительских строк будет выполнено без предупреждения** (скорее всего это правильный ответ, хотя нет указание на событие `ON DELETE` Почитать тут [Руководство по проектированию реляционных баз данных. Каскадное удаление данных](https://habr.com/ru/articles/194738/))
   + все дочерние записи будут удалены, но родительские записи нет.

12. Укажи, какие типы индексов поддерживаются в реляционных базах данных:
   + **Полнотекстовые индексы**
   + **Уникальные индексы**
   + Гибкие индексы
   + **Кластерные индексы**

Статья на тему: [Индексы в реляционной базе данных](/Lib/Indexes_in_a_relational_database/README.md)

13. Какой из следующих элементов ER-модели используется для обозначения связи между сущностями
   + таблица
   + **линия**
   + ключ
   + атрибут

14. Какая основная цель логического моделирования баз данных
   + Оптимизация запросов к базе данных
   + **Представление структуры базы данных без учета конкретной СУБД**

15. Какие из нижеперечисленных методов используются для нормализации логических моделей данных
   + **иерархическое разбиение**
   + многозначные зависимости
   + денормализация
   + **функциональные зависимости**

16. Что такое `CHECK CONSTRAINT` в реляционных базах данных
   + **ограничение, которое проверяет условия, для вставляемых или обновляемых строк**

17. Какой из нижеперечисленных фактов НЕ влияет на процесс проектирования физической модели данных:
   + инструмент проектирования физической модели
   + объём данных
   + требования к производительности
   + сложность бизнес-процессов

18. Как можно добавить объект `CHECK CONSTRAINT` к уже существующей таблице с использованием DDL-языка:
   + с помощью команды `ADD CONSTRAINT`
   + нельзя добавить `ADD CONSTRAINT` к уже существующей таблице
   + с помощью `SET CONSTRAINT`
   + c помощью `MODIFY COLUMN`

Вторая часть
1. Реляционная база данных - структура основанная на связях
2. Нереляционная база данных: MongoDB
3. Какая служба управляет доступом?

Третья часть
1. Аббревиатура CAP в контексте CAP-теории это

Теорема CAP (также известная как теорема Брюэра) — фундаментальный принцип распределённых вычислений, который определяет компромиссы и ограничения при проектировании и развёртывании надёжных, высокопроизводительных распределённых систем.

Теорема утверждает, что распределённая система хранения данных не может одновременно удовлетворять всем трём важнейшим аспектам:

+ Согласованность. Все узлы в распределённой системе предоставляют одни и те же данные и значения в любой момент времени.
+ Доступность. Мера того, насколько часто распределённая система может успешно отвечать на запросы пользователей.
+ Толерантность к разделению. Способность системы противостоять сбоям связи или сбоям в сети.

При проектировании распределённых систем крайне важно найти баланс между этими тремя атрибутами, поскольку достижение всех из них одновременно недостижимо.

[Всё, что вы не знали о CAP теореме](https://habr.com/ru/articles/328792/)

Что стоит за CAP

В CAP говорится, что в распределенной системе возможно выбрать только 2 из 3-х свойств:

+ `C (consistency)` — согласованность. Каждое чтение даст вам самую последнюю запись.
+ `A (availability)` — доступность. Каждый узел (не упавший) всегда успешно выполняет запросы (на чтение и запись).
+ `P (partition tolerance)` — устойчивость к распределению. Даже если между узлами нет связи, они продолжают работать независимо друг от друга.

2. Какой принцип ACID гарантирует что транзакция прошла успешно, изменения будет сохранено даже в случае сбоя системы

   Принцип ACID:
    + Atomicity (Атомарность)
    + Consistency (Согласованность)
    + Isolation (Изолированность)
    + Durability (Устойчивость)

 гарантирует, что изменения, сделанные успешно завершённой транзакцией, останутся сохранёнными после возвращения системы в работу.

Это не должно зависеть от проблем на нижних уровнях, например, от обесточивания системы или сбоев в оборудовании. Если пользователь получил подтверждение от системы, что транзакция выполнена, он будет уверен, что ничего не отменится из-за какого-либо сбоя.

[Транзакционность Основы SQL](https://ru.hexlet.io/courses/sql-basics/lessons/transactions/theory_unit)


Разберем каждое требование подробнее

**Atomicity (Атомарность)** <br>
Любая транзакция не может быть частично завершена — она либо выполнена, либо нет.

**Consistency (Согласованность)** <br>
Завершившаяся транзакция должна сохранять согласованность базы данных. Каждая успешная транзакция фиксирует только допустимые результаты, при том, что в процессе работы транзакции данные могут оказываться несогласованными.

В примере выше снятие денег с одного счета приводит к тому, что данные рассинхронизированы. Но когда транзакция завершается, этого нет.

Гарантию согласованности данных нельзя полностью обеспечить только средствами базы данных, например, различными ограничениями. Поддержка этого требования включает в себя работу со стороны программистов, которые пишут необходимый для этого код.

**Isolation (Изолированность)** <br>
Когда транзакция выполняется, параллельные транзакции не должны оказывать влияния на ее результат. Ни одна транзакция не может увидеть изменения, которые сделаны другими незавершенными транзакциями. Изолированность — дорогое требование, поэтому в реальных БД существуют режимы, которые изолируют транзакцию не полностью — уровни изолированности Repeatable Read и ниже.

**Durability (Устойчивость)** <br>
Изменения, которые сделаны успешно завершенной транзакцией, должны остаться сохраненными после возвращения системы в работу. И это не должно зависеть от проблем на нижних уровнях, к примеру, обесточивание системы или сбои в оборудовании. Если пользователь получил подтверждение от системы, что транзакция выполнена, он будет уверен, что ничего не отменится из-за какого-либо сбоя.
