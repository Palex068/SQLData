# 2. Простая выборка данных


## Содержание

+ [2.1 Базы данных](#21-базы-данных)
+ [2.2 Простая выборка и оператор AS](#22-простая-выборка-и-оператор-as)
+ [2.3 Выборка и сортировка данных: DISTINCT, ORDER BY и LIMIT](#23-выборка-и-сортировка-данных-distinct-order-by-и-limit)
+ [2.4 Порядок работы операторов в запросе](#24-порядок-работы-операторов-в-запросе)
+ [2.5 Практика](#25-практика)

[Оглавление](/SQL_Data/README.md)

# 2.1 Базы данных

Добро пожаловать в отдел аналитики! Как настрой в первый рабочий день? 

Обычно первый рабочий день начинается с получения доступов и чтения документации. Узнать о компании и системах, которые она использует в своей работе, можно на корпоративном портале* — у любой крупной компании он есть. Корпоративные порталы чаще всего создаются на базе специальных сервисов (например, Atlassian Confluence или Notion), где все отделы компании ведут документацию, описывают рабочие процессы и накопленные знания. Благодаря этому новыми сотрудникам будет проще познакомиться с компанией изнутри. 

Доступы к базе данных уже настроены, а у вашего наставника Николая как раз есть время ввести вас в курс дела. Так что наливайте себе кофе и располагайтесь поудобнее. Мы начнем с основ и сперва познакомим вас с таким понятием, как базы данных (БД). Будет много теории, и вы не только узнаете для чего они нужны , но и получите общее понимание работы бизнеса.

![02](/SQL_Data/img/02_01.png)

> Корпоративный портал или корпортал (иногда интранет) — это внутренний информационный сайт, где можно найти информацию о компании и её ценностях, обучающие материалы и контакты сотрудников.

Расскажем историю одной кофейни, чтобы на ее примере вы смогли понять, что такое базы данных.

Дедушка Лёня уже много лет владеет семейной кофейней в Санкт-Петербурге. Она небольшая и очень уютная. Меню у этой кофейни самое обычное: несколько разных видов кофе, чая и сладостей. Вместе с ним в этом заведении работает его жена, бабушка Зоя, а недавно к ним присоединился их внук, Максим. 

Для контекста добавим, что этой кофейне уже не один десяток лет и в ней уже устоялись некоторые правила. К примеру, когда владельцы открывали эту кофейню, они договорились вести учет на бумаге. Спустя много лет ничего не изменилось, и это ни капельки не мешает замечательному заведению радовать своих посетителей вкусным кофе. 

Так как предприятие совсем небольшое, то все записи делать в записной книжке отнюдь не сложно: достаточно записывать все поставки, списания* и продажи. Остатки** посчитать в таком случае достаточно просто, потому что товаров совсем немного и все они на виду. 

Какой-то сложной аналитики этой кофейне не нужно, так как хозяева уже отлично знают всех своих посетителей, поставщиков и все, что связано с их бизнесом.

![02](/SQL_Data/img/02_02.png)

>*Списание — изъятие или удаление из оборота товара,  который невозможно реализовать из-за утери, порчи или потребления сотрудниками.
>**Остатки товаров – непроданные товары. Иногда под остатками понимается отчет, который показывает текущее количество товаров на складах. 

Итак, разберем подробнее эту самую записную книжку. 

Как мы ранее упоминали, в ней три основных раздела: поставки, списания и продажи. Как они будут выглядеть? 

Очевидно, что в небольшой кофейне все записи будут максимально простыми, ведь единственный критерий — понятность для дедушки Лёни. К примеру: 

**Поставки**

Так как владелец пишет все в спешке, записи в тетрадке не стандартизированы. К примеру, где-то написано «шт.», а где-то «штук».

![02](/SQL_Data/img/02_03.png)

**Списания**

Так как учет ведется самим хозяином и решения о списаниях принимает он сам, нет нужды указывать причины и другие подробности.

![02](/SQL_Data/img/02_04.png)

**Продажи**

Тут также нет никакого единого стиля ведения записей. Нет количества проданных товаров, где-то даже есть пропуски: возможно дедушка Лёня был занят и не успел всё записать. Также здесь не видно, была ли какая-либо скидка применена к продаже. 

![02](/SQL_Data/img/02_05.png)

Как мы говорили ранее, такой формат учета возможен потому, что хозяева заведения наизусть знают всё про свою кофейню и не нуждаются в дополнительных средствах контроля и анализа. 

Спустя несколько лет работы, Максим, внук дедушки Лёни, решил, что очень хочет расширить семейный бизнес и построить сеть кафе. Но он понимал, что текущий поход к учету будет преградой при масштабировании*.

К примеру: 

1. Для сети кофеен уже будет невозможен оперативный доступ к данным, так как все носители (записные книжки) находятся в разных местах. 
2. Из-за отсутствия стандартов ведения записей очень сложно, а иногда даже невозможно посчитать, к примеру, самую продаваемую позицию месяца. А посчитать то же самое в разрезе года будет самым мучительным опытом в жизни предпринимателя. 
3. Управление остатками и своевременный заказ необходимых товаров становится тяжелой задачей из-за отсутствия учета остатков в каком-либо виде. 
4. Затруднительно оценивать качество работы сотрудников. 

Недостатки можно перечислять очень долго. Максим понял, что оцифровать данные и хранить их в компьютере будет в разы удобнее и практичнее. К тому же, бумага со временем портится, с ней может случится все что угодно, а оцифрованные данные можно хранить в нескольких местах, чтобы свести риски потери к нулю.

Для этого ему понадобилась бы специальная программа — автоматизированная система, куда вносятся все сведения о поставках, продажах, списаниях и так далее. Изучив предложения на рынке, он выбрал ту, которая устраивала его по цене и функционалу. Перед тем, как начать путь к открытию новых точек, Максим внедрил эту систему в старой кофейне и внимательно изучил ее возможности на практике. 

Данные из нее можно было выгружать в Excel для анализа. Так было разработано несколько шаблонов, которые помогали юному предпринимателю анализировать семейный бизнес, и был сделан первый шаг в сторону создания полноценных баз данных.  

>*Масштабирование бизнеса — это мероприятия, направленные на расширение сети, ассортимента товаров, количества и качества услуг, а также деятельности в целом.

Давайте чуть поближе рассмотрим эту систему и как она устроена. Все достаточно просто: такие системы на практике состоят из двух компонентов*: **Front Office** и **Back Office**. 

**Front Office** используется официантами, кассирами, администраторами — персоналом, который работает в зале. Этот компонент должен покрывать все их задачи: продажи, списание, сканирование акцизных товаров и так далее. 

**Back Office**, в свою очередь, необходим для всех задач, связанных с учетом: приемка товара и ведение накладных, подготовка отчетности для налоговой, амортизация оборудования и многое другое. Обычно с этим компонентом системы работают управляющие и бухгалтеры.

Таким образом, с помощью автоматизации экономится огромное количество времени на все существующие процессы в заведении, от поставок до продаж.

Как мы говорили ранее, данные также можно выгружать из системы в Excel для быстрой обработки и анализа. Давайте разберем подробнее, для чего это нужно и как это работает. 

>*Здесь для упрощения мы опускаем многие технические подробности работы таких систем и обращаем внимание только на основные их компоненты и свойства.

Один из самых важных отчетов для руководства любого бизнеса — это **отчет о прибылях и убытках***. Он очень важен, потому является обязательным для подачи в налоговую. Такие автоматизированные системы существенно ускоряют составление отчетов, так как они стандартизированы. Достаточно один раз собрать данные и сформировать алгоритм для формирования отчета (обычно это доступно уже **«из коробки»****), и получать его по кнопке «Сформировать отчет».

У этого отчета есть ряд нюансов, к примеру: некоторые виды рекламных мероприятий налоговая не считает расходами. При этом для руководства кофейни любой вид рекламы — очевидная статья расходов, которую хочется учитывать. Таким образом, выделяют несколько типов **отчетности*****:

+ **отчетность**, которая формируется **для надзорных органов** (обычно ее называют «статистическая отчетность» или «регулятивная отчетность»);
+ **операционная отчетность** — внутренняя отчетность, которая используется менеджментом предприятия для мониторинга, анализа и управления бизнес-процессами. Она может включать отчеты о продажах, отчеты о закупках, отчеты по проектам, отчеты о работе сотрудников, отчеты о складских запасах. По сути, операционная отчетность отражает все , что происходило с предприятием за какое-то время. 

Такого рода документы — это данные, преобразованные из одного вида в другой с некоторыми правилами. Отсюда можно сделать вывод, что на базовом уровне для создания отчета нам нужно две вещи: 

1. Данные, на которых будет построен отчет.
2. Алгоритм, с помощью которого этот отчет собирается.

Давайте разберемся подробнее, как это все устроено.

![02](/SQL_Data/img/02_06.png)

>*Отчет, в котором отражается доход и расход компании за период. Английское название отчета бывает разным, часто используется название Profit and Loss Account (P&L). Данная аббревиатура достаточно часто встречается в работе.

>**«Из коробки» означает, что данный функционал был предусмотрен и разработан поставщиком ПО заранее, никаких дополнительных действий со стороны потребителя не требуется.

>***Существуют и другие виды отчетности, к примеру: аудиторская, управленческая, отчетность по корпоративной социальной ответственности и так далее. Так как они не являются предметом обсуждения в рамках данного курса, здесь и в дальнейшем мы их не упоминаем.

Начнем с алгоритма. В данном случае алгоритм представляет собой последовательность операций с данными. Чаще всего это блок кода, который выполняет эти операции. Схематично он выглядит следующим образом: 

1. Получение исходных данных.
2. Вычисление необходимых показателей и преобразование данных в заранее определенную структуру*.
3. Сохранение и передача полученных данных пользователю в определенном формате.

Исходные данные, в свою очередь, хранятся в базах данных (БД). Идея здесь также достаточно простая: когда происходит какое-либо событие в системах, о которых мы говорили ранее, запись о нем сразу попадает в базу данных. К примеру, когда пришел товар, в Back Office заполняется шаблон накладной, и когда нажимается кнопка «сохранить», данные автоматически записываются в БД. То же происходит и со всеми остальными данными кофейни. 

В базах данных хранение организовано в табличном формате. В таблице продаж будет храниться вся информация связанная с продажами, в остатках — с остатками и так далее. Именно с таблицами баз данных мы будем учиться работать в нашем курсе.

> *Здесь под **структурой** понимаются столбцы таблицы.

Доступ к информации, которая хранится в базе данных, осуществляется при помощи специальной программы, системы управления базами данных (СУБД). 

Для того, чтобы получить необходимые данные из БД при помощи **СУБД**, был придуман специальный язык — **SQL (Structured Query Language, структурированный язык запросов)**. Запросом в базу данных называют код, который описывает какие данные и в каком формате вы хотите получить. 

В рамках этого урока мы узнали, что такое БД и зачем они нужны. Для начала нам этого хватит. В следующем модуле мы познакомимся с SQL и решим с помощью него первые задачи.

После того, как Максим, внук дедушки Лёни, развил сеть кофеен по всей стране, он решил открыть свой интернет-магазин кофе, чтобы его клиенты смогли насладиться потрясающим ароматом кофейных зерен у себя дома.

Сегодня ваш первый день на работе в технической команде этого кофейного магазина. Теперь после того, как вы познакомились с историей бизнеса и разобрались в причинах перехода к хранению всех операций бизнеса Максима в базе данных, пришло время решать рабочие задачи. Вперед к звездам!

<hr>

[Содержание](#содержание)

# 2.2 Простая выборка и оператор AS

Итак, наша первая **боевая задача***! Отдел маркетинга попросил сделать полную выгрузку данных о пользователях нашего онлайн-магазина True Coffee. 

На внутреннем портале компании мы прочитали, что все данные о пользователях хранятся в таблице **users** с вот такой структурой: 

![02](/SQL_Data/img/02_07.png)

Благодаря описанию таблицы, мы уже заранее можем представить, какие данные в ней хранятся**.

>*Боевая задача —  задача, для выполнения которой нужно обрабатывать/анализировать реальные данные, а не тестовые. Самые актуальные данные расположены на продуктовой среде (ещё её называют «прод» или «боевая среда»). На проде у пользователей, не являющихся администраторами системы, обычно ограниченный набор прав: они могут делать выгрузки, но не могут изменять данные или удалять таблицы. В свою очередь для разработки и тестирования предназначена тестовая среда (тестовый стенд, тестовый контур). Обычно это копия данных с прода за ограниченный промежуток времени или с отставанием на несколько дней.  

>**Более подробно с таблицей и типами данных вы познакомитесь в следующих степах. А про ключи мы расскажем в 6 модуле. На данный момент вам нужно знать, что первичный ключ — это уникальное значение, то есть в столбце id нет повторяющихся значений.

Кроме того, мы нашли шпаргалку по SQL!

Если требуется выгрузить все данные из таблицы, используйте запрос: 

```sql
SELECT *
FROM название_таблицы;
```

То есть для решения первой задачи нужно знать только имя таблицы. Его мы уже знаем — это users. Значит, запрос должен выглядеть так:

```sql
SELECT *
FROM users;
```

Скопируйте этот запрос в поле ниже и нажмите «Отправить». Посмотрите на данные в таблице и сравните с описанием из предыдущего степа:

![02](/SQL_Data/img/02_08.png)

```
+----+-----------------------------+------------+---------------------+-------------+------------+
| id | email                       | name       | created             | phone       | birthday   |
+----+-----------------------------+------------+---------------------+-------------+------------+
| 1  | melissa_mm@seolovin.net     | Melissa    | 2020-01-09 11:21:00 | 89405403537 | 1977-05-23 |
| 2  | clara_sa@seolovin.net       | Clara      | 2020-01-09 10:35:00 | 89655586646 | 1969-03-19 |
| 3  | iamkennet@seolovin.net      | Kennet     | 2020-01-08 01:54:00 | 89905769755 | 1971-11-11 |
| 4  | victorsss37@mail.ru         | Виктор     | 2020-01-06 16:15:00 | 89155952865 | 1968-02-15 |
| 5  | alex006@inbox.ru            | Алексей    | 2020-01-04 01:09:00 | 89406135974 | 1979-06-30 |
| 6  | art59@gmail.com             | Arthur     | 2020-01-03 20:24:00 | 89656319084 | 1967-03-30 |
| 7  | geeoorrg81@glmux.ru         | George     | 2020-01-02 13:17:00 | 89906502193 | 1975-01-25 |
| 8  | kura_lsls@seolovin.net      | Kura       | 2019-12-31 23:41:00 | 89156685303 | 1967-12-21 |
| 9  | mich_a_el@seolovin.net      | Michel     | 2019-12-31 05:16:00 | 89406868412 | 1967-04-08 |
| 10 | el_p@thefmail.com           | Эля        | 2019-12-29 18:31:00 | 89657051521 | 1958-12-17 |
| 11 | champ_38_21@mail.ru         | KdiiqOjPn  | 2019-12-28 23:26:00 | 89907234631 | 1977-04-26 |
| 12 | charlie_78_87@bk.ru         | Charles    | 2019-12-26 08:08:00 | 89157417740 | 1969-03-23 |
| 13 | lyuda_28_11@gmail.com       | Людмила    | 2019-12-25 14:03:00 | 89407600850 | 1959-02-05 |
| 14 | kissa_zel@gmail.com         | Zelena     | 2019-12-25 05:30:00 | 89657783959 | 1963-10-21 |
| 15 | ya_yana2014@yandex.ru       | Яна        | 2019-12-23 09:34:00 | 89907967069 | 1960-12-17 |
| 16 | inna-info@yandex.ru         | Инна       | 2019-12-22 18:39:00 | 89158150174 | 1959-01-25 |
| 17 | will_1_am@bk.ru             | William    | 2019-12-22 16:36:00 | 89408333284 | 1966-09-26 |
| 18 | 1614213543@mail.ru          | Сергей     | 2019-12-21 15:25:00 | 89658516393 | 1971-12-08 |
| 19 | tiger_rus@mail.ru           | Руслан     | 2019-12-20 20:15:00 | 89908699503 | 1966-10-23 |
| 20 | antony_sop@gmail.com        | Anton      | 2019-12-20 08:24:00 | 89158882612 | 1974-04-17 |
| 21 | gob_dmit@gmail.com          | Дмитрий    | 2019-12-19 09:06:00 | 89409065721 | 1961-05-23 |
| 22 | alex_bar_k@ya.ru            | Александра | 2019-12-18 18:05:00 | 89659248831 | 1973-08-27 |
| 23 | stacy1337@mail.ru           | Анастасия  | 2019-12-18 08:12:00 | 89909431940 | 1969-09-17 |
| 24 | mattie345@mail.ru           | Matt       | 2019-12-17 20:14:00 | 89159615050 | 1974-06-24 |
| 25 | click_home@mailsgoogle.ru   | John       | 2019-12-15 09:17:00 | 89409798159 | 1971-06-20 |
| 26 | slony_15@gmail.com          | Анастасия  | 2019-12-15 08:40:00 | 89659981269 | 1979-02-08 |
| 27 | goin_places@forex57.com     | Payonge    | 2019-12-14 14:41:00 | 89910164378 | 1967-11-26 |
| 28 | helen_ivan@mail.ru          | Elena      | 2019-12-14 04:36:00 | 89160347487 | 1977-03-30 |
| 29 | xenia_999@yandex.ru         | Ксения     | 2019-12-13 18:07:00 | 89410530597 | 1974-01-08 |
| 30 | richie_rich@seolovin.site   | Richard    | 2019-12-13 08:56:00 | 89660713706 | 1967-06-20 |
| 31 | daniel_white_vans@yandex.ru | Дэн        | 2019-12-10 08:25:00 | 89910896816 | 1966-11-20 |
| 32 | nicholas_flamel@yandex.ru   | Никита     | 2019-12-10 08:15:00 | 89161079921 | 1963-01-19 |
| 33 | marie_chic@yandex.ru        | Мария      | 2019-12-10 08:06:00 | 89411263031 | 1973-07-30 |
| 34 | daniil_foma@yandex.ru       | Даниил     | 2019-12-10 07:56:00 | 89661446140 | 1977-11-10 |
+----+-----------------------------+------------+---------------------+-------------+------------+
```

<hr>

[Содержание](#содержание)

## Типы данных

У вас все получилось! Давайте посмотрим на первые строки таблицы `users`:

![02](/SQL_Data/img/02_09.png)

У нас есть 6 столбцов*: `id`, `email`, `name`, `created`, `phone`, `birthday`. В каждом из них хранятся данные определенного типа — этот параметр задается еще при создании таблицы. 

Например, у поля `id` **числовой целочисленный** тип данных — в этой колонке могут быть записаны только целые числа.

Поля `email`, name и `phone` имеют **строковый** тип данных, то есть в них хранится текст.

В полях `birthday` и `created` хранятся **дата** и **дата со временем** соответственно. В таких столбцах можно хранить только даты, причем в определенном формате, например, ‘2022-01-08’ или ‘08.01.2022’. Формат определяется при создании столбца**.

> *Как вы уже знаете, в базе данных вся информация хранится в виде таблиц, у которых есть столбцы и строки. Правильнее будет столбцы или колонки называть полями, а строки — записями.
Почему поля? Потому что не все базы данных хранят информацию в виде таблиц (такие базы данных называются нереляционными, можете поискать в интернете примеры таких БД и почитать, как они хранят свои данные), соответственно, у них нет понятия столбцов.
Почему записи? Потому что строка - это тип поля, в котором хранится текстовая информация.

>**В данном курсе мы не рассматриваем создание таблиц. Но если вам интересен данный материал, более подробную информацию вы сможете найти в интернете по запросу: «создание таблиц CREATE TABLE» или в документации по MySQL напрмиер, [здесь](https://www.w3schools.com/mysql/mysql_create_table.asp).

На самом деле для каждой СУБД есть свой набор типов данных. Ниже представлены основные типы, которые относятся к СУБД, с которой мы будем работать все время MySQL 8. С остальными вы можете ознакомиться в [документации](https://dev.mysql.com/doc/refman/8.0/en/data-types.html).

![02](/SQL_Data/img/02_10.png)

При создании таблицы выбирать подходящий тип данных надо с особой внимательностью, ведь от него зависит объем дискового пространства и оперативной памяти, который будут занимать данные.

Например, если в поле будут храниться только числа не больше `2147483647` и не меньше `-2147483648`, то лучше всего выбрать тип `INT`, ведь в таком случае каждое число будет занимать всего лишь 4 байта. Если бы мы выбрали для этого поля тип `BIGINT`, то каждое число занимало бы 8 байт, что в 2 раза больше. А если бы мы выбрали для него тип `VARCHAR`, то каждая цифра таких чисел занимала бы по 1 байту плюс 1 байт на длину числа, то есть число 1000000 при типе `VARCHAR(10)` занимало бы 8 байт (по 1 байту на каждую цифру + 1 байт на длину числа, которая равна 7). 

К тому же, для работы с каждым типом есть свои функции и операции.

<hr>

[Содержание](#содержание)

## Операторы FROM и SELECT

Данные в отдел маркетинга мы предоставили и даже разобрались, какие типы данных представлены в нашей таблице. А теперь мы посмотрим, как отработал наш запрос:

```sql
SELECT *
FROM users;
```

Важно не забывать: SQL расшифровывается как структурированный язык запросов. То есть в нашем запросе команды должны находиться в строго определенном порядке, иначе код выдаст ошибку.

Первым всегда отрабатывает команда FROM. Такие команды еще называют операторами*. С помощью оператора FROM мы говорим СУБД, из какой таблицы мы хотим получить данные. А с помощью SELECT (от англ. «выбирать») мы говорим СУБД, какие поля из таблицы мы хотим выбрать. Для выбора нужных нам полей необходимо перечислять их имена через запятую. То есть, если бы к нам пришли из отдела маркетинга и попросили выгрузить только имена пользователей и их дни рождения, мы бы написали:

```sql
SELECT name, birthday
FROM users;
```

Но ведь в прошлый раз мы явно не указывали ни одного поля из таблицы! Чтобы выбрать все поля из таблицы, необязательно их все перечислять, достаточно написать * .

>*Операторы — это, можно сказать, слова или символы, которые указывают СУБД, какое действие выполнять с базой данных в рамках нашего запроса.

Давайте немного потренируемся, а заодно посмотрим, какие таблицы есть в базе данных нашего онлайн-магазина*. 

Выберите все данные из таблицы `products`.

```sql
SELECT *
FROM products;
```

```
+----+----------+------------------------------------+
| id | brand_id | name                               |
+----+----------+------------------------------------+
| 1  | 4        | Кундинамарка                       |
| 2  | 9        | Ньери                              |
| 3  | 7        | Кофе «Эспрессо»                    |
| 4  | 7        | Кофе «Тайрона»                     |
| 5  | 8        | Тефлоновый питчер Joe Frex 350 мл |
| 6  | 8        | Кофемолка Skerton                  |
| 7  | 8        | Кофемолка Mini                     |
| 8  | 8        | Чайник Buono                       |
| 9  | 8        | Весы V60 Drip Scale                |
| 10 | 8        | Воронка V60 Plastic                |
| 11 | 6        | Кофе «Сантос»                      |
| 12 | 1        | Кофе «Чанчамайо»                   |
| 13 | 2        | Харрар                             |
| 14 | 4        | Супремо                            |
| 15 | 8        | Кофеварка на 3 чашки               |
| 16 | 8        | Фильтры                            |
| 17 | 4        | Кофе светлой обжарки «Эксельсо»    |
| 18 | 9        | Кофе светлой обжарки «Найроби»     |
| 19 | 1        | Кофе «Ламдонг»                     |
| 20 | 2        | Кофе «Иргачеффе»                   |
| 21 | 3        | Джей Хилл                          |
| 22 | 11       | Киримиро                           |
| 23 | 8        | кружка Black                       |
| 24 | 7        | Кофе «Мачу-Пикчу»                  |
| 25 | 7        | Кофе «Сан-Паулу»                   |
| 26 | 8        | чайник BKV12S02-CEV                |
| 27 | 8        | весы BSC2BNVWP                     |
| 28 | 13       | Кофе «Сьерра-Морена»               |
| 29 | 15       | Чьяпас                             |
| 30 | 17       | Черный чай Ассам                   |
| 31 | 17       | Черный чай Эрл Грей                |
| 32 | 17       | Зеленый чай Сенча                  |
| 33 | 17       | Фруктовый чай «Наглый фрукт»       |
| 34 | 7        | Кофе «Твист»                       |
| 35 | 10       | Кофе «Малабар»                     |
| 36 | 5        | Кофе «Сан-Маркос»                  |
| 37 | 16       | Кофе «Джампит»                     |
| 38 | 14       | Серрано                            |
+----+----------+------------------------------------+
```

Выгрузите из таблицы `users` только имена пользователей и их электронные почты.

Вам понадобятся столбцы `name` и `email`.

```sql
SELECT name, email
FROM users
```

```
+------------+-----------------------------+
| name       | email                       |
+------------+-----------------------------+
| Melissa    | melissa_mm@seolovin.net     |
| Clara      | clara_sa@seolovin.net       |
| Kennet     | iamkennet@seolovin.net      |
| Виктор     | victorsss37@mail.ru         |
| Алексей    | alex006@inbox.ru            |
| Arthur     | art59@gmail.com             |
| George     | geeoorrg81@glmux.ru         |
| Kura       | kura_lsls@seolovin.net      |
| Michel     | mich_a_el@seolovin.net      |
| Эля        | el_p@thefmail.com           |
| KdiiqOjPn  | champ_38_21@mail.ru         |
| Charles    | charlie_78_87@bk.ru         |
| Людмила    | lyuda_28_11@gmail.com       |
| Zelena     | kissa_zel@gmail.com         |
| Яна        | ya_yana2014@yandex.ru       |
| Инна       | inna-info@yandex.ru         |
| William    | will_1_am@bk.ru             |
| Сергей     | 1614213543@mail.ru          |
| Руслан     | tiger_rus@mail.ru           |
| Anton      | antony_sop@gmail.com        |
| Дмитрий    | gob_dmit@gmail.com          |
| Александра | alex_bar_k@ya.ru            |
| Анастасия  | stacy1337@mail.ru           |
| Matt       | mattie345@mail.ru           |
| John       | click_home@mailsgoogle.ru   |
| Анастасия  | slony_15@gmail.com          |
| Payonge    | goin_places@forex57.com     |
| Elena      | helen_ivan@mail.ru          |
| Ксения     | xenia_999@yandex.ru         |
| Richard    | richie_rich@seolovin.site   |
| Дэн        | daniel_white_vans@yandex.ru |
| Никита     | nicholas_flamel@yandex.ru   |
| Мария      | marie_chic@yandex.ru        |
| Даниил     | daniil_foma@yandex.ru       |
+------------+-----------------------------+
```

<hr>

[Содержание](#содержание)

## Особенность синтаксиса

Вы могли заметить, что ключевые слова (`SELECT` и `FROM`) в `SQL` пишутся в верхнем регистре (большими буквами). 

На самом деле так делать необязательно. Вообще `SQL` не является регистрозависимым, то есть запрос отработает, независимо от того, как будут написаны ключевые слова.

Следующие запросы вернут один и тот же результат:

```sql
SELECT name
FROM users;
select name
from users;
SeLeCT name
FRoM users;
```

Можно написать код даже вот так!

```sql
select name from users;
```

Так почему же мы тогда писали одни слова в запросе большими буквами, а другие маленькими? Дело в том, что редакторы кода, которые подсвечивают части SQL запроса разными цветами, появились не сразу. И было принято писать ключевые слова и функции заглавными буквами, а названия атрибутов и таблиц – строчными, чтобы визуально код был более читаемым. То же самое касается и переносов на другую строку. Сейчас, с появлением редакторов кода необходимость соблюдать регистры отпала, так как подсветка ключевых слов отдельным цветом и так делает код визуально понятным и читаемым.

В нашем курсе операторы и функции написаны заглавными буквами, чтобы было хорошо видно, что именно мы подсчитываем и какие операторы прописываем*.

Также вы могли заметить, что после запроса стоит знак «;». С его помощью разделяются разные запросы. Если запросов несколько, без него база данных не поймет, где начинается один и заканчивается следующий, и выдаст ошибку при запуске кода.

В нашем курсе при выполнении заданий, всегда будет требоваться написать только один запрос, поэтому код будет работать, даже если вы не поставите «;» в конце.

Всегда, когда пишете код, помните, что, возможно, через какое-то время его нужно будет отредактировать: добавить новые поля или переделать расчеты. Этой задачей могут заниматься ваши коллеги, а не вы. А еще, особенно на первых порах, вам может понадобиться помощь, и вы можете попросить кого-то из них посмотреть, почему запросы дают не тот результат, который нужен. Так что лучше делать код максимально понятным и простым для восприятия.

>*При прохождении курса мы рекомендуем следовать правилу: ключевые слова и функции писать заглавными буквами, а названия атрибутов и таблиц – строчными, либо писать весь запрос в нижнем регистре.
>Правила оформления запросов и имен объектов (таблиц и полей) в каждой компании свои. У нас принято писать SQL-выражения большими буквами, а имена объектов оформлять в стиле [snake_case](https://ru.wikipedia.org/wiki/Snake_case). Но в других компаниях могут быть свои правила, например, для имен объектов может быть использован [CamelCase](https://ru.wikipedia.org/wiki/CamelCase).

<hr>

[Содержание](#содержание)

## Особенности наименований полей

Давайте вспомним наименования столбцов в нашей таблице users:

![02](/SQL_Data/img/02_11.png)

Полям принято давать **говорящие** имена, чтобы по одному названию было понятно, какие данные там хранятся. Например, по названию поля email уже сразу понятно, что там записываются адреса электронной почты. 

Обычно в компаниях есть стандарты, как называть поля в таблицах. Например, если это поле с датой, то к названию приписывается `_dt` или `_date`. А если это расчетное поле, содержащее количество, то часто к названию приписывается `_cnt` (сокращение от count — «количество»): название `calls_cnt` подойдет для столбца, в котором содержится количество звонков.

<hr>

[Содержание](#содержание)

## Константные поля

Результатом выполнения запроса является таблица, у которой есть строки и столбцы. Мы же в свою очередь можем выводить не только атрибуты таблицы, но и задавать при выводе константные поля, то есть неизменяемые значения. Например, если нам захочется, чтобы в результате рядом с именем каждого пользователя была строка «This is our user», то запрос будет иметь следующий вид:

```sql
SELECT name, 'This is our user'
FROM users;
```

Скопируйте запрос в поле ниже и нажмите «Отправить», чтобы посмотреть на полученный результат.

>Обратите внимание на названия выведенных полей.

```
| name       | This is our user |
+------------+------------------+
| Melissa    | This is our user |
| Clara      | This is our user |
| Kennet     | This is our user |
| Виктор     | This is our user |
| Алексей    | This is our user |
| Arthur     | This is our user |
| George     | This is our user |
| Kura       | This is our user |
| Michel     | This is our user |
| Эля        | This is our user |
| KdiiqOjPn  | This is our user |
| Charles    | This is our user |
| Людмила    | This is our user |
| Zelena     | This is our user |
| Яна        | This is our user |
| Инна       | This is our user |
| William    | This is our user |
| Сергей     | This is our user |
| Руслан     | This is our user |
| Anton      | This is our user |
| Дмитрий    | This is our user |
| Александра | This is our user |
| Анастасия  | This is our user |
| Matt       | This is our user |
| John       | This is our user |
| Анастасия  | This is our user |
| Payonge    | This is our user |
| Elena      | This is our user |
| Ксения     | This is our user |
| Richard    | This is our user |
| Дэн        | This is our user |
| Никита     | This is our user |
| Мария      | This is our user |
| Даниил     | This is our user |
+------------+------------------+
```

В константном поле можно указывать не только строки, но и числа. Числа указываются без кавычек.

Недавно на склад поступила партия №5. Давайте выведем наименования продуктов из таблицы `products` и дополнительный столбец с цифрой 5.

Вам понадобится столбец `name` из таблицы `products`.

```sql
SELECT name, 5
FROM products;
```

```
+------------------------------------+---+
| name                               | 5 |
+------------------------------------+---+
| Кундинамарка                       | 5 |
| Ньери                              | 5 |
| Кофе «Эспрессо»                    | 5 |
| Кофе «Тайрона»                     | 5 |
| Тефлоновый питчер Joe Frex 350 мл | 5 |
| Кофемолка Skerton                  | 5 |
| Кофемолка Mini                     | 5 |
| Чайник Buono                       | 5 |
| Весы V60 Drip Scale                | 5 |
| Воронка V60 Plastic                | 5 |
| Кофе «Сантос»                      | 5 |
| Кофе «Чанчамайо»                   | 5 |
| Харрар                             | 5 |
| Супремо                            | 5 |
| Кофеварка на 3 чашки               | 5 |
| Фильтры                            | 5 |
| Кофе светлой обжарки «Эксельсо»    | 5 |
| Кофе светлой обжарки «Найроби»     | 5 |
| Кофе «Ламдонг»                     | 5 |
| Кофе «Иргачеффе»                   | 5 |
| Джей Хилл                          | 5 |
| Киримиро                           | 5 |
| кружка Black                       | 5 |
| Кофе «Мачу-Пикчу»                  | 5 |
| Кофе «Сан-Паулу»                   | 5 |
| чайник BKV12S02-CEV                | 5 |
| весы BSC2BNVWP                     | 5 |
| Кофе «Сьерра-Морена»               | 5 |
| Чьяпас                             | 5 |
| Черный чай Ассам                   | 5 |
| Черный чай Эрл Грей                | 5 |
| Зеленый чай Сенча                  | 5 |
| Фруктовый чай «Наглый фрукт»       | 5 |
| Кофе «Твист»                       | 5 |
| Кофе «Малабар»                     | 5 |
| Кофе «Сан-Маркос»                  | 5 |
| Кофе «Джампит»                     | 5 |
| Серрано                            | 5 |
+------------------------------------+---+
```

<hr>

[Содержание](#содержание)

## Вычисление арифметических выражений при выборке

При выборке данных из таблицы мы можем применить любую математическую операцию к значениям числового типа. Можно прибавить или вычесть число, умножить или разделить, найти остаток от деления и так далее.

Давайте познакомимся с новой таблицей в нашей базе данных — purchases. В ней указаны данные о покупках пользователей.

Выведем идентификатор покупки (id), цену (price) и добавим вычисляемое поле: цена в долларах. Для этого нам нужно столбец price разделить на 90. 

```sql
SELECT id, price, price / 90
FROM purchases;
```

Скопируйте запрос в поле ниже и нажмите «Отправить», чтобы посмотреть на полученный результат.

>Обратите внимание на названия выведенных полей.

```sql
SELECT id, price, price / 90
FROM purchases
LIMIT 5;
```

```
+----+--------+------------+
| id | price  | price / 90 |
+----+--------+------------+
| 1  | 1530.0 | 17.0       |
| 2  | 340.0  | 3.777778   |
| 3  | 370.0  | 4.111111   |
| 4  | 340.0  | 3.777778   |
| 5  | 340.0  | 3.777778   |
+----+--------+------------+
```

Отлично, а теперь давайте посчитаем цену в евро.

Выведите идентификатор покупки, цену и вычисляемое поле: цена в евро. Для этого нужно столбец `price` разделить на `100`. 

Вам понадобятся столбцы `id` и `price` из таблицы `purchases`.

```sql
SELECT id, price, price / 100
FROM purchases
LIMIT 5;
```

```
+----+--------+-------------+
| id | price  | price / 100 |
+----+--------+-------------+
| 1  | 1530.0 | 15.3        |
| 2  | 340.0  | 3.4         |
| 3  | 370.0  | 3.7         |
| 4  | 340.0  | 3.4         |
| 5  | 340.0  | 3.4         |
+----+--------+-------------+
```

Наша СУБД поддерживает все классические арифметические операторы из других языков программирования: 

![02](/SQL_Data/img/02_12.png)

Стоит помнить, что порядок операций будет тот же, что и в математике. Представим ситуацию, что расходы на закуп выросли из-за курса валют и владелец онлайн-магазина решил поднять цены товаров на 10%*. Чтобы получить нужную цифру, мы можем произвести следующий подсчет: `price + price * 0,1`. В этом случае сначала выполнится умножение, а потом сложение. 

Как и в математике, при вычислении арифметических операций с помощью SQL можно пользоваться скобками. Такие операции будут производиться первыми, например в `(price + price * 0,1) / 75` выполнятся все выражения в скобках, а потом уже деление на 75.

>*Математическая формула расчета процентов (доли) выглядит так: (искомая часть / целое число) * 100.
>Чтобы найти процент от числа, применяется такой вариант формулы: (число * процент) / 100. Тогда 10% от цены будет: (цена * 10) / 100. Если дробь сократить, то можно записать решение таким образом: цена * 0,1.
>Чтобы получить цену на 10% больше можно использовать формулу: цена * 1,1 или просто добавить к цене 10%: цена + цена * 0,1. Мы использовали второй вариант в примере, чтобы показать порядок математических действий.

<hr>

[Содержание](#содержание)

## Оператор AS

Вы, наверно, уже заметили, что результатом выполнения запроса является таблица, у которой есть строки и столбцы, а у столбцов есть названия (имена). Наименования столбцов в результате запроса можно изменить. Это делается для того, чтобы при просмотре результата запроса сразу было понятно, что находится в той или иной колонке. Чтобы изменить имя столбца, используется ключевое слово AS. Например:

```sql
SELECT name AS user_names
FROM users;
```

Из таблицы `users` будет прочитано поле `name`, но при выводе результата поле будет отображаться с именем `user_names` . Оператор `AS` задает новое имя для столбца в выводе, но не меняет наименование столбца в изначальной таблице в базе данных.

Помните, мы выгружали данные для коллег из отдела маркетинга? Кажется, они поняли, что неправильно сформировали техническое задание* для нас, поэтому решили вернуться с новым.

Выведите из таблицы `users` имена всех пользователей, их электронную почту и дату рождения. А также добавьте в результат еще одно поле с именем `label`, которое будет содержать только запись «Для маркетинга».

Вам понадобятся столбцы `name`, `email`,  `birthday` из таблицы `users`.

>*Техническое задание или ТЗ — это документ, в котором фиксируются требования к задаче или проекту. ТЗ может быть в виде Word-файла, направленного на почту, или заявки в специальной программе — это зависит от принятых процессов внутри компании.

```sql
SELECT name,
       email,
       birthday,
       'Для маркетинга' AS label
FROM users;
```

<hr>

[Содержание](#содержание)

# 2.3 Выборка и сортировка данных: DISTINCT, ORDER BY и LIMIT

С запросами отдела маркетинга разобрались! Отлично! Давайте посмотрим, что там у нас осталось на сегодня из открытых задач*? Смотрите, к нам поступил запрос от отдела закупок. Коллеги попросили выгрузить варианты фасовки продуктов. Видимо, в дальнейшем они будут использовать эту информацию, чтобы заказать упаковку для продукции.

![02](/SQL_Data/img/02_13.png)

Выгрузите варианты фасовки продуктов. Для этого понадобится поле variant_name из таблицы purchases.

>*Обычно для оптимизации работы команды и отслеживания задач используются специальные программы: Jira, Service desk, Help desk и другие. Заказчики (в нашем случае это коллеги из других отделов) заводят задачу, т. е. создают страничку  или «тикет» с описанием, что нужно сделать, насколько это критично и срочно, и другими требованиями Как только задача появляется в системе, ей присваивается статус «Открыта». Когда один из сотрудников начинает работать с задачей, он переводит ее в статус «В работе». Финальным статусом задачи будет «Решено». Статусы и поток выполнения задач зависят от подходов в компании и могут отличаться. Зачастую в процессе выполнения требуется согласование или ответ от заказчика. Для таких действий иногда создаются отдельные статусы.

```sql
SELECT variant_name
FROM purchases;
```

<hr>

[Содержание](#содержание)

## Оператор DISTINCT

Варианты фасовок мы выгрузили, но не думаем, что коллегам будет удобно работать с этими данными из-за множества дублей:

![02](/SQL_Data/img/02_14.png)

Нужно подумать, как вывести только уникальные значения.

Одни из ключевых навыков аналитика данных — это самостоятельность и умение самостоятельно находить информацию. Не нужно пугаться, что чего-то не знаете. Всегда можно сначала поискать информацию в интернете, а затем обратиться за помощью к коллегам и наставнику.

Как насчет того, чтобы немного потренироваться? Поищите в интернете инструкцию, как использовать оператор `DISTINCT`. Для этого достаточно ввести в поисковую строку браузера запрос «оператор `DISTINCT` SQL». Данный оператор используется, чтобы оставить только уникальные значения в результате выполнения запроса. В следующем степе мы объясним синтаксис и принцип работы этого оператора. А сейчас попробуйте самостоятельно найти информацию в интернете и решить нашу задачу.

Выведите уникальные варианты фасовки продуктов. Для этого понадобится поле `variant_name` из таблицы `purchases`.


```sql
SELECT DISTINCT variant_name
FROM purchases;
```

```
+--------------+
| variant_name |
+--------------+
| 1 кг.        |
| 200 г.       |
| 1 шт.        |
| 100 г.       |
| 250 г.       |
| 1 уп.        |
| 500 г.       |
| 150 г.       |
+--------------+
```

Сработало? Если сразу разобраться не получилось, не расстраивайтесь! Просто старайтесь искать больше дополнительной информации по SQL в интернете по мере прохождения курса. Постепенно вы привыкнете к этому и научитесь разбираться в различных темах самостоятельно. А сейчас, как мы и обещали, расскажем про оператор `DISTINCT`.

Давайте вернемся на пару степов назад и вспомним, как мы выгружали для коллег из отдела закупок варианты фасовки продуктов:

```sql
SELECT variant_name
FROM purchases;
```

В результате запроса выше у нас получилось вывести на экран только одну колонку variant_name без всех остальных, но количество строк сохранилось: 

![02](/SQL_Data/img/02_15.png)

Выделенные серым столбцы не будут выведены на экран.

Согласитесь, не очень удобно, что остаются повторяющиеся значения или, проще говоря, дубли. Оператор DISTINCT (от английского distinct – «определенный», «индивидуальный», «отличимый») позволяет оставить только уникальные значения. Для этого нужно добавить его в запрос:

```sql
SELECT DISTINCT variant_name
FROM purchases;
```

То есть с помощью скрипта мы буквально говорим: выбери уникальные значения вариантов фасовки из столбца `variant_name` в таблице `purchases`. Оператор `DISTINCT` отсеивает дубли, мы получаем следующие данные:

![02](/SQL_Data/img/02_16.png)

Это как раз то, что нужно для отдела закупок. Можем смело отправлять им выгрузку и закрывать* задачу.

>*Закрытие задачи предполагает изменение её статуса в системе учёта задач на «Закрыто» или «Выполнено». В разных компаниях по-разному устроен процесс ведения задач; ещё он называется `workflow` (воркфлоу). Иногда после закрытия задачи автор может переоткрыть её, если недоволен результатом. В других случаях статус «Закрыто» является конечным статусом задачи.

Оператор `DISTINCT` можно применить к нескольким столбцам. Запрос будет выглядеть следующим образом:

```sql
SELECT DISTINCT название_столбца_1, название_столбца_2
FROM название_таблицы
```

А теперь, используя конструкцию запроса выше, найдите уникальные варианты фасовки и цену. Выведите иx именно в таком порядке, сначала вариант фасовки, затем цена.

Используйте столбцы `variant_name` и `price` из таблицы `purchases`.

```sql
SELECT DISTINCT variant_name,
       price 
FROM purchases;
```

А вот и новая задача! Коллеги из отдела по работе с клиентами хотят проанализировать, насколько часто стали регистрироваться посетители интернет-магазина после изменения дизайна регистрационной формы. Выведите для них имена пользователей с датой регистрации.

Вам понадобятся столбцы `name` и `created` из таблицы `users`.

Обратите внимание, что записи в результате запроса будут расположены в том порядке, в котором они изначально записаны в таблице.

```sql
SELECT DISTINCT name, created
FROM users
```

<hr>

[Содержание](#содержание)

## Оператор ORDER BY

В прошлом степе мы получили следующие данные: 

![02](/SQL_Data/img/02_17.png)

Согласитесь, для наглядности хочется, чтобы данные были отсортированы. Иногда при постановке задачи аналитику коллеги сразу уточняют, что хотят получить данные в уже отсортированном виде, иногда могут не уточнить. Так и в нашем случае: им удобнее сразу получить отсортированный по дате регистрации список пользователей, но они об этом не сказали. Так можно сразу увидеть первую и последнюю даты регистрации, дни, в которые пользователи чаще регистрировались, а также разделить пользователей на тех, кто зарегистрировался до введения новой формы регистрации и после.

Для сортировки данных есть специальный оператор ORDER BY. Он пишется в конце запроса, как показано на примере:

```sql
SELECT name, created
FROM users
ORDER BY created;
```

Cкопируйте запрос в поле ниже и нажмите «Отправить». Обратите внимание, как теперь отображаются данные — мы отсортировали их по дате регистрации в порядке возрастания. 

<hr>

[Содержание](#содержание)

## Прямой порядок сортировки

Прямой порядок сортировки, то есть от меньшего к большему или в алфавитном порядке, указывается с помощью дополнительного слова ASC (от англ. ascending — «возрастающий») после поля, по которому мы хотим сделать сортировку. Если нам захочется отсортировать записи в обратном порядке, то к полю, по которому мы сортируем результат, необходимо дописать слово DESC (от англ. descending — «убывающий»).

Если дополнительное слово не прописано, то порядок сортировки по умолчанию будет прямой, то есть запросы ниже выдадут одинаковый результат.

В явном виде указан прямой порядок сортировки с помощью ASC:

```sql
SELECT user_name, created
FROM users
ORDER BY created ASC
```

Прямой порядок сортировки по умолчанию:

```sql
SELECT user_name, created
FROM users
ORDER BY created
```

Давайте теперь возьмем все данные из таблицы пользователей (`users`) и отсортируем их по дате регистрации (`created`) в порядке убывания. Так, наверху выводимой таблицы мы получим самых новых пользователей. 

Для запроса используйте оператор `ORDER BY` и не забудьте про дополнительное слово `DESC`, которое как раз и указывает на сортировку в обратном порядке: 

```sql
ORDER BY наименование_столбца DESC
```

```sql
SELECT *
FROM users
ORDER BY created DESC;
```

<hr>

[Содержание](#содержание)

## Обратный порядок сортировки

Но что делать, если в поле, по которому мы сортируем результат, есть повторяющиеся значения? Например, мы решили отсортировать наших пользователей по имени в обратном порядке, то есть от Я до А:

```sql
SELECT *
FROM users
ORDER BY name DESC;
```

![02](/SQL_Data/img/02_18.png)

Пользователи с одинаковыми именами отобразятся в том же порядке, в котором они перечислены в базе данных. Если нам такой вариант не подходит, мы можем указать сразу несколько полей для сортировки результата.

Например, отсортируем всех наших пользователей в обратном порядке по имени и прямом порядке по дате рождения. Для этого просто через запятую укажем еще одно поле для сортировки и получим такой запрос:

```sql
SELECT *
FROM users
ORDER BY name DESC, birthday ASC;
```

По сути в таком случае делается две сортировки: cначала по столбцу `name`, а потом внутри каждой одинаковой группы имен — по столбцу `birthday`.  

![02](/SQL_Data/img/02_19.png)

Важно отметить еще один аспект оператора `ORDER BY`. Поле, которое используется для сортировки результата, не обязательно должно присутствовать в результате запроса (например, можно написать запрос, который выведет ТОЛЬКО имена наших клиентов в порядке даты их рождения, при этом сама дата рождения в результате будет отсутствовать).

​​​​​​Мы привели только небольшую часть данных в качестве примера. 

Выведите все данные из таблицы `products`. Отсортируйте данные по названию продуктов (`name`) по алфавиту и номеру (`id`) в обратном порядке, то есть от большего к меньшему.

```sql
SELECT *
FROM products
ORDER BY name, id DESC;
```

<hr>

[Содержание](#содержание)

## LIMIT

Нашим коллегам не всегда нужна выгрузка данных из всей таблицы, тем более таблицы могут содержать тысячи, а иногда и миллионы строк. В таком случае в задаче для аналитиков заказчик указывает, что ему необходимо, например, выгрузить топ-5 записей или записи с пятой по седьмую. Для вывода определённого количества записей используется оператор LIMIT, который указывается в конце запроса.

Коллеги хотят провести опрос среди новых клиентов, чтобы узнать, насколько простой для них была регистрация и заказ продуктов. Для этого им нужны данные 5 последних зарегистрировавшихся пользователей. Чтобы получить их, скопируйте запрос в поле ниже* и нажмите «Отправить». 

```sql
SELECT *
FROM users
ORDER BY created DESC
LIMIT 5;
```

*Обратите внимание, мы сделали сортировку по дате, чтобы самые новые пользователи оказались наверху таблицы. Оператор LIMIT отработает после ORDER BY. То есть LIMIT применится уже к отсортированным данным. Более подробно о порядке работы операторов в запросе мы расскажем в следующем уроке.

А вот и еще один запрос от коллег. Они хотят отправить купоны на покупку нашим 10 самым старым — то есть давно зарегистрировавшимся — пользователям.

Выведите 10 записей, отсортированных по дате регистрации в порядке возрастания, с именами пользователей, электронной почтой и датой регистрации.

Вам понадобятся столбцы `name`, `email` и `created` из таблицы users.

```sql
SELECT name, email, created
FROM users
ORDER BY created
LIMIT 10;
```

<hr>

[Содержание](#содержание)

## Как ещё можно использовать LIMIT? Бонусный степ

С помощью оператора `LIMIT` можно выводить определенные строки из середины таблицы. Например, с 3 по 6 включительно.

Для этого в операторе `LIMIT` через запятую нужно указать 2 числа. Первое — с какой строки выводить данные (нумерация начинается с нуля). Второе число указывает, сколько строк нужно вывести. Соответственно, если мы хотим вывести строки с 3 по 6 в конце запроса мы должны указать:

```sql
LIMIT 2, 4
```

2 — потому что нумерация начинается с 0.<br>
4 — потому что нам нужны четыре строки: 2-я, 3-я, 4-я, 5-я при нумерации с нуля. 

![02](/SQL_Data/img/02_20.png)

А теперь на основе предыдущего задания давайте выведем записи с 3-й по 6-ю, отсортировав их по дате регистрации в порядке убывания. Записи должны содержать имена пользователей, электронную почту и дату регистрации.

Вам понадобятся столбцы name, email и created из таблицы users.

```sql
SELECT name, email, created
FROM users
ORDER BY created DESC
LIMIT 2, 4;
```

<hr>

[Содержание](#содержание)

# 2.4 Порядок работы операторов в запросе

В одном из прошлых уроков мы уже разбирались, в каком порядке будут отрабатывать операторы в самом простом запросе:

```sql
SELECT name, birthday
FROM users;
```

В запросе выше первым выполнится оператор `FROM`, то есть перед тем как произвести выборку данных, сперва нужно определить таблицу, откуда эти данные взять. Затем уже отработает оператор `SELECT`:  c помощью него мы выбираем столбцы, которые хотим получить в выводе.

Но в каком же порядке будут выполняться операторы, если запрос более сложный?

Например, мы хотим вывести 10 самых новых продуктов, появившихся в интернет-магазине. Сам запрос будет выглядеть так:

```sql
SELECT name AS product_name, created AS added_date
FROM products
ORDER BY created
LIMIT 10;
```

В данном запросе у нас добавляется сортировка данных (`ORDER BY`) и ограничение на количество строк в выводе (`LIMIT`).

Как и в самом простом запросе, первым выполнится оператор `FROM`. То есть, если изначально не определить таблицу, то не будет данных, с которыми смогут работать остальные операторы.
Затем выполнится оператор `SELECT`. Обратите внимание, что в нем мы не только выбираем столбцы для вывода, но и задаем им новые имена при помощи оператора `AS`.
Далее выполняется сортировка с помощью оператора `ORDER BY`.
Последним отработает оператор `LIMIT`. Благодаря тому, что этот оператор выполняется уже после сортировки, мы можем вывести топ-10 новых продуктов.

![02](/SQL_Data/img/02_21.png)

Теперь, когда мы разобрались, в каком порядке отрабатывают операторы, расскажем об одной интересной особенности сортировки: в `ORDER BY` можно указывать названия столбцов, которые мы задали с помощью `AS`. Например:

```sql
SELECT name AS product_name, created AS added_date
FROM products
ORDER BY added_date
LIMIT 10;
```

Это возможно благодаря тому, что оператор `ORDER BY` отрабатывает после оператора `SELECT`. После того как отработал `SELECT`, к столбцу `created` можно обращаться, как к `added_date`. Получается, в сортировке мы уже можем указать новое имя столбца `added_date`. 

Еще один интересный вопрос: что же отработает раньше — `SELECT` или `DISTINCT`?

Помните задачу про уникальные варианты фасовки продуктов? 

```sql
SELECT DISTINCT variant_name
FROM purchases;
```

Как обычно, `FROM` сработает первым: находим таблицу purchases, из которой будем брать данные. А вот дальше отработает `SELECT`, то есть предварительно нужно отобрать столбцы, по которым мы хотим получить уникальные значения. Если программа этого не сделает, то уникальные значения посчитаются в разрезе всех столбцов, что даст неверный результат. В конце с помощью `DISTINCT` отберутся уникальные значения.

<hr>

[Содержание](#содержание)

# 2.5 Практика

Отлично! Вы познакомились с основами — пора проверить, насколько хорошо вы все запомнили. В этом уроке вас ждут задания на повторение пройденного материала. Постарайтесь решить задачи, не подглядывая в подсказки. Напоминаем, что описание таблиц можно посмотреть в [документации](https://docs.google.com/document/d/10e3ZCCFgRxPa8-WnvEgzDvzVBtIM9sd-/edit#heading=h.gjdgxs).

![02](/SQL_Data/img/02_22.png)

<hr>

[Содержание](#содержание)
