# 6. Соединение таблиц

## Содержание

+ [6.1 Ключи и связи](#61-ключи-и-связи)
+ [6.2 INNER JOIN](#62-inner-join)
+ [6.3 LEFT JOIN, RIGHT JOIN](#63-left-join-right-join)
+ [6.4 FULL JOIN](#64-full-join)
+ [6.5 Практика](#65-практика)

[Оглавление](/SQL_Data/README.md)

# 6.1 Ключи и связи

Отличная работа! Вы прошли непростую, но очень важную тему. Теперь вы умеете применять подзапросы! Далее в модуле мы познакомимся со специальными операторами, с помощью которых можно соединять таблицы. Ведь довольно часто в работе встречаются задачи, в которых для выгрузки и расчетов нужны поля из нескольких таблиц.

Мы расскажем вам про то, какие бывают связи между таблицами и как они могут быть организованы. В этом уроке не будет заданий на написание SQL-запросов, но он очень важен, чтобы понять, когда и какой оператор для соединения таблиц применять.

![06](/SQL_Data/img/06_01.png)

## Первичный ключ

Напоминаем, что записью в таблице называют строку. Для примера ниже представлена запись из таблицы `orders`:

![06](/SQL_Data/img/06_02.png)

Каждая запись таблицы содержит значения нескольких полей. Например, таблица `orders` содержит заказы, каждый из которых характеризуется значениями полей:

+ `delivery_price`
+ `paid`
+ `user_id`
+ `date`
+ `address`
+ `total_price`
+ `coupon_id`

Но как в таком случае найти определенный заказ? Конечно, можно просмотреть все поля, но это неудобно и долго, и особенно неэффективным такой подход становится, когда записей в таблице становится очень много. Для решения таких задач в теории баз данных существуют **первичные ключи** таблицы.

**Первичный ключ (primary key, PK)** — это одно или несколько полей, которые используются для обеспечения уникальности данных в таблице. Каждое значение первичного ключа **не повторяется** в рамках таблицы. Он всегда идентифицирует определенную запись в таблице (то есть отличает ее от других). Другими словами, **каждому значению первичного ключа будет соответствовать только одна запись**.

<hr>

[Содержание](#содержание)

## Простой и составной первичный ключ

Если в качестве первичного ключа было выбрано **одно поле**, то такой ключ называется **простым**. Например, всё в той же таблице заказов за уникальность записи отвечает поле `id`. Нет ни одной записи, где бы оно повторялось.

![06](/SQL_Data/img/06_03.png)

На самом деле, первичные ключи всех таблиц в нашем курсе простые и являются полем `id`. 

А теперь давайте представим ситуацию, что в таблице заказов нет поля `id`. Ниже пример. Обратите внимание, что мы поменяли тип данных в поле `date` с `date` на `timestamp`*. 

![06](/SQL_Data/img/06_04.png)

Что же тогда можно использовать в качестве первичного ключа? Ведь ни одно поле по отдельности не обеспечивает уникальность. В таком случае можно выбрать несколько полей сразу — такой ключ называется составным. Бывают даже таблицы, где уникальность записи определяется всеми полями таблицы.

Комбинация `user_id` и `date` для каждого заказа будет уникальна, ведь пользователь может за один момент времени совершить только один заказ. Именно для этого мы поменяли тип данных в поле `date` на `timestamp`. За день можно сделать несколько заказов, но с учетом секунд и миллисекунд — только один. 

Какие поля будут использованы в качестве первичного ключа и какой тип данных будет у этих полей, определяется перед созданием таблицы. Иногда для этого требуется отдельный анализ.

*`Timestamp` — дата и время с точностью до миллисекунд.

<hr>

[Содержание](#содержание)

## Естественный и искусственный первичные ключи

**Естественным** или **бизнес-ключом** называется первичный ключ, то есть поле или набор полей, которые **естественным** образом существует в таблице. Ярким примером в рамках интернет-магазина может выступать электронная почта пользователя, которая в большинстве случаев является также и логином.

При создании таблицы orders мы поступили немного хитрее и создали поле id, в котором хранятся последовательные номера записей. По сути, это поле не содержит никакой информации о заказе из реальной жизни, но оно однозначно идентифицирует каждую запись. Такой первичный ключ называется **искусственным** или **суррогатным**.

![06](/SQL_Data/img/06_05.png)

<hr>

[Содержание](#содержание)

## Внешние ключи

Если в таблице есть поле (или несколько полей), которое ссылается на первичный ключ другой таблицы, то такое поле называется **внешним ключом (foreign key, FK)**. Внешний ключ нужен, чтобы связать две таблицы между собой. В таблицах, с которыми вы работали, есть достаточно примеров. Давайте рассмотрим один из них, чтобы стало понятнее.

В таблице brands мы определили суррогатный первичный ключ по полю `id`. В это же время в таблице `products` есть поле `brand_id`, которое является **внешним ключом** и ссылается на поле `id` таблицы `brands`. 

Вот так выглядит таблица `brands`: 

![06](/SQL_Data/img/06_06.png)

А вот так выглядит таблица `products`:

![06](/SQL_Data/img/06_07.png)

Для наглядности возьмем первую запись из таблицы `products`. Мы видим, что в поле `brand_id` указан номер `4`. Идем в таблицу `brands` и видим, что под `id` `4` у нас «Колумбия». 

![06](/SQL_Data/img/06_08.png)

<hr>

[Содержание](#содержание)

## Виды связей между таблицами. Один-ко-многим

Внешние ключи нужны для создания логической связи между таблицами. Продолжая пример из предыдущего степа, можно сказать, что по внешнему ключу `brand_id` из таблицы `products` мы можем найти название бренда для каждого продукта в таблице `brands`. Связь описанных таблиц можно изобразить в виде схемы: 

![06](/SQL_Data/img/06_09.png)

Представленный вид связи называется один-ко-многим, потому что одной записи из таблицы `brands` соответствует несколько записей из таблицы `products`. То есть, например, у нас может быть несколько продуктов бренда «Колумбия», при этом в таблице брендов «Колумбия» представлена только одним `id` — 4.

Обратите внимание на то, что один конец линии связи похож на крест, а другой — на гусиную лапку. Именно такое обозначение показывает, что в родительской таблице `brands` только одна строка соответствует каждому значению `id`, а в дочерней таблице `products` несколько записей могут иметь одно и то же значение поля `brand_id`. При этом поле `id` таблицы `brands` и поле `brand_id` таблицы `products` содержат **одинаковую информацию** о бренде.

Хоть один-ко-многим и является самым популярным видом связи между таблицами, он не единственный. Существуют также другие виды связи: **один-к-одному** и **многие-ко-многим**. 

Небольшой тест на понимание предыдущего степа.

Выберите из списка все примеры связи один ко многим:


+ [x] Таблицы children (в ней хранятся имена детей из детского сада для многодетных семей) и parents (в ней хранятся имена родителей детского сада для многодетных семей) связаны между собой через поле с номером ребенка: children.child_id и parents.child_id
+ [x] Таблицы employees (в ней хранятся все имена сотрудников, которые работают только в 1 отделе) и department (в ней хранятся все известные отделы фирмы) связаны между собой через поле с номером отдела: employees.department_id и department.department_id
+ [ ] Таблицы wifes (в ней хранятся имена замужних женщин) и husbands (в ней хранятся имена женатых мужчин) связаны между собой либо полем с номером телефона мужа: husbands.phone_number и wifes.husband_phone_number; либо полем с номером телефона жены wifes.phone_number и husbands.wife_phone_number
+ [ ] Таблицы classes (в ней хранятся все курсы университета) и students (в ней хранятся имена студентов университета) связаны через промежуточную таблицу classes_students при помощи 2 связей: через поле с номером студента (students.id и classes_students.student_id) и через поле с номером курса (classes.id и classes_students.class_id)
+ [ ] Таблицы disks (в ней хранятся все доступные на складе диски) и hardware (в ней хранится все оборудование на складе) связаны между собой полями с серийным номером: disks.serial_number и hardware.serial_number

<hr>

[Содержание](#содержание)

## Виды связей между таблицами. Один-к-одному

Примером связи один-к-одному может служить связь между таблицами* сотрудников и их автомобилей: первичным ключом в таблице с автомобилями будет регистрационный номер автомобиля (например, к500ае), а в таблице с сотрудниками поле с такими же номерами будет внешним ключом.

По правилам на одного сотрудника полагается только одно парковочное место и, соответственно, в базе данных может быть зарегистрирован только один автомобиль для каждого. Одной записи из таблицы с сотрудниками будет соответствовать одна запись в таблице с их автомобилями. 

![06](/SQL_Data/img/06_10.png)

>*Связь один-к-одному мы объясняем на примере дополнительных таблиц, которых не было в курсе.

Небольшой тест на понимание предыдущего степа.

Выберите из списка все примеры связи один к одному:


+ [ ] Таблицы employees (в ней хранятся все имена сотрудников, которые работают только в 1 отделе) и department (в ней хранятся все известные отделы фирмы) связаны между собой через поле с номером отдела: employees.department_id и department.department_id
+ [ ] Таблицы children (в ней хранятся имена детей из детского сада для многодетных семей) и parents (в ней хранятся имена родителей детского сада для многодетных семей) связаны между собой через поле с номером ребенка: children.child_id и parents.child_id
+ [ ] Таблицы classes (в ней хранятся все курсы университета) и students (в ней хранятся имена студентов университета) связаны через промежуточную таблицу classes_students при помощи 2 связей: через поле с номером студента (students.id и classes_students.student_id) и через поле с номером курса (classes.id и classes_students.class_id)
+ [x] Таблицы wifes (в ней хранятся имена замужних женщин) и husbands (в ней хранятся имена женатых мужчин) связаны между собой либо полем с номером телефона мужа: husbands.phone_number и wifes.husband_phone_number; либо полем с номером телефона жены wifes.phone_number и husbands.wife_phone_number
+ [x] Таблицы disks (в ней хранятся все доступные на складе диски) и hardware (в ней хранится все оборудование на складе) связаны между собой полями с серийным номером: disks.serial_number и hardware.serial_number

<hr>

[Содержание](#содержание)

## Виды связей между таблицами. Многие-ко-многим

Один из классических примеров связи многие-ко-многим* — связь между сотрудниками и номерами телефонов. У одного человека может быть несколько номеров: рабочий, мобильный и так далее. В то же время сотрудники колл-центра работают сменами, и получается, один номер рабочего телефона может принадлежать нескольким людям. 

Для реализации связи многие-ко-многим потребуется дополнительная промежуточная таблица с двумя полями: id сотрудника и номер телефона. В таком случае получится следующая схема: 

![06](/SQL_Data/img/06_11.png)

В таблице с сотрудниками содержится информация о персонале, а в таблице с телефонами — информация о номерах. Промежуточная таблица нужна для того, чтобы показать связь между сотрудниками и номерами телефонов. 

Обратите внимание, что в средней таблице комбинация полей id_сотрудника и номер_телефона является уникальной, то есть может быть использована как первичный ключ. С другой стороны, каждое из этих полей является внешним ключом, организующим связь с другой таблицей. 

>*Связь многие-ко-многим мы объясняем на примере дополнительных таблиц, которых не было в курсе.

Небольшой тест на понимание предыдущего степа.

Выберите из списка все примеры связи один ко многим:

+ [ ] Таблицы disks (в ней хранятся все доступные на складе диски) и hardware (в ней хранится все оборудование на складе) связаны между собой полями с серийным номером: disks.serial_number и hardware.serial_number
+ [ ] Таблицы wifes (в ней хранятся имена замужних женщин) и husbands (в ней хранятся имена женатых мужчин) связаны между собой либо полем с номером телефона мужа: husbands.phone_number и wifes.husband_phone_number; либо полем с номером телефона жены wifes.phone_number и husbands.wife_phone_number
+ [x] Таблицы classes (в ней хранятся все курсы университета) и students (в ней хранятся имена студентов университета) связаны через промежуточную таблицу classes_students при помощи 2 связей: через поле с номером студента (students.id и classes_students.student_id) и через поле с номером курса (classes.id и classes_students.class_id)
+ [ ] Таблицы children (в ней хранятся имена детей из детского сада для многодетных семей) и parents (в ней хранятся имена родителей из детского сада для многодетных семей) связаны между собой через поле с номером ребенка: children.child_id и parents.child_id
+ [ ] Таблицы employees (в ней хранятся все имена сотрудников, которые работают только в 1 отделе) и department (в ней хранятся все известные отделы фирмы) связаны между собой через поле с номером отдела: employees.department_id и department.department_id

<hr>

[Содержание](#содержание)

## Обязательность связей. Бонусный степ

Когда мы описывали связь один-к-одному, у вас мог возникнуть резонный вопрос: какое значение будет записано во внешнем ключе у сотрудника без автомобиля?

Из-за того, что у этих сотрудников нет автомобиля, во внешнем ключе не получится указать номер машины, как мы это сделали у остальных. Вместо номера автомобиля у таких сотрудников записывается просто `NULL`, ведь он обозначает отсутствие значения. Получается, что для какого-то сотрудника **необязательно** найдется автомобиль в соответствующей таблице. Это называется **один-к-одному с необязательной связью**.

Иногда в таблицу автомобилей заносят номера авто не принадлежащих работникам, например, если это автомобиль гостя, который получил пропуск на парковку — его (гостя) уже не будет в базе сотрудников. 

По аналогии можно сказать, что не всегда у нас есть товары определенного бренда, говоря о связи **один-ко-многим с необязательной связью**. 

Со связью **многие-ко-многим** ситуация обстоит проще — она всегда необязательная. Если сотруднику еще не присвоен номер телефона, то просто в промежуточной таблице просто не будет записи с ним. То же самое с номерами телефонов, которые еще ни за кем не закрепили.

Такие связи обозначаются так: черта перед крестом или гусиной лапкой заменяется на окружность.

![06](/SQL_Data/img/06_12.png)

Окружность ставится со стороны той таблицы, в которой необязательно должно быть значение, на которое ссылается другая таблица. Возвращаясь к примеру с автомобилями и сотрудниками, скажем, что в таблице с машинами записаны только автомобили сотрудников, то есть в ней не найдется таких машин, которые принадлежат не сотрудникам. В таком случае схема связи будет следующей:

![06](/SQL_Data/img/06_13.png)

<hr>

[Содержание](#содержание)

# 6.2 INNER JOIN

Теперь, когда мы разобрались с видами связей между таблицами, можно приступать к практической части. В этом модуле мы рассмотрим, как с помощью запроса можно соединять таблицы с учетом связей между ними.

Для того, чтобы было понимание того, какие связи присутствуют в нашей базе данных, нарисуем `ER-диаграмму`*, отражающую связи между имеющимися таблицами.

![06](/SQL_Data/img/06_14.png)

Особенность нашей базы состоит в том, что все связи имеют **тип один-ко-многим с обязательной связью**. Также стоит отметить тот факт, что в каждой таблице в качестве первичного ключа используется суррогатный ключ, то есть просто возрастающий номер `id`. 

*`ER (Entity Relationship)`-диаграмма представляет собой модель взаимосвязей между объектами. В рамках предварительного анализа данных всегда изучайте имеющиеся таблицы в базе данных и взаимосвязи в используемых таблицах, то есть учитывайте, куда ссылаются внешние ключи. Это важно, иначе можно составить неверный запрос и получить в результате некорректную выборку.

<hr>

[Содержание](#содержание)

## Соединение таблиц. INNER JOIN

Одним из наиболее распространенных операторов соединения является `INNER JOIN`. С помощью `INNER JOIN` происходит объединение записей из двух таблиц по какому-то условию, обычно по связующему полю. В результирующую выборку попадают только те записи, которые удовлетворяют условию.

В запросе оператор `INNER JOIN` ставится после оператора `FROM`, при этом необходимо указать еще и условие соединения таблиц после указателя `ON`. Давайте подробнее рассмотрим на примере запроса ниже: выведем товары и название их бренда. 

```sql
SELECT products.name AS prod_name, brands.name AS brand_name
FROM products
INNER JOIN brands ON brands.id = products.brand_id;
```

Результатом данного запроса будет выборка (дан пример части данных):

![06](/SQL_Data/img/06_15.png)

Теперь давайте разберем запрос. Перед этим вспомним схему связи между таблицами products и brands (связь один-ко-многим).

![06](/SQL_Data/img/06_16.png)

В данном запросе мы соединяем таблицы `products` и `brands` по условию `brands.id = products.brand_id`. Логически соединение будет происходить построчно, и в выборку попадут только те записи, где внешний ключ `brand_id` из таблицы products соответствуют первичному ключу `id` из таблицы `brands`:

```sql
ON brands.id = products.brand_id;
```

![06](/SQL_Data/img/06_17.png)

Обратите внимание, так как и в `products` , и в `brands` есть поле с одинаковым названием — `id`, то в запросе обязательно нужно указать, из какой таблицы его брать. Для этого достаточно написать через точку название таблицы перед наименованием поля: `brands.id`. C помощью оператора `AS` можно задать псевдоним для таблицы, а потом применять уже его. В качестве псевдонима таблицы можно выбрать более короткое или говорящее название. Это удобно при указании необходимых полей и в операторе `SELECT` , и при соединении таблиц, поскольку они могут содержать поля с одинаковыми именами, но с разными данными. Например, поле `id` в таблице `brands` отличается от поля `id` в таблице `products`. Обратиться к полю таблицы в таком случае можно при помощи добавления через точку **псевдонима** таблицы перед именем поля:

```sql
SELECT p.name AS prod_name, b.name AS brand_name
FROM products AS p
INNER JOIN brands AS b ON b.id = p.brand_id;
```

Результат запроса не поменяется, если таблицы в операторах `FROM` и `INNER JOIN` указать в другом порядке, также можно не указывать оператор `AS`, когда задаете псевдоним для таблицы. То есть запрос ниже вернет те же данные:

```sql
SELECT p.name AS prod_name, b.name AS brand_name
FROM brands b
INNER JOIN products p ON b.id = p.brand_id;
```

Теперь давайте разберем ситуацию, что же будет, если в таблице продуктов указан несуществующий `id` бренда. Сам запрос возьмем из предыдущего степа:

```sql
SELECT p.name AS prod_name, b.name AS brand_name
FROM products AS p
INNER JOIN brands AS b ON b.id = p.brand_id;
```

С помощью оператора `INNER JOIN `мы соединяем 2 таблицы, чтобы соотнести каждый продукт с соответствующим названием бренда. Соединение таблиц происходит по номеру, который хранится в поле `brand_id` в таблице `products` и `id` в таблиц `brands`.

![06](/SQL_Data/img/06_18.png)

Обратите внимание, что в столбце `brand_id` есть номер `49`, которого нет в столбце `id` таблицы `brands`. Получается, для этой записи условие `b.id = p.brand_id` не выполнится, и она не попадет в результирующую выборку:

![06](/SQL_Data/img/06_19.png)

<hr>

[Содержание](#содержание)

## Использование псевдонима таблицы

Также еще раз рассмотрим запрос из предыдущих степов, только немного его изменим: выведем все данные из таблицы `products` и только столбец `name` из таблицы `brands`.

```sql
SELECT p.id, p.brand_id, p.name, b.name 
FROM products p
INNER JOIN brands b ON b.id = p.brand_id;
```

Согласитесь, иногда не очень удобно перечислять все столбцы таблицы, особенно если их много. В этом случае можно использовать символ «*», но чтобы запрос отработал, нужно вместе с ним написать через точку псевдоним таблицы. Давайте перепишем запрос выше:

```sql
SELECT p.*, b.name 
FROM products p
INNER JOIN brands b ON b.id = p.brand_id;
```

В результате запроса мы выводим все поля из таблицы `products` при помощи псевдонима таблицы и символа `*`, а также название бренда (поле `name`) из таблицы `brands` (для этого также используем псевдоним таблицы).

Тот же способ можно использовать, если вы хотите вывести какой-нибудь столбец таблицы первым, а затем все остальные данные:

```sql
SELECT o.date, o.* 
FROM orders o;
```

Теперь пришло время применить полученные знания для решения боевых задачек. Одна как раз поступила от отдела закупок.

Выведите все данные из таблицы покупок (purchases) и название продукта из таблицы products. Отфильтруйте данные так, чтобы количество  купленных единиц товара было равно 2. Внимание, порядок полей важен.

```sql
SELECT pur.*, prod.name
FROM purchases pur JOIN products prod ON pur.product_id = prod.id
WHERE pur.amount = 2
```

<hr>

[Содержание](#содержание)

## Соединение таблиц. INNER JOIN. Бонусный степ

Уверены, что с предыдущим степом вам удалось справиться. Вот так выглядит правильный ответ:

```sql
SELECT pur.*, p.name
FROM purchases pur
INNER JOIN products p ON p.id = pur.product_id
WHERE pur.amount = 2;
```

Логика запроса проста: сначала соединяем таблицу `purchases` с таблицей `products` по внешнему ключу `product_id`, а затем отфильтровываем все записи, у которых поле amount равно 2. Однако, соединение с помощью оператора `INNER JOIN` может проводиться по нескольким условиям. Давайте перепишем запрос, указав в соединении комбинацию двух условий, связанных при помощи логического оператора `AND`:

```sql
SELECT pur.*, p.name
FROM purchases pur
INNER JOIN products p ON p.id = pur.product_id
                         AND pur.amount = 2;
```

В этом случае фильтрация по полю `amount` из таблицы `purchases` будет производиться при соединении таблиц*.

>*Пока что мы рекомендуем выносить условия, которые не относятся к логике соединения таблиц, в оператор `WHERE`, это поможет не путаться первое время

<hr>

[Содержание](#содержание)

## Соединение таблиц. CROSS JOIN. Бонусный степ

В SQL существует оператор соединения `CROSS JOIN`*, который соединяет каждую строку одной таблицы с каждой строкой второй таблицы. Такое соединение называется декартово произведение. 

В качестве примера рассмотрим таблицы `brands` и `products`. 

Вот так выглядят записи таблицы `brands`: 

![06](/SQL_Data/img/06_20.png)

А так выглядят записи таблицы products: 

![06](/SQL_Data/img/06_21.png)

Конструкция оператора `CROSS JOIN` немного отличается от других соединений. Здесь не нужно указывать условие соединения, так как все строки соединяются друг с другом:

```sql
SELECT * 
FROM brands
CROSS JOIN products;
```

Результат выполнения такого запроса будет содержать 646 записей, потому что для каждой записи таблицы `brands`, которая содержит 17 записей, нужно подобрать в пару каждую из записей таблицы `products`, которая содержит 38 записей. Отсюда и получается число 648, которое равно произведению 17 и 38.

Результат получился слишком большим, мы приведем только первые записи:

![06](/SQL_Data/img/06_22.png)

Первые 2 поля результата — это поля `id` и `name` из таблицы `brands`, а оставшиеся 3 — это поля `id`, `brand_id` и `name` из таблицы `products`. Каждая запись результата представляет собой возможную пару одной из записей из таблицы `brands` и из таблицы `products`. 

Также можно заметить, что если бы мы поменяли таблицы местами, то результат запроса получился бы точно таким же. Тут можно провести аналогию с простым умножением чисел: если поменять местами два множителя, то произведение не изменится. Таким образом запрос ниже вернет идентичный результат.

```sql
SELECT * 
FROM products
CROSS JOIN brands;
```

*На практике данный оператор используется достаточно редко. Мы рассказываем о нем в этом курсе для общей информации.

А теперь подумайте о том, что запрос с `INNER JOIN` можно переписать при помощи `CROSS JOIN` и `WHERE`.

Например, возьмем такой запрос:

```sql
SELECT pur.*, p.name
FROM purchases pur
INNER JOIN products p ON p.id = pur.product_id;
```

В запросе мы соединяем 2 таблицы при помощи `INNER JOIN` с условием. Но этот же запрос можно переписать следующим образом:

```sql
SELECT pur.*, p.name
FROM purchases pur
CROSS JOIN products p 
WHERE p.id = pur.product_id;
```

Результат будет один и тот же, но переписанный запрос может помочь взглянуть на соединение таблиц с другой стороны. Такой подход очень удобен, когда непонятно, сколько записей получится в результате соединения, особенно если соединение происходит не по первичному ключу. 

Обратите внимание, что все равно правильнее использовать `INNER JOIN`. Во-первых, в СУБД для этого оператора реализованы специальные алгоритмы, которые оптимизируют запрос при выполнении. Во-вторых, такой запрос проще понимать, ведь условие соединения не сливается с другими фильтрами. 

Теперь давайте потренируемся в написании запросов.

Отдел доставки хочет, чтобы мы узнали среднюю стоимость доставки всех вариантов фасовки товара под номером 3. Результат округлите до целого при помощи функции `ROUND`.

Выведите вариант фасовки и округленную среднюю цену. Поля назовите `variant_name` и `avg_delivery_price` соответственно.

Для этого используйте таблицы `orders` и `purchases`. Не забудьте отфильтровать данные по номеру товара (поле `product_id` из таблицы `purchases`), а также сгруппировать по типу фасовки (поле `variant_name` из таблицы `purchases`).

```sql
SELECT p.variant_name AS variant_name,
       ROUND(AVG(o.delivery_price)) AS avg_delivery_price
FROM orders o INNER JOIN purchases p ON o.id = p.order_id
WHERE p.product_id = 3
GROUP BY 1;
```

На этот раз команда клиентского опыта хочет, чтобы мы выгрузили для них все заказы, в которых был применен промокод, который использовался не более 2 раз. Выведите только номер заказа и промокод, который был использован.

Используйте таблицы `orders` и `coupons`, отфильтруйте данные по количеству использований промокода (поле usages таблицы `coupons`). В результате выведите только поля `id` таблицы `orders` и `code` таблицы `coupons`. Используйте псевдонимы `order_id` и `coupon_code`.

```sql
SELECT o.id AS order_id,
       c.code AS coupon_code
FROM orders o INNER JOIN coupons c ON o.coupon_id = c.id
WHERE c.usages <= 2
```

<hr>

[Содержание](#содержание)

# 6.3 LEFT JOIN, RIGHT JOIN

Вы познакомились с одним из важнейших операторов INNER JOIN и основными принципами соединения таблиц. Давайте рассмотрим еще несколько операторов соединения, которые могут пригодиться в том случае, когда между таблицами необязательная связь. 

Все связи в нашей базе являются обязательными, и из-за это для связи таблиц в запросе достаточно оператора INNER JOIN. Но давайте представим, будто маркетологи решили, что необходимо начать продавать брендированную одежду. Такой подход повысит узнаваемость нашего магазина и привлечет новых клиентов. Они заранее попросили нас добавить в табличку brands новый бренд с наименованием «Одежда», но пока не успели создать первый прототип. 

После того, как мы вставим новый бренд в таблицу brands, она будет выглядеть вот так: 

![06](/SQL_Data/img/06_23.png)

При этом в таблице `products` пока нет ни одной позиции с номером бренда `18`, то есть между таблицей `products` и `brands` теперь связь **один-ко-многим с необязательной связью** со стороны таблицы `brands`.

## Соединение таблиц. LEFT JOIN

Теперь, если соединить таблицы `brands` и `products` при помощи оператора `INNER JOIN` с условием `b.id = p.brand_id`, новый бренд под номером `18` не попадет в результат соединения, ведь в таблице `products` нет ни одного продукта с таким `id` бренда.

```sql
SELECT
      b.id as brand_id,
      b.name as brand_name,
      p.id product_id,
      p.brand_id,
      p.name as product_name
FROM brands b
INNER JOIN products p ON b.id = p.brand_id;
```

Соединение при помощи оператора `INNER JOIN` не отражает необязательность участия некоторых записей таблицы `brands` в организации связи с таблицей `products`. Для запросов, которым важен такой тип связи, существует специальный оператор `LEFT JOIN`.

Его синтаксис точно такой же, как у оператора `INNER JOIN`, но логика немного отличается. Оператор `LEFT JOIN` соединяет две таблицы, но если в таблице, которая указана в запросе слева от оператора, например, `FROM brands LEFT JOIN products`, есть записи, которые необязательно участвуют в организации связи, то такие записи попадут в результат соединения. Проще говоря, в результирующую выборку попадут все записи из таблицы, что указана слева от оператора `LEFT JOIN`. В нашем примере это записи из таблицы `brands` — и те из них, что соответствуют условию соединения из таблицы справа. Соответственно порядок, в котором соединяются таблицы, важен. 

Давайте перепишем запрос и посмотрим, каким будет результат:

```sql
SELECT
    b.id as brand_id,
    b.name as brand_name,
    p.id product_id,
    p.brand_id,
    p.name as product_name
FROM brands b
LEFT JOIN products p ON b.id = p.brand_id;
```

**Результат выполнения запроса**

![06](/SQL_Data/img/06_24.png)

Как мы писали выше, в выборку попали все записи из таблицы, что указана слева от оператора `LEFT JOIN`, то есть из `brands`. Обратите внимание на последнюю строку. Появилась запись с новым номером бренда, под которым пока нет ни одного продукта. У этой записи все поля, которые относятся к таблице `products`, заполнены значением `NULL`. 

Теперь вы знаете, откуда взялось название нашего канала LEFT JOIN в Telegram 

<hr>

[Содержание](#содержание)

## Соединение таблиц. RIGHT JOIN

Есть одна очень важная деталь, касающаяся оператора `LEFT JOIN`: нужно учитывать порядок, в котором соединяются таблицы. Если поменять их местами и написать такой запрос, то результат будет точно такой же, как и при использовании оператора `INNER JOIN`: 

```sql
SELECT
    b.id as brand_id,
    b.name as brand_name,
    p.id product_id,
    p.brand_id,
    p.name as product_name
FROM products p
LEFT JOIN brands b ON b.id = p.brand_id;
```

Результат выполнения запроса

![06](/SQL_Data/img/06_25.png)

В таком случае таблицей слева от `LEFT JOIN` будет `products`, а у нее все записи участвуют в организации связи. 

Для того, чтобы в результат попали все записи из правой таблицы, можно использовать оператор соединения `RIGHT JOIN`. По сути это аналог оператора `LEFT JOIN`, только для запросов, у которых таблица с необязательной связью находится справа от оператора.

Запросы, которые представлены ниже, вернут абсолютно одинаковый результат.

```sql
SELECT
    b.id as brand_id,
    b.name as brand_name,
    p.id product_id,
    p.brand_id,
    p.name as product_name
FROM brands b
LEFT JOIN products p ON b.id = p.brand_id;
```

```sql
SELECT
    b.id as brand_id,
    b.name as brand_name,
    p.id product_id,
    p.brand_id,
    p.name as product_name
FROM products p
RIGHT JOIN brands b ON b.id = p.brand_id;
```

Результат выполнения запросов

![06](/SQL_Data/img/06_26.png)

Отдел закупок требует от нас выгрузку всех товаров с названиями их брендов. Задачка несложная, но есть нюанс...

В нашей базе произошел сбой: новые товары были добавлены в таблицу `products` с новым брендом, но этот бренд не был записан в таблицу `brands`. Пока инженеры исправляют проблему, выведите все товары с названием бренда, даже те, у которых он не указан. В таблице `products` вам понадобятся все поля, а в таблице `brands` — только `name`, ему присвойте псевдоним `brand_name`.

```sql
SELECT p.*, b.name AS brand_name
FROM products p LEFT JOIN brands b ON p.brand_id = b.id
```

Отлично! Теперь давайте посчитаем для коллег из отдела продаж количество проданных товаров. В таблице `products` все еще есть продукты с брендом, который отсутствует в таблице `brands`, про них тоже не забудьте.

Выведите имя продукта, имя его бренда и количество проданных единиц этого продукта. В этой выгрузке вам понадобятся таблицы `products`, `brands` и `purchases`. Имя бренда выведите в результате с псевдонимом `brand_name`, количество проданного товара с именем `cnt_sold`. Результат отсортируйте по возрастанию количества проданной продукции.

>Хорошо подумайте, какую агрегатную функцию нужно использовать для подсчета количества единиц проданного товара! Обозначение cnt_ в превдониме мы используем, чтобы отобразить бизнес-смысл будущего поля — общее количество.

```sql
SELECT prod.name,
       b.name AS brand_name,
       SUM(amount) AS cnt_sold      
FROM products prod LEFT JOIN purchases pur ON prod.id = pur.product_id
                   LEFT JOIN brands b ON prod.brand_id = b.id
GROUP BY prod.name, b.name
ORDER BY cnt_sold;
```

<hr>

[Содержание](#содержание)

# 6.4 FULL JOIN

Вы отлично справляетесь! Осталось совсем немного до финального задания в 7-м модуле.

Хотелось бы рассказать, что на практике наиболее часто используемые операторы соединения — это `INNER JOIN` и `LEFT JOIN`, также достаточно часто используется `FULL JOIN`. С этим оператором вы познакомитесь в следующих степах.

![06](/SQL_Data/img/06_27.png)

<hr>

[Содержание](#содержание)

## Соединение таблиц. FULL JOIN

Представим, что в нашем магазине появилась возможность купить лимонад, но руководство компании пока не определилось, под каким брендом его продавать, и записало в поле `brand_id` в таблице продуктов (`products`) значение  «0». Но в таблице `brands` нумерация брендов начинается с  «1», то есть у таблицы `products` теперь тоже не все записи обязательно участвуют в связи таблиц `products` и `brands`.

В таком случае ни `LEFT JOIN`, ни `RIGHT JOIN` не позволят в запросе вывести все записи таблиц `brands` и `products`, которые не участвуют в образовании связей, ведь такие операторы могут добавить такие записи только одной из двух таблиц: либо левой, либо правой. Поэтому при использовании `LEFT JOIN`, ни `RIGHT JOIN` в запросе ниже мы получим только:

![06](/SQL_Data/img/06_28.png)

или

![06](/SQL_Data/img/06_29.png)

а не две записи сразу.

Для решения подобной задачи можно использовать оператор FULL JOIN, который в результате выводит записи обеих таблиц, которые не участвовали в образовании связи.

Давайте сперва напишем запрос, а потом посмотрим на результат: 

```sql
SELECT
      b.id as brand_id,
      b.name as brand_name,
      p.id product_id,
      p.brand_id,
      p.name as product_name
FROM products p
FULL JOIN brands b ON b.id = p.brand_id;
```

**Результат выполнения запроса**

![06](/SQL_Data/img/06_30.png)

Обратите внимание на 2 последние строки:

![06](/SQL_Data/img/06_31.png)

В первом случае у продукта  «Лимонад» указано значение `brand_id`, которого нет в таблице `brands`. Во втором случае есть бренд  «Одежда», но пока таких товаров нет в таблице `products`.

Грубо говоря, `FULL JOIN` — это комбинация операторов `LEFT` и `RIGHT JOIN`.

К сожалению, СУБД MySQL не поддерживает `FULL JOIN`, поэтому в рамках данного курса заданий с таким оператором не будет.  

<hr>

[Содержание](#содержание)

## Соединение таблиц. Порядок выполнения других операторов

В этом степе мы поговорим о том, как применяются остальные операторы в запросе с соединением таблиц. В любом запросе, который содержит оператор `FROM`, он выполняется первым. То есть в начале определяется, из какой таблицы стоит прочитать данные (и присваивается псевдоним таблице, который задается через `AS`) для их дальнейшей фильтрации, группировки и применения различных функций, описанных в `SELECT`*.

Если в запросе после `FROM` указан оператор соединения таблицы, например `CROSS JOIN`, то он выполняется вторым, а уже следом за ним — все остальные операторы. 

![06](/SQL_Data/img/06_32.png)

Например, в таком запросе первым делом произойдет соединение таблиц `brands` и `products`, а потом уже фильтрация по условию, описанному в `WHERE`.

```sql
SELECT * 
FROM brands
CROSS JOIN products
WHERE brand_id > 5;
```

Для примера дана часть таблицы:

![06](/SQL_Data/img/06_33.png)

Напоминаем, что в операторе соединения можно, как и в операторе `FROM` задавать псевдоним для таблицы через `AS`, а потом обращаться по нему к таблице. Применение псевдонимов очень удобно при указании необходимых полей в операторе `SELECT`, так как обычно псевдонимы короче, чем название самой таблицы. Поскольку разные таблицы могут содержать поля с одинаковыми именами, но с разными данными, например, поле `id` в таблице `brands` отличается от поля `id` в таблице `products`, то необходимо указывать, из какой таблицы брать требуемое поле. Обратиться к полю таблицы в таком случае можно при помощи добавления через точку псевдонима таблицы перед именем поля, как в запросе ниже.

```sql
SELECT b.id AS brand_id, p.id AS product_id
FROM brands AS b
CROSS JOIN products AS p
WHERE p.brand_id > 5;
```

Все остальные операторы, такие как `GROUP BY`, `ORDER BY` и `LIMIT` будут применяться тоже после соединения таблиц и фильтрации.

>*Мы еще раз хотим подчеркнуть, что порядок выполнения операторов в запросе только логический. Планировщик запроса, который реализован в СУБД, может производить соединение,  фильтрацию и группировку в том порядке, который более оптимален с точки зрения вычислительных ресурсов. Довольно часто фильтрация производится либо в момент соединения таблиц, либо перед ним. Последовательность выполнения операторов, о которой мы говорим в этом курсе, это всего лишь логическая интерпретация запроса, которая нужна для понимания того, какой результат получится. 

<hr>

[Содержание](#содержание)

## Соединение множества таблиц
Часто случается такая ситуация, когда в одном запросе необходимо вывести данные сразу трех или более таблиц. Это не должно вас пугать — в SQL это возможно. 

Для каждой новой присоединяемой таблицы надо использовать отдельный оператор соединения. Например, для того, чтобы вывести номера всех покупок, у которых номер товара меньше либо равен 3, с именем товара и именем бренда товара, понадобится написать вот такой запрос:

```sql
SELECT 
   pur.id,
   p.id as product_id,
   p.name as product_name,
   b.name as brand_name
FROM purchases pur
INNER JOIN products p ON p.id = pur.product_id
INNER JOIN brands b on p.brand_id = b.id
WHERE p.id <= 3;
```

Результат выполнения запроса

![06](/SQL_Data/img/06_34.png)

Давайте последовательно рассмотрим, что произошло в ходе выполнения запроса*:

1. Сначала к таблице `purchases` была присоединена таблица `products` по условию `p.id = pur.product_id`.
2. Затем уже к результату присоединения была добавлена таблица `brands` по условию `p.brand_id = b.id`.
3. После последовательного соединения из результата отфильтровываются только те записи, у которых значение поля `id` из таблицы `products` меньше либо равно 3.

Можно комбинировать различные операторы соединения с различными условиями, даже можно присоединять одну и ту же таблицу несколько раз! 

>*На самом деле таблицы в запросах с множественными соединениями необязательно будут соединены в том порядке, в котором они прописаны в тексте запроса. Оптимизатор запроса СУБД может изменить порядок на физическом уровне, если найдет другой, более оптимальный порядок. 

<hr>

[Содержание](#содержание)

## Соединение подзапросов. Бонусный степ

Не стоит забывать, что подзапросы тоже могут быть источниками данных, как и таблицы. Соответственно, к ним можно также присоединять таблицы, или их можно использовать в качестве таблиц для присоединения.

Например, запрос из предыдущего степа можно было бы переписать с внесением условия в подзапрос:

```sql
SELECT 
   pur.id,
   p.id as product_id,
   p.name as product_name,
   b.name as brand_name
FROM (SELECT id, product_id 
      FROM purchases
      WHERE product_id <= 3) pur
INNER JOIN products p ON p.id = pur.product_id
INNER JOIN brands b on p.brand_id = b.id;
```

Или же использовать присоединение подзапроса к таблице:

```sql
SELECT 
   pur.id,
   p.id as product_id,
   p.name as product_name,
   b.name as brand_name
FROM purchases pur
INNER JOIN (SELECT *
            FROM products p 
            WHERE id <= 3) p ON p.id = pur.product_id
INNER JOIN brands b on p.brand_id = b.id;
```

В обоих случаях сначала вычисляется подзапрос, а затем либо к нему присоединяются другие таблицы, либо он присоединяется как таблица.

Важно не забывать присваивать псевдоним подзапросу. Это ведь не исходная таблица, которой мы заранее задали имя и можем по нему обратиться к нужным нам полям, а результат выполнения внутреннего запроса, к которому мы относимся, как к таблице. 

<hr>

[Содержание](#содержание)

## Условие через оператор USING. Бонусный степ

Если две таблицы соединяются через знак «=» и поля таблиц, по которым мы их соединяем, имеют одинаковые имена, то удобно воспользоваться оператором `USING()`*, вместо того, чтобы писать условие соединения таким образом: ON поле_таблицы_1 = поле_таблицы_2. Сама конструкция в таком случае будет выглядеть следующим образом:

```sql
...
FROM таблица_1
INNER JOIN таблица_2 USING(название_полей_по_которым_идет_соединение)
...
```

После оператора `USING` необходимо в скобках указать имя поля, по которому мы хотим соединить 2 таблицы. Пример такого запроса мы привели ниже:

```sql
SELECT 
   pur.id,
   p.product_id,
   p.name as product_name
FROM purchases pur
INNER JOIN (SELECT id as product_id, name 
            FROM products) p USING (product_id)
WHERE p.product_id <= 3;
```

Результат такого запроса будет идентичен результату запроса с ключевым словом ON:

```sql
SELECT 
   pur.id,
   p.product_id,
   p.name as product_name
FROM purchases pur
INNER JOIN (SELECT id as product_id, name 
            FROM products) p ON pur.product_id = p.product_id
WHERE p.product_id <= 3;
```

Таблица `purchases` и подзапрос с псевдонимом `p` соединяются по полю, в котором хранится номер продукта, при этом оба поля имеют одинаковое имя `product_id`, поэтому можно воспользоваться оператором `USING` для описания условия связи этих таблиц.

Также обратите внимание, что хоть у таблицы `products` есть поле `id`, в котором хранится номер продукта, мы не можем к нему обратиться, поскольку в подзапросе `p` этому полю был задан псевдоним `product_id`.  

Данный оператор есть не во всех СУБД, и классический способ соединять таблицы всё-таки через знак «=», а не оператор `USING`. Одно из преимуществ использования знака равно — если в запросе используется много таблиц, то по псевдонимам таблиц сразу видно, какие таблицы друг с другом соединяются.

<hr>

[Содержание](#содержание)

# 6.5 Практика

Вы познакомились с разными видами соединений и прочитали много теории, как они работают и чем отличаются. Пора приступать к практической части!

![06](/SQL_Data/img/06_35.png)

<hr>

[Содержание](#содержание)

