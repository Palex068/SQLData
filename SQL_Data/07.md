# 7. Финальное задание

## Содержание

+ [7.1 Итоги маркетинговой компании](#71-итоги-маркетинговой-компании)
+ [7.2 Маржа и маржинальность](#72-маржа-и-маржинальность)
+ [7.3 ABC-анализ](#73-abc-анализ)
+ [7.4 Итоги курса](#74-итоги-курса)

[Оглавление](/SQL_Data/README.md)

# 7.1 Итоги маркетинговой компании

Вы отлично справились с самой сложной теоретической частью курса. Так уж вышло, что она оказалась последней, но не стоит грустить, ведь теперь вы можете применить полученные знания для решения более интересных боевых задач.

В этом модуле вам нужно будет помочь коллегам из маркетингового и финансового отделов. В первом уроке мы будем исследовать маркетинговую компанию и искать причину ее провала. Во втором — проанализируем, какая из двух финансовых стратегий более прибыльна.

Давайте приступать!

![07](/SQL_Data/img/07_01.png)

Отдел маркетинга решил запустить акцию для новых клиентов. При регистрации клиенту дается промокод «NEWCOMER», который можно применить только к первой покупке, чтобы получить скидку 30% на заказ. 

![07](/SQL_Data/img/07_02.png)

Эта акция должна привлечь новых покупателей и расширить базу клиентов. Однако, необходимо убедиться в том, что наша акция технически правильно реализована. Для этого придется немного подождать, пока акцией не воспользуются клиенты. А затем уже на полученных данных провести анализ.

Спустя неделю мы решили проверить, как проходит наша акция.

Давайте для начала посмотрим на все заказы, которые были сделаны с момента старта акции. За начало акции будем считать дату, когда был совершен первый заказ с использованием промокода «NEWCOMER». Этот запрос мы напишем в 2 этапа:

1. Сначала найдем самый ранний заказ.
2. А потом выведем все заказы, которые были совершены после него.

Что ж, приступим. Выведите дату самого раннего заказа, к которому был применен промокод «NEWCOMER».  Назовите столбец first_order_with_coupon.

**Структура данных в нашей БД**

![07](/SQL_Data/img/07_03.png)

```sql
SELECT MIN(date) AS first_order_with_coupon
FROM orders o JOIN coupons c ON o.coupon_id = c.id
WHERE c.code = 'NEWCOMER';
```

Отлично!

Теперь давайте выведем данные всех заказов, которые были сделаны с момента начала акции. Дату самого первого заказа мы уже знаем, осталось лишь добавить фильтр, который оставит все заказы, сделанные после него.

Используя код из предыдущего степа, напишите запрос, который выведет все поля заказов из таблицы orders, сделанные с момента начала акции.  

```sql
SELECT *
FROM orders
WHERE date >= (SELECT MIN(date) AS first_order_with_coupon
              FROM orders o JOIN coupons c ON o.coupon_id = c.id
              WHERE c.code = 'NEWCOMER')
```

Теперь у нас есть запрос, который выводит все заказы, необходимые для анализа. 

Давайте оценим долю заказов, сделанных с использованием промокода с момента начала акции.

Выведите количество всех заказов с момента начала акции, количество заказов, в которых был использован промокод «NEWCOMER», а также процент заказов с промокодом от всех заказов с момента начала акции.

Для первого поля используйте псевдоним cnt_orders, для второго — cnt_promo_orders, для третьего — perc_promo_total. 

```sql
WITH tmp AS (
    SELECT *
    FROM orders
    WHERE date >= (SELECT MIN(date) AS first_order_with_coupon
                   FROM orders o JOIN coupons c ON o.coupon_id = c.id
                   WHERE c.code = 'NEWCOMER'))
SELECT (SELECT COUNT(*)
        FROM tmp) AS cnt_orders,
        (SELECT COUNT(*)
        FROM tmp
        WHERE coupon_id IS NOT NULL) AS cnt_promo_orders,
        100 * (SELECT COUNT(*)
        FROM tmp
        WHERE coupon_id IS NOT NULL) / 
        (SELECT COUNT(*)
        FROM tmp) AS perc_promo_total
```

Получилось довольно большое число заказов от новых пользователей к всем заказам, ведь каждый раз, когда к заказу был применен промокод, перед этим был создан новый аккаунт.

Можем ли мы с уверенностью сказать, что в нашей клиентской базе появилось 8 новых клиентов? Скорее всего, да, но что-то подсказывает нам, что мы получили слишком хороший результат за одну лишь неделю. Неужели что-то пошло не так? Единственный способ проверить нашу догадку — посмотреть на новых пользователей. 

Напишите запрос, который выведет:

+ поле id всех заказов с момента начала акции,
+ название промокода, который был применен к заказу, из таблицы coupons,
+ поля из таблицы users, соответствующие этим заказам.

Для `id` заказа укажите псевдоним `order_id`, а также отсортируйте все данные по возрастанию значений этого поля.

```sql
SELECT o.id AS order_id,
       c.code, 
       u.*
FROM orders o JOIN users u ON o.user_id = u.id
              LEFT JOIN coupons c ON o.coupon_id = c.id
WHERE date >= (SELECT MIN(date) AS first_order_with_coupon
               FROM orders o JOIN coupons c ON o.coupon_id = c.id
               WHERE c.code = 'NEWCOMER')
ORDER BY order_id
```

Кажется, все же что-то пошло не так...

И по вашему запросу из предыдущего степа уже видно, что именно сломалось в рамках не просто нашей маркетинговой компании, но и всей системы!

Чтобы получше разглядеть, скопируйте запрос из предыдущего степа, но сделайте сортировку сначала по номеру телефона, а потом по номеру заказа.

```sql
SELECT o.id AS order_id,
       c.code, 
       u.*
FROM orders o JOIN users u ON o.user_id = u.id
              LEFT JOIN coupons c ON o.coupon_id = c.id
WHERE date >= (SELECT MIN(date) AS first_order_with_coupon
               FROM orders o JOIN coupons c ON o.coupon_id = c.id
               WHERE c.code = 'NEWCOMER')
ORDER BY u.phone, order_id
```

Некоторые пользователи поняли, что они могут несколько раз зарегистрироваться с одним и тем же именем, электронной почтой и даже телефоном! Из-за этого они получили возможность пользоваться приветственным промокодом «NEWCOMER» несколько раз. Хорошо, что мы заметили эту проблему сейчас, а не через еще одну неделю, ведь это могло обернуться для компании финансовыми потерями.

К сожалению, придется отложить нашу маркетинговую кампанию, пока не будет перестроена таблица `users`. А какие бы изменения вы предложили для нее, чтобы больше не наступать на такие грабли? 

>В ответе может встретиться то, о чем не было рассказано в курсе, поэтому поищите значение незнакомых выражений в интернете самостоятельно

+ [x] Сделать поле phone естественным первичным ключом
+ [x] Установить на поле phone ограничение UNIQUE
+ [ ] Сделать имя естественным первичным ключом
+ [ ] Предложить отделу по работе с клиентами звонить каждому новому клиенту и уточнять личную информацию
+ [ ] Установить на поле phone ограничение NOT NULL

Нам очень помогла ваша наблюдательность. А с помощью анализа данным нам удалось сохранить бизнесу много денег!

Мы еще раз убедились в том, что дополнительная проверка данных никогда не повредит и порой поможет избавиться от неприятных неожиданностей.

![07](/SQL_Data/img/07_04.png)

<hr>

[Содержание](#содержание)

# 7.2 Маржа и маржинальность

В этой задаче вам предстоит провести небольшое исследование для финансового отдела. Коллеги хотели бы узнать, какое стратегическое решение прибыльнее: увеличить цену на все товары на 3% или увеличить цену 5 самых часто покупаемых товаров на 10%. Использовать будем, конечно, только имеющиеся у нас данные без учета маркетинговой кампании из предыдущего урока.

Давайте разбираться.

![07](/SQL_Data/img/07_05.png)

Задачка выглядит непростой на первый взгляд, поэтому давайте сначала **декомпозируем** ее. 

Итак, нам необходимо сравнить прибыль, которую бы мы получили, если бы все наши товары стоили на 3% дороже, с прибылью, которую мы бы получили, если бы увеличили цену пяти самых популярных из них на 10%. Мы не станем учитывать стоимость доставки и примененные промокоды в наших расчетах.

Поскольку все данные о покупках содержатся в таблице `purchases`, мы можем разделить нашу задачу на 6 этапов следующим образом: 

1. Увеличим цену всех товаров на 3% и, умножив новую цену на количество купленного товара, получим новые суммы покупок.
2. Найдем топ-5 самых заказываемых товаров, то есть таких, которые встречаются в наибольшем количестве заказов.
3. Оставим только покупки 5 самых популярных товаров, в них увеличим цену на 10% и найдем новые суммы покупок.
4. Повторим 3 шаг, но проделаем его для всех товаров, которые не попали в топ-5 самых заказываемых, цену при этом увеличивать не будем.
5. Соединим подзапросы, которые считают сумму всех покупок из пунктов 1, 3 и 4, между собой, и сложим суммы покупок 5 самых заказываемых товаров из пункта 3 и с покупками товаров, не входящих в топ-5, из пункта 4.
6. Для лучшего сравнения приведем процентное соотношение получившейся прибыли от применения первой стратегии (+3% к цене всех товаров) к прибыли от применения второй стратегии (+10% к цене 5 самых популярных товаров).

Давайте начнем с самого первого пункта.

Посчитайте суммы покупок при увеличении цены всем товаров на 3%. Выведите `id` покупок из таблицы `purchases` и соответствующую сумму покупки с псевдонимом `first_strategy`.

**Подсказка**

Просто добавьте к значению поля price значение поля price, умноженное на 0,03 (предыдущая цена + 3%), а затем умножьте результат на значение поля amount, чтобы получить сумму каждого заказа.

```sql
SELECT id,
       price * 1.03 * amount AS first_strategy
FROM purchases
```

Переходим к следующему этапу.

Найдите топ-5 самых заказываемых товаров из `purchases`. В выборке оставьте только поле `product_id`. 

При решении данной задачи постарайтесь не использовать подзапрос, вывести данные, сделав соответствующую сортировку, можно в простом запросе.

**Подсказка**

Посчитайте для каждого товара количество уникальных заказов при помощи агрегатной функции `COUNT` и `DISTINCT`, отсортируйте все товары по убыванию количества заказов через `ORDER BY ... DESC` и оставьте только 5 при помощи оператора `LIMIT`.

```sql
SELECT product_id
FROM purchases
GROUP BY product_id
ORDER BY COUNT(DISTINCT order_id) DESC
LIMIT 5
```

Супер!

Теперь переходим к 3 этапу нашей большой задачи. Надо выбрать все покупки самых популярных товаров (которые мы получили из предыдущего степа), у них увеличить цену товаров на 10% и посчитать новую стоимость каждой покупки. Выведите только id покупки и поле `second_strategy_top_products` с рассчитанной стоимостью покупки.

**ВАЖНО**

Задание предполагает, что вы возьмете запрос из предыдущего задания и сделаете фильтр типа WHERE product_id IN (запрос_из_предыдущего_степа). Но запрос с таким фильтром не выполнится, потому что в MySQL есть ограничение, которое не позволяет использовать оператор LIMIT в подзапросе для фильтра через оператор IN.

Чтобы такая шалость удалась, надо внутренний подзапрос обернуть в другой подзапрос с псевдонимом, например, вот так `WHERE product_id IN (SELECT * FROM (запрос_из_предыдущего_степа) AS sub)`.

**Подсказка**

Для фильтрации используйте оператор `IN`, но учтите то, что мы написали выше про особенности работы MySQL.

```sql
WITH top_5 AS (
    SELECT product_id
    FROM purchases
    GROUP BY product_id
    ORDER BY COUNT(DISTINCT order_id) DESC
    LIMIT 5)

SELECT id,
       price * 1.1 * amount AS second_strategy_top_products
FROM purchases
WHERE product_id IN (SELECT * FROM top_5)
```

На этом этапе давайте выведем все покупки товаров, которые не входят в пятерку самых популярных. 

Задача очень простая: нужно лишь взять запрос из предыдущего степа и немного изменить фильтр, а также не увеличивать цену на 10%, а оставить ее такой, какая она есть. Выведите только id покупки и поле `second_strategy_non_top_products` с рассчитанной стоимостью покупки.

**Подсказка**

Используйте оператор NOT для того, чтобы изменить условие фильтра на противоположное.

```sql
WITH top_5 AS (
    SELECT product_id
    FROM purchases
    GROUP BY product_id
    ORDER BY COUNT(DISTINCT order_id) DESC
    LIMIT 5)

SELECT id,
       price AS second_strategy_non_top_products
FROM purchases
WHERE product_id NOT IN (SELECT * FROM top_5)
```

Итак, мы пересчитали все покупки в соответствии с нашими стратегиями. Пришло время посчитать выручку по каждой стратегии как сумму от всех покупок и сравнить их между собой.

На этом степе мы выполним сразу пятый и шестой шаги нашего плана. 

Напишите запрос, который:

1. в первом поле выведет суммарную выручку от всех продаж при выборе первой стратегии (присвойте псевдоним first_rev);
2. во втором поле — суммарную выручку от всех продаж при выборе второй стратегии (присвойте псевдоним second_rev);
3. в третьем — процентное соотношение суммарной выручки от первой стратегии к выручке от второй стратегии, то есть отношение first_rev к second_rev в процентах (присвойте псевдоним proc_ratio). 

```sql
WITH top_5 AS (
    SELECT product_id
    FROM purchases
    GROUP BY product_id
    ORDER BY COUNT(DISTINCT order_id) DESC
    LIMIT 5),

first_str AS (
    SELECT SUM(price * 1.03 * amount) AS first_strategy
    FROM purchases),

second_str AS (
    SELECT SUM(IF(product_id IN (SELECT * FROM top_5), 
              price * 1.1 * amount, 
              price * amount)) AS second_strategy
    FROM purchases)

SELECT (SELECT first_strategy FROM first_str) AS first_rev,
       (SELECT second_strategy FROM second_str) AS second_rev,
       100 * (SELECT first_strategy FROM first_str) / 
       (SELECT second_strategy FROM second_str) AS proc_ratio
```

Прекрасно! Вы справились с еще одной очень сложной задачей!

Теперь финансовый отдел сможет принять решение, какую же стратегию им выбрать. Хотя наши результаты показали, что эти стратегии практически не отличаются друг от друга по выручке. 

![07](/SQL_Data/img/07_06.png)

<hr>

[Содержание](#содержание)

## Бонусный секретный урок

Вы, наверное, заметили, что финальный запрос получился очень уж сложным. Нам пришлось использовать слишком большое количество подзапросов.

А что если мы скажем, что есть функция, при помощи которой можно было бы значительно упростить запрос? Тем, кто уже знает хотя бы на базовом уровне какой-нибудь язык программирования, она может быть знакома.

<hr>

[Содержание](#содержание)

## Функция IF

Это очень полезная функция, которая принимает 3 аргумента:

+ условие (возвращает либо TRUE, либо FALSE)
+ выражение, которое будет возвращено, если условие оказалось истинным (то есть вернуло TRUE)
+ выражение, которое будет возвращено, если условие оказалось ложным (то есть вернуло FALSE)

Синтаксис функции простой. Ее используют при перечислении выражений в операторе SELECT, каждый аргумент разделяется запятой.

```sql
SELECT IF(<условие>, <выражение_при_TRUE>, <выражение_при_FALSE>) AS <псевдоним>
FROM <таблица>;
```

Условие проверяется для каждой записи после фильтрации в операторе `WHERE`, выражения вычисляются также для каждой записи отдельно. И в условии, и в обоих выражениях можно использовать имена полей, тогда для каждой записи будет взято соответствующее ей значение этого поля.

Рассмотрим на примере, как работает эта функция.

Допустим у нас есть таблица `test_if` с полем number, в котором хранится последовательность чисел от 1 до 10 включительно. Нам хочется рядом с полем numbers вывести поле, которое бы говорило, четное (Even) число или нечетное (Odd).

Для этого потребовалось бы написать такой запрос:

```sql
SELECT 
    number, 
    IF(number%2 = 1,'Odd', 'Even') as is_even 
FROM test_if;
```

Получится вот такой результат: 

![07](/SQL_Data/img/07_07.png)

Функция `IF` применилась к каждой записи таблицы `test_if`. Для каждой записи проверялось условие `number%2 = 1`, где `number` — значение поля number в каждой отдельной записи. Если это условие возвращало `TRUE`, то функция `IF` возвращала значение 'Odd'. Если — `FALSE`, то она возвращала 'Even'.

Важно понимать, что второй и третий аргументы должны быть одинакового типа, ведь результат функции IF заполняет поле значениями, а в поле могут быть значения только одного типа.

Если бы мы рассказали про функцию `IF` раньше, то наш финальный запрос мог бы выглядеть вот таким образом*:

```sql
SELECT 
	first_rev,
	second_rev,
	(first_rev / second_rev) * 100 AS proc_ratio
FROM (
      SELECT 
            SUM(1.03 * price * amount) AS first_rev,
            SUM(
                IF(product_id IN (
                                  SELECT * 
                                  FROM (
                                        SELECT product_id
                                        FROM purchases
                                        GROUP BY product_id
                                        ORDER BY COUNT(DISTINCT order_id) DESC
                                        LIMIT 5
                                       ) agg
                                  ),
                   1.1 * price * amount, price * amount)
                ) AS second_rev
	   FROM purchases
      ) AS revs
```

Как работает этот запрос? Разбор запроса написан ниже, но мы скроем его, чтобы у вас было время подумать и попробовать разобраться самим.

>*Скрипт можно упростить и сделать более читаемым, использовав не подзапросы, а CTE (общее табличное выражение). Мы не рассматриваем их в курсе, об этом вы можете почитать отдельно в интернете. Тогда скрипт можно переписать, например, так:

**Скрипт, написанный с помощью CTE**

```sql
with agg as (
             SELECT product_id
             FROM purchases
             GROUP BY product_id
             ORDER BY COUNT(DISTINCT order_id) DESC
             LIMIT 5
             ),

revs as (
         SELECT 
               SUM(1.03 * price * amount) AS first_rev,
               SUM(
                   IF(product_id IN (SELECT * FROM agg),1.1 * price * amount, price * amount)
                  ) AS second_rev
         FROM purchases
        )

SELECT 
	first_rev,
	second_rev,
	(first_rev / second_rev) * 100 AS proc_ratio
FROM revs;
```

**Объяснение**

1. Во внутреннем подзапросе мы:
    + Считаем выручку при первой стратегии — увеличиваем цену на 3% домножением на 1.03.
    + Умножаем цену на количество  — так получаем сумму каждой покупки.
    + Суммируем все получившиеся значения, чтобы получилась выручка при применении первой финансовой стратегии.
2. В том же подзапросе мы суммируем сумму каждой покупки при втором варианте стратегии, но для каждой покупки мы:
    + Проверяем, входит ли товар в топ-5 самых заказываемых.
    + Если да, то при расчете стоимости покупки увеличиваем стоимость на 10%, умножаем на 1.1
    + Если нет, то стоимость остается прежней.
    + Результаты функции IF также складываем при помощи агрегатной функции SUM.
3. Во внешнем подзапросе уже выводим нужные поля и считаем отношение в процентах.

<hr>

[Содержание](#содержание)

# 7.3 ABC-анализ

## ABC-анализ
Вы отлично справляетесь с финальными заданиями! В этом уроке мы познакомимся с ABC-анализом и попробуем его провести.

ABC-анализ — это способ классификации товаров, ресурсов и т.п. по степени их влияния на прибыль компании. Проще говоря, это один из наиболее часто используемых маркетинговых инструментов в ретейле, чтобы определить группы товаров, которые лучше всего продаются. Также с помощью данного анализа компания может выявить самые нерентабельные товары или услуги и отказаться от них.

Зачастую при описании ABC-анализа упоминают [закон Парето](https://ru.wikipedia.org/wiki/Закон_Парето), по которому 20% приложенных усилий хватает, чтобы получить 80% результата. Переводя это на ретейл, можно утверждать, что 20% продаваемой продукции обеспечивают 80% дохода компании.

![07](/SQL_Data/img/07_08.png)

<hr>

[Содержание](#содержание)

## Почему именно ABC?

Следуя ABC-анализу, товары стандартно делят на три группы:

+ А — товары, которые формируют 80% продаж. Их доля от общего количества товаров — 20%.
+ В — группа товаров промежуточной позиции и на них приходится около 15% продаж. Их этих товаров от общего количества — 30%.
+ C — товары, составляющие в ассортименте 50-60% и дающие только 5% продаж.

После такого анализа становится очевидным, какие товары приносят наибольшую выгоду компании, а от каких можно отказаться, сократить или попробовать заменить. 

ABC-анализ полезен для выстраивания маркетинговой стратегии и как следствие для достижения высоких показателей продаж. С помощью ABC-анализа проще планировать бюджет и управлять разнообразием продукции. Но ABC-анализ должен проводиться регулярно (например, раз в год или даже квартал), чтобы компания могла эффективно отвечать на потребности и запросы покупателей. Также при подобном методе важно учитывать сезонность товаров.

![07](/SQL_Data/img/07_09.png)

Ты познакомился с теорией, пора перейти к практике! Нам нужно получить таблицу, в которой будет отображен процент вклада продаж конкретной позиции в общие продажи. 

Для начала посчитай общие продажи, назови колонку `total_sum`. Для этого нам понадобятся данные по количеству (`amount`) и цене (`price`) из таблицы `purchases`.

```sql
SELECT SUM(amount * price) AS total_sum
FROM purchases
```

Теперь выведем таблицу, в которой будет отображен процент вклада продаж конкретной позиции в общие продажи. 

Используй запрос из предыдущего степа как подзапрос. Выведи product_id и процент вклада продаж по каждому продукту, назвав колонку vklad. Отсортируй данные в порядке убывания по колонке vklad, чтобы увидеть, какие продукты приносят наибольший вклад в прибыть компании.

**Подсказка**

Посчитай процент вклада по формуле: `(sum(amount * price)/total_sum)*100`. Не забудь про группировку данных.
Чтобы использовать в формуле общие продажи соедини запрос из предыдущего степа при помощи `CROSS JOIN` с таблицей purchases.

```sql
SELECT product_id , 100 * SUM(price * amount) / (SELECT SUM(amount * price)
                                                 FROM purchases) AS vklad
FROM purchases
GROUP BY 1                               
ORDER BY 2 DESC
```

Чтобы понять, что это за продукты, давай добавим наименование после колонки product_id. За основу используй запрос из предыдущего степа. Также тебе понадобится колонка name из таблицы products.

**Подсказка**

Чтобы добавить наименование в вывод соедини запрос из предыдущего степа при помощи INNER JOIN с таблицей products.

```sql
SELECT product_id,
       name,
       100 * SUM(price * amount) / (SELECT SUM(amount * price)
                                    FROM purchases) AS vklad
FROM purchases p JOIN products pr ON p.product_id = pr.id
GROUP BY p.product_id, pr.name                               
ORDER BY 3 DESC
```

А теперь добавим нарастающий (накопительный) итог* по столбцу процентов и увидим, какие товары дают 80% оборота. С помощью функции IF присвоим им соответствующую группу А, В или С. В этом степе в качестве основы использован запрос из предыдущего степа. Обратите внимание, мы соединяем результирующую таблицу из прошлого степа с самой собой по условию on t1.vklad<= t2.vklad. Таким образом мы получим накопительный итог по процентам (колонка sum_values).

Постарайтесь самостоятельно прочитать запрос — аналитикам часто приходится писать не только свой код, но и разбираться в чужом. Чтобы было проще, скопируй его в поле ниже и посмотри результат.

```sql
SELECT t1.product_id,
       t1.name, 
       t1.vklad, 
       SUM(t2.vklad) AS sum_values, 
       IF(SUM(t2.vklad) / 100 <= 0.8, 'A',
          IF(SUM(t2.vklad) / 100 <= 0.95, 'B', 'C')
          ) as ABC_group
FROM (
      SELECT product_id,
             p.name, 
            (SUM(amount * price) / total_sum) * 100 AS vklad
FROM purchases pur
CROSS JOIN (
            SELECT SUM(amount * price) AS total_sum
            FROM purchases
            ) t
LEFT JOIN products p ON p.id = pur.product_id         
GROUP BY product_id, total_sum, p.name
      ) t1

LEFT JOIN (
           SELECT product_id,
                  p.name, 
                 (SUM(amount * price) / total_sum) * 100 AS vklad
FROM purchases pur
CROSS JOIN (
            SELECT SUM(amount * price) AS total_sum
            FROM purchases
            ) t
LEFT JOIN products p ON p.id = pur.product_id         
GROUP BY product_id, total_sum, p.name
       ) t2 
                on t1.vklad<= t2.vklad

GROUP BY t1.product_id, t1.name, t1.vklad
ORDER BY sum_values
```

>*Нарастающий итог — это когда значение на каждой новой строке вычисляется, в результате сложения текущего значения с суммой предыдущих значений. Накопленную сумму проще посчитать с помощью оконной функции, но в данном курсе мы их не рассматриваем.

```
+------------+------------------------------------+----------+------------+-----------+
| product_id | name                               | vklad    | sum_values | ABC_group |
+------------+------------------------------------+----------+------------+-----------+
| 3          | Кофе «Эспрессо»                    | 12.39905 | 12.39905   | A         |
| 5          | Тефлоновый питчер Joe Frex 350 мл | 8.866108 | 21.265158  | A         |
| 28         | Кофе «Сьерра-Морена»               | 6.765846 | 28.031004  | A         |
| 1          | Кундинамарка                       | 6.255782 | 34.286786  | A         |
| 7          | Кофемолка Mini                     | 5.375672 | 39.662458  | A         |
| 8          | Чайник Buono                       | 4.950619 | 44.613077  | A         |
| 9          | Весы V60 Drip Scale                | 4.690586 | 49.303663  | A         |
| 26         | чайник BKV12S02-CEV                | 4.490561 | 53.794224  | A         |
| 25         | Кофе «Сан-Паулу»                   | 3.870484 | 57.664708  | A         |
| 6          | Кофемолка Skerton                  | 3.750469 | 61.415177  | A         |
| 12         | Кофе «Чанчамайо»                   | 3.655457 | 65.070634  | A         |
| 33         | Фруктовый чай «Наглый фрукт»       | 2.865358 | 67.935992  | A         |
| 20         | Кофе «Иргачеффе»                   | 2.545318 | 70.48131   | A         |
| 15         | Кофеварка на 3 чашки               | 2.500313 | 72.981623  | A         |
| 14         | Супремо                            | 2.445306 | 75.426928  | A         |
| 36         | Кофе «Сан-Маркос»                  | 1.945243 | 77.372172  | A         |
| 16         | Фильтры                            | 1.875234 | 79.247406  | A         |
| 34         | Кофе «Твист»                       | 1.830229 | 81.077635  | B         |
| 35         | Кофе «Малабар»                     | 1.710214 | 82.787848  | B         |
| 37         | Кофе «Джампит»                     | 1.68021  | 84.468059  | B         |
| 11         | Кофе «Сантос»                      | 1.635204 | 86.103263  | B         |
| 29         | Чьяпас                             | 1.410176 | 87.513439  | B         |
| 17         | Кофе светлой обжарки «Эксельсо»    | 1.405176 | 88.918615  | B         |
| 21         | Джей Хилл                          | 1.390174 | 90.308789  | B         |
| 19         | Кофе «Ламдонг»                     | 1.330166 | 91.638955  | B         |
| 23         | кружка Black                       | 1.070134 | 92.709089  | B         |
| 18         | Кофе светлой обжарки «Найроби»     | 0.965121 | 93.674209  | B         |
| 13         | Харрар                             | 0.950119 | 94.624328  | B         |
| 31         | Черный чай Эрл Грей                | 0.935117 | 95.559445  | C         |
| 27         | весы BSC2BNVWP                     | 0.88011  | 96.439555  | C         |
| 32         | Зеленый чай Сенча                  | 0.730091 | 97.169646  | C         |
| 4          | Кофе «Тайрона»                     | 0.725091 | 97.894737  | C         |
| 22         | Киримиро                           | 0.650081 | 98.544818  | C         |
| 24         | Кофе «Мачу-Пикчу»                  | 0.470059 | 99.014877  | C         |
| 30         | Черный чай Ассам                   | 0.265033 | 99.27991   | C         |
| 38         | Серрано                            | 0.250031 | 99.529941  | C         |
| 10         | Воронка V60 Plastic                | 0.245031 | 99.774972  | C         |
| 2          | Ньери                              | 0.225028 | 100.0      | C         |
+------------+------------------------------------+----------+------------+-----------+
```

<hr>

[Содержание](#содержание)

## RFM-анализ. Бонусный степ

Как вы могли догадаться, кроме ABC, есть еще и другие часто используемые методы анализа данных, например, RFM-анализ. 

**RFM-анализ** — метод, позволяющий разделить клиентов на группы по частоте и сумме покупок. Соответственно, такая сегментация позволяет выявить тех покупателей, которые приносят больше прибыли компании. С помощью этой информации можно направить точечную рекламу на подобных пользователей, чтобы привлечь больше покупателей и повысить прибыль.

Аббревиатура RFM расшифровывается так:

+ **Recency** — давность, то есть показатель, как давно клиенты покупали товар. Ее просто посмотреть, отсортировав клиентов по дате последней покупки.
+ **Frequency** — частота, то есть как часто покупатели делают заказы. Логично, что высокий показатель частоты говорит о том, что клиенту нравится компания/бренд, а также ее товары и услуги. 
+ **Monetary** — деньги или, говоря более точно, общая сумма трат. Здесь все просто: чем выше показатель, тем больше денег тратит клиент на покупки именно в этой компании.

Запомните основное: благодаря RFM-анализу можно успешно сегментировать аудиторию и разрабатывать персональные предложения для каждой группы. Ниже приведен пример таких групп клиентов.

![07](/SQL_Data/img/07_10.png)

<hr>

[Содержание](#содержание)

# 7.4 Итоги курса

Поздравляем с успешным завершением испытательного срока в онлайн-магазине [«True Coffee»](https://coffeetrue.ru/)! Надеемся, что вам все понравилось и было интересно постепенно погружаться в специфику профессии аналитика данных.

![07](/SQL_Data/img/07_11.png)

Вы познакомились с:

Базовым SQL – научились делать выборку данных по условию, изучили агрегатные функции, группировку данных, подзапросы и соединение таблиц.

Продуктовыми метриками* и диаграммами– изучили некоторые продуктовые метрики (MAU, DAU, конверсия), посчитали часть из них, а также узнали об особенностях различных диаграмм (линейной, столбчатой, круговой, воронки). 

Работой в компании – узнали, как устроены процессы в отделе аналитики данных.

 

Напоминаем, что с базовыми продуктовыми метриками:

+ `LTV` (прибыль от клиента за всё время работы),
+ `AOV` (средний чек),
+ `CAC` (стоимость привлечения одного клиента), 
+ `ARPU` (средний доход с одного активного пользователя ), 
+ `ARPPU` (средний доход с одного платящего пользователя)
— вы можете познакомиться в нашем бесплатном курсе [«Марафон данных: первое знакомство с SQL и Python»](https://stepik.org/course/105359).

<hr>

[Содержание](#содержание)

