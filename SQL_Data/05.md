# 5. Подзапросы

## Содержание

+ [5.1 Фильтрация с помощью подзапроса](#51-фильтрация-с-помощью-подзапроса)
+ [5.2 Фильтрация с помощью скалярного подзапроса](#52-фильтрация-с-помощью-скалярного-подзапроса)
+ [5.3 Подзапрос как источник данных](#53-подзапрос-как-источник-данных)
+ [5.4 Практика](#54-практика)

[Оглавление](/SQL_Data/README.md)

# 5.1 Фильтрация с помощью подзапроса

Вы отлично усваиваете новый материал! В вашем арсенале теперь есть операторы для выборки данных по условиям, и вы можете посчитать различные показатели при помощи агрегатных функций. 

Но иногда может попасться задача на выгрузку данных с необычной фильтрацией, которую простыми средствами не выполнить за один запрос. 

Давайте рассмотрим на примере.

![05](/SQL_Data/img/05_01.png)

## Выгрузка в несколько запросов

Коллеги попросили выгрузить все заказы пользователей, зарегистрировавшихся в 2020 году.

Логично такую выгрузку выполнить в два этапа: 

1. Выгрузить всех пользователей из таблицы users,  которые зарегистрировались в 2020 году (то есть с 1 января по 31 декабря 2020 года). В данном случае удобно использовать оператор BETWEEN, чтобы установить фильтр на дату регистрации.
2. Взять id полученных пользователей и отобрать только их заказы. Для этого мы поставим условие на id пользователей с помощью оператора IN.

Этап 1:

```sql
SELECT id
FROM users
WHERE created BETWEEN '2020-01-01' AND '2020-12-31';
```

Результатом запроса будет вот такой список идентификаторов пользователей. 

![05](/SQL_Data/img/05_02.png)

**Этап 2:**

```sql
SELECT * 
FROM orders 
WHERE user_id IN (1,2,3,4,5,6,7);
```

Скопируйте запрос в поле ниже и нажмите «Отправить», чтобы посмотреть на результат. Обратите внимание на столбец user_id: в нем будут только те id пользователей, что мы указали в условии.

> Посмотреть, через какие поля таблицы связаны друг с другом можно в [документации](https://docs.google.com/document/d/10e3ZCCFgRxPa8-WnvEgzDvzVBtIM9sd-/edit#heading=h.gjdgxs) или на схеме ниже. Сохрани данную схему, она поможет тебе в решении задач этого модуля.

![05](/SQL_Data/img/05_03.png)

<hr>

[Содержание](#содержание)

## Фильтрация при помощи подзапроса

Мы уверены, что предыдущий способ вам не особо понравился. Получить данные, потом вручную их копировать кажется неправильным. Оба запроса, рассмотренных в предыдущем степе, можно было бы объединить в один. Для этого можно использовать разные средства SQL, мы же это сделаем с помощью подзапроса*. 

**Подзапрос** — это запрос, который используется в другом SQL-запросе, то есть запрос внутри другого запроса. Подзапрос пишется в скобках как в примере ниже.

Мы записали код, которым можно выгрузить нужные нам данные. Давайте сразу разберем его. Обратите внимание: чтобы код был более читаемым, принято логические части запроса отделять отступами. Мы так и сделали:

```sql
SELECT * 
FROM orders
WHERE user_id IN (
                  SELECT id
                  FROM users
                  WHERE created BETWEEN '2020-01-01' AND '2020-12-31'
                  )
;
```

В качестве подзапроса в данном случае выступает то, что написано в скобках после оператора `IN`, а именно:

```sql
SELECT id
FROM users
WHERE created BETWEEN '2020-01-01' AND '2020-12-31'
```

Это полноценный запрос, который вернет нам `id` пользователей, зарегистрировавшихся в 2020 году. Мы использовали результат этого запроса как множество значений, которые может принимать поле `user_id` при выборке из таблицы `orders`:

```sql
WHERE user_id IN (результат_подзапроса)
```

Таким образом, наш полный запрос можно интерпретировать так: выведи все записи из таблицы `orders`, у которых значение поля `user_id` входит в результат подзапроса. Результатом подзапроса в свою очередь будут все `id` пользователей из таблицы `users`, зарегистрировавшихся в 2020 году.

>*Подобные задания можно также выполнять с помощью оператора `JOIN`, о котором мы расскажем в следующем модуле.

Важно помнить, какие поля будут выведены в результате выполнения подзапроса, и применять фильтрацию именно по ним.

Если, например, изменить наш предыдущий запрос таким образом, чтобы подзапрос выводил все данные, то скрипт не выполнится:

```sql
SELECT * FROM orders
WHERE user_id IN (
                  SELECT *
                  FROM users
                  WHERE created BETWEEN '2020-01-01' AND '2020-12-31'
                  );
```

Давайте разберемся, почему такой запрос не сработает. Для начала выполним выполним подзапрос отдельно:

```sql
SELECT *
FROM users
WHERE created BETWEEN '2020-01-01' AND '2020-12-31'
```

Результат будет содержать все поля таблицы:

![05](/SQL_Data/img/05_04.png)

Так как **один столбец** одновременно можно сравнить только с **одним другим столбцом**, непонятно, со значениями каких столбцов мы будем сравнивать поле `user_id` из таблицы `orders`. Поэтому в **подзапросе** явно нужно было определить поле `id`, а не выводить значения всех столбцов.

А теперь давайте потренируемся в новой теме и решим несколько задач от коллег.

Отделу закупок нужна выгрузка из таблицы `products` `id` и названий продуктов,  у которых название бренда начинается с заглавной буквы «Б». В этом вам поможет таблица `brands`, у которой есть только 2 поля: `id` и `name`. 

Вам понадобятся столбцы `id`, `name`, `brand_id` из таблицы `products`, а также столбцы `id`, `name` из таблицы `brands`. 

```sql
SELECT id, name
FROM products
WHERE brand_id IN (SELECT id
                   FROM brands
                   WHERE name LIKE 'Б%');
```

Отлично!

Не переживайте, что решение задач занимает у вас сейчас больше времени — мы начинаем изучать более сложные темы, так что это естественно. Больше практики, и вы будете чувствовать себя увереннее при написании SQL-запросов. Также не забывайте в свободное время смотреть дополнительные материалы по SQL и читать различные статьи на тему аналитики данных. В этом вам поможет наш Telegram-канал [LEFT JOIN](https://t.me/leftjoin), в котором мы публикуем интересные заметки и новости мира IT и аналитики.

![05](/SQL_Data/img/05_05.png)

Прежде чем мы перейдем к следующей задаче, давайте вспомним про тип данных в столбце `created` таблицы `users`. Изначальный тип данных этого поля `timestamp` —  `дата со временем 'гггг-мм-дд чч:мм:сс'`, например, '2020-01-19 10:35:11'. В прошлых задачах мы упрощали его до формата обычной даты: 'гггг-мм-дд'. Так как вы уже научились делать простую фильтрацию по датам, пришло время немного усложнить запросы, вернув полю `created` формат дата со временем.

Из-за данного формата теперь фильтрация будет выглядеть следующим образом:

+ За день: WHERE created BETWEEN '2020-01-01 00:00:00' AND '2020-01-01 23:59:59'
+ За период: WHERE created BETWEEN '2020-01-01 00:00:00' AND '2020-12-31 23:59:59'

А теперь выведите все данные из таблицы `orders` о клиентах, которые зарегистрировались с 20 по 31 декабря 2019 года включительно. Коллеги хотят узнать, какой процент клиентов, пришедших перед праздником, продолжает делать покупки в онлайн-магазине. Если таких будет немного, можно сделать вывод, что новички зарегистрировались, чтобы купить подарки на Новый год. 

Вам понадобятся данные из таблиц `orders` и `users`. 

<hr>

[Содержание](#содержание)

## Подзапрос и другие условия

Фильтр с подзапросом может быть не единственным в секции `WHERE`, ведь условие с подзапросом — это всего лишь фильтр с оператором `IN`.

Вы же еще не забыли, что несколько условий можно объединять при помощи логических операторов?

Например, запрос, который мы рассмотрели в прошлом степе, можно дополнить условием на стоимость доставки заказов. Давайте выведем все заказы пользователей, зарегистрировавшихся с 20 по 31 декабря 2019 года включительно, со стоимостью доставки не менее 200 рублей.

В части `WHERE` будет 2 условия:

1. Дата регистрации с 20 по 31 декабря 2019 года включительно. Здесь мы используем подзапрос.
2. Стоимость доставки не меньше 200 рублей.

Обратите внимание, что нам нужны записи, где оба условия соблюдаются, поэтому мы используем логический оператор AND:

```sql
SELECT * 
FROM orders
WHERE user_id IN (
                  SELECT id
                  FROM users
                  WHERE created BETWEEN '2019-12-20 00:00:00' AND '2019-12-31 23:59:59'
                  )
      AND delivery_price >= 200;
```

Результатом запроса будет таблица: 

![05](/SQL_Data/img/05_06.png)

>Оператор `WHERE` может содержать несколько условий с разными подзапросами. Все условия в части `WHERE` будут связаны  между собой логическими операторами. Например:

```sql
WHERE user_id IN (
                  SELECT id
                  FROM users
                  WHERE created BETWEEN '2019-12-20 00:00:00' AND '2019-12-31 23:59:59'
                  )
 AND brand_id IN (
                  SELECT id
                  FROM brands
                  WHERE name LIKE 'Эфиоп%'
                  )
;
```

Также не забывайте, что подзапрос — это все еще запрос, который может содержать в себе не только фильтрацию, но и, например, группировку.

Теперь еще одно задание! На этот раз от отдела продаж.

Выгрузите для коллег все данные по покупкам из таблицы `purchases`, в которых есть товары дороже 300 рублей, купленные с декабря 2019 года.

Вам понадобятся данные из таблиц `purchases` и `orders`. 

**Подсказка**

С помощью подзапроса получите все `id` заказов из таблицы `orders`, которые были сделаны с декабря 2019 года. Для вывода данных из таблицы `purchases` только по этим заказам, используйте оператор `IN`, также не забудьте про условие на поле `price`.

```sql
SELECT *
FROM purchases
WHERE order_id IN (SELECT id 
                   FROM orders
                   WHERE date >= '2019-12-01')
  AND price > 300;
```

О! После просмотра данных предыдущей выборки, к нам снова вернулся отдел закупок. На этот раз они хотят немного другую информацию.

Выведите все данные из таблицы `products`, у которых название бренда **начинается** с заглавной буквы «Б», или номер бренда входит в промежуток от 4 до 7.

Вам понадобятся данные из таблиц `products` и `brands`. 

**Подсказка**

С помощью подзапроса получите все id брендов из таблицы brands, у которых название бренда начинается с заглавной буквы «Б». Для отбора необходимых брендов используйте оператор LIKE.
Для отбора необходимых продуктов используйте два условия на поле brand_id. Первое условие будет с подзапросом, второе на номер бренда в промежутке от 4 до 7.

```sql
SELECT *
FROM products
WHERE brand_id IN (SELECT id
                   FROM brands
                   WHERE name LIKE 'Б%')
   OR brand_id BETWEEN 4 AND 7
```

<hr>

[Содержание](#содержание)

## Подзапрос внутри подзапроса

Не стоит забывать, что подзапрос — это тоже запрос, который может содержать множество различных условий фильтрации, которые тоже могут быть написаны с использованием подзапроса.

Например, чтобы отобрать все покупки из таблицы purchases, у которых название название бренда содержит прописную букву «у», потребуется написать вот такой непростой запрос.

```sql
SELECT * 
FROM purchases
WHERE product_id IN (
	             SELECT id FROM products 
	             WHERE brand_id IN (
		                        SELECT id FROM brands 
		                        WHERE name LIKE '%у%'
		                        )
	             )
;
```

Такие запросы стоит писать и читать изнутри, то есть начиная с последнего подзапроса. Последовательность логики такого запроса следующая:

1. Сначала отбираем все `id` брендов из таблицы `brands`, которые содержат букву «у» в названии:

```sql
SELECT id FROM brands 
WHERE name LIKE '%у%';
```

2. Потом отбираем все `id` продуктов из таблицы `products`, `brand_id` которых соответствует отобранным:

```sql
SELECT id FROM products 
WHERE brand_id IN (результат_первого_подзапроса);
```

3. В конце отбираем покупки полученных продуктов из таблицы purchases:

```sql
SELECT * 
FROM purchases
WHERE product_id IN (результат_второго_подзапроса);
```

Выведите уникальные `id` заказов (`order_id`) из таблицы `purchases`, содержащих товары брендов, название которых начинается с заглавной букву «Э». 

Вам понадобятся данные из таблиц `purchases`, `products` и `brands`. 

**Подсказка**

Как мы уже упоминали, такие запросы стоит писать и читать изнутри. Поэтому сначала напишите запрос, который выводит `id` брендов из таблицы `brands`, название которых начинается с заглавной букву «Э».  Поместите этот запрос в скобки — это будет внутренний подзапрос.
Затем найдите `id` продуктов из таблицы `products` этих брендов. Это уже «внешний» подзапрос.
В последнюю очередь выведите `order_id` заказов из таблицы `purchases`, которые содержат данные товары.

```sql
SELECT DISTINCT order_id
FROM purchases
WHERE product_id IN (SELECT id
                   FROM products
                   WHERE brand_id IN (SELECT id
                                      FROM brands
                                      WHERE name LIKE 'Э%'))
```

<hr>

[Содержание](#содержание)

## Условие подзапроса по нескольким полям. Бонусный степ

Мы уже упоминали, что при фильтрации с использованием подзапроса важно выбрать в подзапросе только те поля, по которым мы хотим отобрать нужные нам записи. 

Однако иногда встречаются ситуации, когда необходимо отобрать нужные записи в соответствии не с одним полем, а с комбинацией полей.

Например,  недавно коллеги просили отобрать все заказы, которые состоят только из товара под номером 8. Для этого мы использовали вот такой запрос:

```sql
SELECT * 
FROM orders
WHERE (id, total_price) IN (
		            SELECT order_id, price * amount
		            FROM purchases 
		            WHERE product_id = 8
                            )
;
```

Почему нельзя было просто указать соответствие по `id` заказа? Потому что , есть множество заказов, в которых присутствует товар номер 8 совместно с другими товарами, а нам нужно отобрать заказы, где содержится только товар номер 8.

Фильтрацией по комбинации полей `id` и `total_price` из таблицы `orders` мы отобрали те заказы, в которых есть только товар 8, ведь при заказе нескольких товаров в поле `total_price` будет содержаться стоимость всех заказанных товаров. Если  `total_price` и `price * amount` совпадают, значит других товаров в этом заказе не было.

>Обратите внимание, что подзапрос содержит 2 поля в результате: `order_id` и произведение `price*amount`. И наше условие также выставлено на 2 поля: `(id, total_price)`. То есть мы проверяем комбинацию полей `id` и `total_price` на вхождение в результат подзапроса.

<hr>

[Содержание](#содержание)

## Операторы ALL и ANY. Бонусный степ

Есть специальные операторы `ALL` и `ANY`*, которые  позволяют использовать операторы сравнения с подзапросами. 

Оператор `ANY` возвращает **true (1)**, если какое-либо из значений подзапроса удовлетворяет условию. Оператор `ALL` возвращает **true (1)**, если все значения подзапроса удовлетворяют условию. Приведем соответствие условий с операторами `ALL` и `ANY` и их более понятные нам эквиваленты.

![05](/SQL_Data/img/05_07.png)

Вместо (1,2,3) можно использовать подзапрос, который вернет как множество значений, так и одно значение.

>*Задач, в которых необходимо использовать именно эти операторы, крайне мало, поэтому они редко встречаются в работе, но знать о них все равно стоит. Более подробнее про операторы `ALL` и `ANY` можете почитать в интернете.

<hr>

[Содержание](#содержание)

# 5.2 Фильтрация с помощью скалярного подзапроса

## Скалярный подзапрос

В прошлом уроке, чтобы задать условие, мы использовали подзапрос в паре с оператором `IN`. Это было логично, ведь результатом подзапроса в прошлых задачах всегда был набор значений одного или нескольких полей.

Мы не использовали в условии с подзапросом операторы сравнения и оператор `BETWEEN` только из-за того, что результат подзапроса представлял собой несколько записей. 

В этом модуле мы рассмотрим фильтрацию данных, когда результатом подзапроса является только одно значение. Именно такие подзапросы, состоящие из одного значения (одного поля), называются скалярными.

![05](/SQL_Data/img/05_08.png)

Одни из наиболее частых случаев, когда используется скалярный подзапрос — это вывод результата агрегатной функции. Давайте разберем конкретный пример.

Выведем все заказы, которые были созданы в последний («максимальный») день:

```sql
SELECT * 
FROM orders
WHERE date = (
              SELECT MAX(date)
              FROM orders
              )
;
```

Как обычно сначала посмотрим, что выведет подзапрос:

```sql
SELECT MAX(date)
FROM orders;
```

Результатом подзапроса будет максимальная дата создания заказа — `2020-01-09`.

Затем основным запросом мы выведем все записи, где дата заказа будет равна `2020-01-09`:

![05](/SQL_Data/img/05_09.png)

А теперь выведите для коллег все данные по заказам с максимальной стоимостью. Отсортируйте их по полю `id` в порядке убывания. 

Постарайтесь не подглядывать в предыдущие степы, а написать запрос самостоятельно. Начните с подзапроса, то есть сначала найдите максимальную стоимость заказов. Затем напишите уже весь запрос, где в условии цена будет сравниваться с максимальной.

```sql
SELECT *
FROM orders
WHERE total_price = (SELECT MAX(total_price)
                      FROM orders)
```

Обратите внимание мы не можем написать:

```sql
WHERE total_price = MAX(total_price)
```

В этом случае мы получим ошибку, так как функция `MAX()` считается по всей колонке, то есть выбирается максимальное значение из группы значений:

![05](/SQL_Data/img/05_10.png)

А оператор `WHERE` работает построчно, соответственно в нем мы не можем сразу посчитать максимальное значение из всех значений столбца.

Хорошо запомните, что такие задачи стандартно решаются через подзапрос. Они часто встречаются на **собеседованиях на Junior-позиции**, чтобы проверить понимание подзапросов. Например, выведите все товары с максимальной ценой или всех студентов, получивших самый высокий балл и т.п.

А теперь выведите для коллег все данные по заказам с минимальной стоимостью. Отсортируйте заказы по полю `id` в порядке убывания.

Постарайтесь не подглядывать в предыдущие степы, а написать запрос самостоятельно. Начните с подзапроса, то есть сначала найдите минимальную стоимость заказов. Затем напишите уже весь запрос, где в условии цена будет сравниваться с минимальной.

```sql
SELECT *
FROM orders
WHERE total_price = (SELECT MIN(total_price)
                      FROM orders)
ORDER BY id DESC
```

Для продуктового отдела выведите все данные по заказам самого младшего и самого старшего клиентов.

Вам понадобятся данные из таблиц `orders` и `users`. 

**Подсказка**

В части `WHERE` у вас будет 2 условия: `user_id` должен быть равен `id` самого младшего клиента либо `id` самого старшего.
Чтобы найти их `id` в таблице `users`, сделайте соответствующую сортировку по дате рождения и поставьте `LIMIT`, чтобы в выдаче были значения только из первой строки

```sql
SELECT *
FROM orders
WHERE user_id IN (SELECT id
                  FROM users
                  WHERE birthday = (SELECT MIN(birthday)
                                      FROM users)
                     OR birthday = (SELECT MAX(birthday)
                                    FROM users));
```

```sql
SELECT *
FROM orders
WHERE user_id = (SELECT id
                  FROM users
                  ORDER BY birthday DESC
                  LIMIT 1)
  OR user_id = (SELECT id
                  FROM users
                  ORDER BY birthday
                  LIMIT 1);
```

Выведите для коллег все заказы, которые были сделаны в день регистрации последнего клиента.

Вам понадобятся данные из таблицы `orders` и `users`. В таблице `users` дата создания аккаунта хранится в формате `DATETIME` (то есть дата и время), а в таблице orders — в формате `DATE`. Для того, чтобы корректно сравнить эти поля, необходимо преобразовать поле `created` к типу `DATE` при помощи функции `DATE()`. Проделайте небольшую самостоятельную работу и посмотрите в интернете, как применять эту функцию. 

**Подсказка**

Датой регистрации последнего клиента будет максимальная дата регистрации клиента: `MAX(created)`.

```sql
SELECT *
FROM orders
WHERE date = (SELECT DATE(created)
              FROM users
              ORDER BY 1 DESC
              LIMIT 1)
```

Не стоит забывать, что результат скалярного подзапроса это всего лишь значение, константа. Соответственно, можно использовать разные операторы, чтобы задать условия фильтрации на результат подзапроса, например, операторы сравнения, BETWEEN, LIKE.

Выведите для продуктового отдела все данные по заказам, где стоимость заказа больше средней. Отсортируйте заказы по полю `total_price` в порядке убывания.

**Подсказка**

Как обычно, начните с подзапроса и определите, какое значение нужно найти с его помощью. А затем уже напишите полностью запрос.

```sql
SELECT *
FROM orders
WHERE total_price > (SELECT AVG(total_price)
                     FROM orders)
ORDER BY total_price DESC
```

<hr>

[Содержание](#содержание)

## Подзапросы с HAVING, BETWEEN, LIKE и операторами сравнения  

Результат подзапроса — это всего лишь набор значений или одно значение.

Это означает, что их можно использовать не только в условиях оператора `WHERE`, но и в условии оператора `HAVING`!  Скалярные запросы можно даже использовать как константу в операторе `SELECT`, но такое применение подзапросов в рамках курса мы не рассматриваем.

Самое главное — выбирать правильные операторы для работы с подзапросами в зависимости от количества записей в результате. Например:

1. Если результат подзапроса выдает несколько значений, а мы используем операторы сравнения, `BETWEEN`, `LIKE`, то запрос не выполнится, так как не сможет произвести сравнение с несколькими значениями, в отличии от, например, оператора IN;
2. Если результатом подзапроса будут значения двух столбцов, как в этом степе, то и сравнение во внешнем запросе нужно производить по двум столбцам. 

<hr>

[Содержание](#содержание)

# 5.3 Подзапрос как источник данных

Вы молодец! Мы проходим уже достаточно сложные темы, так что это нормально, если задачи даются с бóльшим трудом. Больше практики, и с каждым разом вы будете решать их лучше и лучше.

Далее в уроке мы рассмотрим подзапрос как источник данных. В этом уроке будет много теории и разобранных примеров, чтобы показать варианты использования подзапросов. 

![05](/SQL_Data/img/05_11.png)

## Подзапрос как источник данных

До сих пор оператор FROM мы использовали для определения, из какой таблицы выбрать данные.

Однако в качестве источника данных можно использовать результат подзапроса. Для этого вместо названия таблицы после оператора `FROM` в круглых скобках напишите подзапрос, а после закрывающей скобки присвойте ему псевдоним через оператор `AS` (или даже без него)*.

К примеру запрос, который выведет всех пользователей с номером 21, может быть источником данных для другого запроса. Так как в нашей таблице значение поля `id` уникальное, то результатом подзапроса будет только одна запись, то есть строка. Весь запрос будет выглядеть вот так:

```sql
SELECT * 
FROM (
      SELECT * 
      FROM users 
      WHERE id = 21
     ) AS user_21
;
```

Также, в если мы в подзапросе задаем новое имя столбцу, то во внешнем запросе в части `SELECT` мы должны обращаться к этому полю уже по новому имени, как, например, в запросе ниже. Обратите внимание, что во внешнем запросе используется `user_email` в качестве наименования поля, потому что именно такое наименование получил столбец в подзапросе:

```sql
SELECT user_email
FROM (
      SELECT id, name, email as user_email
      FROM users 
      WHERE id = 21
     ) AS user_21
;
```

Важно: наименования полей должны совпадать с наименованием в подзапросе.

>*В MySQL 8 обязательно присваивать подзапросу-источнику псевдоним, однако это необязательное условие в некоторых других СУБД, например, в ClickHouse.

Давайте подробнее рассмотрим, что же происходит в запросе ниже

```sql
SELECT user_email
FROM (
      SELECT id, name, email as user_email
      FROM users 
      WHERE id = 21
     ) AS user_21
;
```

1. Сначала отработает подзапрос:

```sql
(
 SELECT id, name, email as user_email
 FROM users 
 WHERE id = 21
) AS user_21
```

То есть из таблицы `user` мы отбираем всех пользователей, чей `id` равен `21`. Так как значение поля `id` уникально, то результатом подзапроса будет только одна запись:

![05](/SQL_Data/img/05_12.png)

2. Теперь уже результат нашего подзапроса становится источником данных. Из него мы выбираем поле `user_email`:

![05](/SQL_Data/img/05_13.png)

Давайте потренируемся на рабочих задачах и для курьерского отдела выведем номера всех заказов из таблицы `orders`, где стоимость доставки больше нуля, но заказ не был оплачен. Отсортируйте данные по `id` по возрастанию. Для подзапроса можете указать любой псевдоним.

Вам понадобится таблица `orders`. 

Эта задача на тренировку подзапросов, поэтому для фильтрации по полю `delivery_price` используйте подзапрос, а фильтрацию по полю `paid` и сортировку по `id` заказов выполните уже во внешнем запросе.

```sql
SELECT id
FROM orders
WHERE delivery_price > 0
  AND paid != 1
ORDER BY id
```

<hr>

[Содержание](#содержание)

## Оператор WHERE во внешнем запросе

К запросу, у которого источник не таблица, а подзапрос, можно относиться точно так же, как к обыкновенному. То есть, например, можно фильтровать данные с помощью оператора `WHERE`:

```sql
SELECT *
FROM (
      SELECT * 
      FROM purchases 
      ) ord
WHERE product_id = 7;
```

Здесь оператор `WHERE` применяется уже к результату подзапроса, а не к таблице `purchases` напрямую.

Посмотрите на запрос ниже и подумайте какой результат он вернет. Ответ в следующем степе. 

```sql
SELECT *
FROM (
      SELECT *
      FROM purchases 
      WHERE product_id = 2
      ) ord
WHERE product_id = 7;
```

Запрос ниже вернет пустой результат. Давайте пошагово разберем, как же он отработает.

```sql
SELECT *
FROM (
      SELECT *
      FROM purchases 
      WHERE product_id = 2
      ) ord
WHERE product_id = 7;
```

1. Сначала отработает подзапрос:

```sql
(
SELECT *
FROM purchases 
WHERE product_id = 2
) ord
```

То есть из таблицы `purchases` мы отбираем все записи, где `id` товара равен 2:

![05](/SQL_Data/img/05_14.png)

2. Теперь уже результат нашего подзапроса становится источником данных. Из него мы выбираем все данные, где  `id` товара равен 7, но таких записей не будет, так как среди результата подзапроса есть только `id` товара 2.

```sql
SELECT *
FROM (
      SELECT *
      FROM purchases 
      WHERE product_id = 2
      ) ord
WHERE product_id = 7;
```

<hr>

[Содержание](#содержание)

## Группировка во внешнем запросе

Когда источник данных — подзапрос, во внешнем запросе кроме фильтрации при помощи оператора `WHERE`, можно также группировать данные и считать различные статистики.

Например, для курьерского отдела запросом ниже мы выгружали выборку, которая показывала количество заказов с определенной стоимостью доставки. При этом обратите внимание, что статистику мы посчитали только по оплаченным товарам (`paid = 1`), сделанным в 2020 году и позднее (`date >= '2020-01-01'`).

```sql
SELECT delivery_price, COUNT(id) as cnt_ord
FROM (
      SELECT * FROM orders
      WHERE paid = 1
          and date >= '2020-01-01'
      ) ord
GROUP BY delivery_price;
```

![05](/SQL_Data/img/05_15.png)

В запрос можно также добавить, например, фильтрацию по результатам агрегации при помощи оператора HAVING:

```sql
SELECT delivery_price, COUNT(id) as cnt_ord
FROM (
      SELECT * FROM orders
      WHERE paid = 1
          and date >= '2022-01-01'
      ) ord
GROUP BY delivery_price
HAVING COUNT(id) >= 2;
```

![05](/SQL_Data/img/05_16.png)

А теперь очередное задание! На этот раз от отдела продаж.

Выведите `id` товара (`product_id`) и сумму, на которую было куплено каждого товара. Посчитайте сумму по всем товарам и оставьте в результате только те, у которых `product_id < 5`. Назовите столбцы `product_id` и `cnt_prod_sum` соответственно.

Вам понадобятся данные из таблицы `purchases`.

Эта задача на тренировку подзапросов, поэтому для фильтрации данных используйте подзапрос, а `id` товаров и сумму выводите уже во внешнем запросе.

**Подсказка**

Чтобы посчитать сумму по купленному товару, учтите, в каком количестве его купили: `price * amount`. 

```sql
SELECT product_id,
       SUM(amount * price) AS cnt_prod_sum
FROM purchases
WHERE product_id < 5
GROUP BY product_id
```

Отдел продаж поручил нам еще одно задание!

На этот раз они хотят, чтобы посчитали, сколько было заказов, в которых был  всего лишь 1 продукт, в которых было 2 различных продукта, и так далее. Для этого вам придется использовать таблицу purchases, и тут, в отличие от предыдущих степов, без подзапроса не обойтись никак. Нас интересуют только различные позиции, а не их фасовки, поэтому для подсчета количества уникальных товаров используйте только поле product_id.

Назовите поля в результате псевдонимами `cnt_prod` и `cnt_orders`.

```sql
SELECT prod_count AS cnt_prod,
       COUNT(*) AS cnt_orders
FROM (SELECT order_id,
             COUNT(DISTINCT product_id) AS prod_count
      FROM purchases
      GROUP BY order_id) AS pc
GROUP BY prod_count;
```

<hr>

[Содержание](#содержание)

## Операторы ORDER BY и LIMIT во внешнем запросе. Бонусный степ

В запросе, где источник данных — подзапрос, можно использовать операторы `ORDER BY` и `LIMIT` для сортировки и ограничения результата, так же, как и `WHERE`, `GROUP BY` и `HAVING`. 

`​​​​​ORDER BY` и `LIMIT` применяются к результату того запроса, в теле которого они присутствуют. Например, запрос, который вернет топ-10 самых дорогих заказов может быть оформлен вот так:

```sql
SELECT *
FROM (
	SELECT order_id, SUM(price*amount) as sum_ord 
	FROM purchases 
	GROUP BY order_id 
) ord
ORDER BY sum_ord DESC 
LIMIT 10;
```

Если бы сортировка и ограничение результата были внутри подзапроса, то ограничение результата внешнего запроса уже применялось к результату подзапроса. Например, вот такой запрос все равно вернет 10 записей, ведь результат подзапроса ограничен оператором `LIMIT 10`:

```sql
SELECT *
FROM (
	SELECT order_id, SUM(price*amount) as sum_ord 
	FROM purchases 
	GROUP BY order_id 
	ORDER BY sum_ord DESC 
	LIMIT 10
) ord 
LIMIT 12;
```

<hr>

[Содержание](#содержание)

# 5.4 Практика

Пора проверить новые знания и решить несколько задачек на тему подзапросов!

![05](/SQL_Data/img/05_17.png)

<hr>

[Содержание](#содержание)

