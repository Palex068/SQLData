# 3. Выборка данных по условию

## Содержание

+ [3.1 Фильтрация данных, операторы сравнения. WHERE](#31-фильтрация-данных-операторы-сравнения-where)
+ [3.2 Фильтрация данных. Значение NULL](#32-фильтрация-данных-значение-null)
+ [3.3 Фильтрация данных, операторы сравнения 2. WHERE](#33-фильтрация-данных-операторы-сравнения-2-where)
+ [3.4 Фильтрация данных, логические операторы. WHERE](#34-фильтрация-данных-логические-операторы-where)
+ [3.5 Операторы BETWEEN, IN, LIKE](#35-операторы-between-in-like)
+ [3.6 Практика](#36-практика)

[Оглавление](/SQL_Data/README.md)

# 3.1 Фильтрация данных, операторы сравнения. WHERE

Вы отлично справляетесь! Мы уже делали несколько простых выгрузок для коллег из разных отделов. Пора заняться более сложными задачами. Отдел продаж попросил выгрузку данных по заказам за 4 января 2020 года. В этом нам поможет оператор `WHERE`. С его помощью можно выбрать данные за определенные даты или определенной категории.

В этом модуле вы не только познакомитесь с оператором `WHERE`, но и научитесь отфильтровывать данные с помощью операторов сравнения, логических операторов, а также операторов `BETWEEN`, `IN`, `LIKE`. Но обо всем по порядку!

Давайте сперва выведем все данные из таблицы заказов orders. Посмотрим, что там хранится.

```sql
SELECT *
FROM orders;
```

В таблице orders содержатся данные о совершенных заказах: 

![03](/SQL_Data/img/03_01.png)

Структура таблицы следующая: 

![03](/SQL_Data/img/03_02.png)

<hr>

[Содержание](#содержание)

## Фильтрация данных с помощью оператора WHERE

Что ж, мы познакомились с таблицей `orders`, а теперь давайте попробуем найти все данные по определенным параметрам, то есть отфильтруем их. Как мы уже говорили, с этим нам поможет оператор `WHERE`, в котором указываются условия для отбора нужных нам записей. 

Отдел продаж попросил выгрузку данных по заказам за 4 января 2020 года. Значит, нам нужно выбрать записи только за этот день, то есть поставить ограничения на дату. Скрипт будет выглядеть следующим образом:

```sql
SELECT *
FROM orders
WHERE date = '2020-01-04';
```

Попробуйте запустить этот запрос.

Обратите внимание, что дата указана в кавычках. Также рекомендуем соблюдать формат даты: ГГГГ-ММ-ДД (год — месяц — день). 

Итак, давайте разберемся, как это работает. В первую очередь очень важно понять, в каком порядке выполняются команды. С этим поможет схема ниже.

![03](/SQL_Data/img/03_03.png)

Первым всегда будет отрабатывать оператор `FROM`, потому что перед тем, как начинать работать с данными, необходимо указать их источник.

После него всегда будет отрабатывать оператор `WHERE`. После того, как мы указали источник данных, нам необходимо отфильтровать их, то есть выбрать только те строки, которые отвечают указанному условию.

И только после этого они передаются в оператор `SELECT`, и там уже мы сможем выбрать столбцы, которые нам необходимы, и вывести их на экран.

А что происходит с самой таблицей? Давайте посмотрим на картинку ниже: 

![03](/SQL_Data/img/03_04.png)

И вспомним наш запрос:

```sql
SELECT *
FROM orders
WHERE date = '2020-01-04'
```

Первым делом срабатывает оператор `FROM`, который определяет, откуда необходимо получить данные. В нашем случае это таблица `orders`. Оператор `FROM` как бы «находит» и «открывает» ее для дальнейших операций. После этого мы уже можем отфильтровать строки в этой таблице. 

`WHERE` идет по каждой строчке сверху вниз и выбирает только те из них, которые подходят условию (в нашем случае `date` должно соответствовать '2020-01-04'). Если строка соответствуют условию, то программа внутри себя присваивает ей значение 1 или `True` (истина)* , то есть выражение `date = '2020-01-04'` является истинным (правильным) для строки. Если строка не соответствует условию, то ей присваивается значение 0 или `False` (ложь). Затем скрипт отбирает все строки, которым присвоено только значение `True`.  

После того, как мы убрали ненужные строки, мы передаем отфильтрованный набор данных далее, то есть в `SELECT`. 

С помощью оператора `SELECT` можно выбрать, например, только определенные столбцы для вывода или все столбцы, как это сделали мы в нашем запросе.

>*При выполнении некоторых команд или проверке условий вычисляются значения условных выражений, и в зависимости от результата программа выполняет то или иное действие. Условное выражение может принимать одно из двух значений: «истина» или «ложь». «Истина» представлена значением 1 или True. Значение «ложь» представлено 0 или False. Запомните данную информацию — она понадобится вам в следующих уроках.

А теперь выведите из таблицы orders только те заказы, которые были сделаны 18 декабря 2019 года, с `id` и датой.

Вам понадобятся столбцы `id` и `date`.

Пример написания даты: '2019-12-18', то есть год — месяц — день. Дату необходимо указывать в кавычках.

```sql
SELECT id, date
FROM orders
WHERE date = '2019-12-18';
```

<hr>

[Содержание](#содержание)

## Операторы сравнения и типы данных

Вы уже запомнили, что дата прописывается в кавычках: `WHERE date = '2021-01-10'`?

То же самое со строковыми типами данных. Их мы тоже прописываем в кавычках. Например, если мы хотим вывести все заказы, которые были сделаны на определенный адрес, то необходимо прописать: `WHERE address = 'Ленинский пр., 100-2-139'`.

Регистр букв имеет значение. При сравнении через знак «=» требуется указывать строку точно так же, как она прописана в ячейке, то есть выборки для строк 'Ленинградский' и 'ЛеНинграДский' будут разными. Сравнение происходит посимвольно, поэтому даже лишний пробел может изменить выборку.

![03](/SQL_Data/img/03_05.png)

Если условие ставится на число, то есть числовой тип данных, то кавычки не нужны. Например: `WHERE price >= 2876.99` или` WHERE id < 6`.

```sql
SELECT id
FROM orders
WHERE address = 'Раменское, въезд Сталина, 07'
```

А теперь выведите все `id` заказов, где сумма заказа равна `2050`. Не забывайте, что числа ставить в кавычки не надо.

Вам понадобятся столбцы `id`, `total_price` из таблицы `orders`.

```sql
SELECT id
FROM orders
WHERE total_price = 2050;
```

Выведите `id` заказа, цену доставки, адрес и дату из таблицы `orders`, где цена доставки равна 99.

Вам понадобятся столбцы `id`, `delivery_price`, `address`, `date`.

```sql
SELECT id, delivery_price, address, date
FROM orders
WHERE delivery_price = 99;
```

Пока мы разбирались, как работает оператор `WHERE`, от отдела по работе с клиентами пришел запрос выгрузить данные о последнем заказе одного из наших постоянных клиентов, который доставили не на тот адрес. Коллеги хотят проверить, какая информация хранится о нем в базе данных. Они предоставили его `id` — `66`. Это упрощает задачу — можно сразу выставить фильтр  `WHERE id = 66`.

Выведите id заказа, дату, адрес и сумму заказа №66.

Вам понадобятся столбцы id, date, address и total_price из таблицы orders.

```sql
SELECT id, date, address, total_price
FROM orders
WHERE id = 66;
```

Вы отлично постарались! А теперь представьте, если бы коллеги не знали номер заказа? Как тогда найти нужную информацию?

Менеджеры говорили, что это наш постоянный клиент, значит, он есть в нашей базе данных с определенным идентификатором или номером — давайте запросим этот номер у коллег. Очень важно не бояться обращаться за помощью и общаться с сотрудниками из других отделов, так вы сможете быстрее и качественнее выполнять свои задачи!

Коллеги предоставили нам `id` клиента — `29`. В таблице `orders` эта информация указывается в поле `user_id`.

Теперь, когда мы узнали номер пользователя, мы сможем получить все данные о нем, указав соответствующее условие в операторе `WHERE`. Но сейчас нам нужен только последний заказ. Чтобы получить информацию о нем, нужно отсортировать данные по дате в порядке убывания с помощью оператора `ORDER BY`: в первой строке мы и увидим нужный нам заказ.

Выведите id пользователя, id заказа, адрес, дату и сумму заказа для пользователя с id равным 29. Отсортируйте данные по дате в порядке убывания.

Вам понадобятся столбцы user_id, id, address, date и total_price из таблицы orders.

```sql
SELECT user_id, id, address, date, total_price
FROM orders
WHERE user_id = 29
ORDER BY 4 DESC;
```
Супер! Готовы немного усложнить задачу? Давайте в выводе сразу получим нужные нам данные без лишних строк.

В прошлом степе мы вывели все данные по пользователю с id 29. Теперь выведите на экран только первую строку.

```sql
SELECT user_id, id, address, date, total_price
FROM orders
WHERE user_id = 29
ORDER BY 4 DESC
LIMIT 1;
```

Молодец! Запрос со множеством операторов — это стандартная ситуация в работе аналитика. Давайте посмотрим, в каком порядке они отрабатывают.
 

```sql
SELECT user_id, id, address, date, total_price
FROM orders
WHERE user_id = 29
ORDER BY date DESC
LIMIT 1;
```

1. Первым, как обычно, отработает `FROM`.
2. Затем — `WHERE`. С его помощью мы отфильтровываем нужные нам строки.
3. Далее `SELECT` — выбираем столбцы для вывода.
4. Затем `ORDER BY` — определяем, в каком порядке выводить строки.
5. Последним отработает оператор `LIMIT`. С помощью него мы выведем необходимое количество строк.

![03](/SQL_Data/img/03_06.png)

<hr>

[Содержание](#содержание)

# 3.2 Фильтрация данных. Значение NULL

Давайте еще раз посмотрим на данные из таблицы заказов: 

![03](/SQL_Data/img/03_07.png)

В таблице `orders` заполнены не все ячейки — в некоторых ничего нет, например, в столбцах `address` и `coupon_id`. Данные ячейки выделены на скриншоте выше. Когда в поле ничего не хранится, оно заполняется специальным значением `NULL` (отсутствие сведений).

Например, если пользователь не указал адрес доставки, то поле `adress` будет пустым, то есть будет хранить в себе значение `NULL`. В этом случае покупатель скорее всего будет забирать заказ на складе.

То же самое с купоном: если у пользователя не было купона, или он не применил его к своей покупке, то значение в столбце `coupon_id` останется пустым и будет содержать специальное значение `NULL`.

Цифра 0 или знак пробела не являются `NULL`, так как эти обозначения воспринимаются БД как информация. Также важно учитывать, что значение `NULL` может встречаться в столбцах с любым типом данных.

Бывает, нужно найти столбцы, в которых определенные строки содержат или не содержат значения `NULL`. Для этого мы используем следующие конструкции:

+ Если нужно найти записи, где в определённом поле есть `NULL`-значения:
```sql
WHERE наименование_столбца IS NULL
```

+ Если нужно найти записи, где в определённом поле значения не пустые, то есть нет NULL-значения:
```sql
WHERE наименование_столбца IS NOT NULL
```

В следующих степах вас ждут примеры использования фильтрации на `NULL`-значения.

От руководителя курьерского отдела нам пришла задача. Надо сделать две выгрузки: список заказов, где указан адрес доставки и где его нет. Далее заказчик проанализирует эти данные и решит, следует ли расширять штат курьеров.

![03](/SQL_Data/img/03_08.png)

Декомпозируем* задачу. Сначала найдем все заказы, где пользователи указали адрес доставки. Для этого нам нужно вывести полностью все записи, где поле address в таблице orders заполнено, то есть не содержит NULL-значений. Используя схему ниже, напишите правильный запрос.

```sql
WHERE наименование_столбца IS NOT NULL
```

>*Декомпозиция — разделение на части. Обычно в процессе работы большие и объемные задачи разделяют на части и выполняют по отдельности. Так проще дать задаче предварительную оценку, то есть указать сколько времени понадобится на выполнение (например, 16 часов или 6 дней); также в этом случае проще контролировать процесс работы и следить за сроками.

```sql
SELECT *
FROM orders
WHERE address IS NOT NULL
```

Вы получили первую выгрузку. Пора перейти ко второй части задачи и выгрузить все данные из таблицы orders, где поле adress не заполнено, то есть содержит NULL-значения.

```sql
SELECT *
FROM orders
WHERE address IS NULL;
```

Вы отлично справились! Обе выгрузки можно передавать заказчику, закрывать задачу и переходить к следующей.

Отдел маркетинга тоже попросил две выгрузки:

+ номера заказов, при оформлении которых был применен купон; 
+ номера заказов, при оформлении которых купон не применялся.

Сделаем первую выгрузку. Для этого понадобятся столбцы `id`, `coupon_id` из таблицы `orders`.

```sql
SELECT id
FROM orders
WHERE coupon_id IS NOT NULL
```

Теперь вторая часть задачи — выведите все `id` заказов из таблицы `orders`, при оформлении которых не был применен купон.

Как и в прошлый раз, вам понадобятся столбцы `id`, `coupon_id` из таблицы `orders`.

```sql
SELECT id
FROM orders
WHERE coupon_id IS NULL
```

Теперь вы знаете, как  делать выборку данных с фильтром на пустое значение `NULL`! Не забывайте, что при сравнение на такие значения не используется знак «=»:

```sql
WHERE наименование_столбца IS NULL
WHERE наименование_столбца IS NOT NULL
```

<hr>

[Содержание](#содержание)

# 3.3 Фильтрация данных, операторы сравнения 2. WHERE

## Операторы сравнения

В предыдущих уроках мы познакомились с оператором `WHERE` и сделали различные выборки данных. Мы задавали условие с помощью знака «=». Благодаря ему можно отфильтровать только те записи из таблицы, у которых значение в указанном поле равно чему-то. Например, чтобы найти все заказы, доставка которых была совершена на адрес «Рябиновая 19-1-2», нужно поставить условие `WHERE address = 'Рябиновая 19-1-2'` , а если мы хотим получить всех пользователей, у кого день рождения 10 января 1973 года, то нужно поставить условие на дату `WHERE birthday = '10.01.1973'`.

Но кроме этого знака, можно использовать и другие:

+ нестрогие неравенства обозначаются как `>=` (больше либо равно) или `<=` (меньше либо равно);
+ строгие неравенства обозначаются как `>` (больше) или `<` (меньше).

Например:

+ Для вывода пользователей, зарегистрировавшихся с 31 января 2021 года включительно, требуется условие `WHERE created >= '2021-01-31'`. Мы используем неравенство `>= '2021-01-31'`, так как нам нужны даты, которые больше или равны '2021-01-31'.
+ Если мы захотим вывести заказы, сумма которых меньше 1000, то ставим условие `WHERE total_price < 1000`.

В следующем степе вас ждет таблица-подсказка.

Таблица-подсказка

В MySQL 8 поддерживается несколько операторов сравнения: 

![03](/SQL_Data/img/03_09.png)

Все эти операторы можно использовать, чтобы задать условия для фильтрации данных.

На сегодня есть открытая задача от отдела продаж. Коллеги хотят проверить, упали ли продажи после 2020 года. 

Выведите `id` заказов, дату и сумму из таблицы `orders`, где заказы были сделаны после 1 января 2020 года включительно. 

Вам понадобятся столбцы `id`, `date`, `total_price` из таблицы `orders`.

**Подсказка**

Используйте условие `date >= '2020-01-01'`, чтобы найти все заказы, которые были сделаны после 1 января 2020 года включительно. 

```sql
SELECT id, date, total_price
FROM orders
WHERE date >= '2020-01-01'
```

А теперь давайте подготовим вторую выборку для коллег. Выведите `id` заказов, дату и сумму из таблицы `orders`, где заказы были сделаны до 1 января 2020 года. 

Вам понадобятся столбцы `id`, `date`, `total_price` из таблицы `orders`.

**Подсказка**

Используйте условие `date < '2020-01-01'` либо условие `date <= '2019-12-31'`, чтобы найти все заказы, которые были сделаны до 1 января 2021 года. 

```sql
SELECT id, date, total_price
FROM orders
WHERE date < '2020-01-01'
```

Коллеги проанализировали данные и решили дополнительно проверить, стали ли покупатели чаще делать более дорогие заказы.

Выведите все данные из таблицы `orders`, где сумма заказа больше или равна 3000 рублей.

Вам понадобится столбец `total_price` из таблицы `orders`.

```sql
SELECT *
FROM orders
WHERE total_price >= 3000;
```

Отлично! Коллеги заметили, что один из пользователей делал очень много заказов, что сильно влияет на статистические показатели, и попросили убрать его из выборки.

Выведите все данные из таблицы `orders`, кроме заказов, сделанных пользователем «0». 

Вам понадобится столбец `user_id` из таблицы `orders`.

**Подсказка**

Используйте условие `user_id != 0`, чтобы убрать из выборки заказы пользователя «0». Знак «!=» можно читать как «не равно».

```sql
SELECT *
FROM orders
WHERE user_id != 0;
```

<hr>

[Содержание](#содержание)

## Операторы сравнения. Константы. Бонусный степ

В запросе можно сравнивать две константы, то есть постоянные величины, например, числа или даже строки.

Вспомним, что сравнение происходит построчно — мы об этом рассказывали в одном из прошлых степов. Тогда при выполнении запроса ниже на каждой строке будет проверяться условие, меньше ли пять десяти. Пять всегда меньше десяти, поэтому данный запрос выведет все строки:

```sql
SELECT *
FROM orders
WHERE 5 < 10;
```

А если мы поменяем знак, то уже не получим ни одной записи, т.к. для каждой записи неравенство 5 > 10 не выполнится, потому что данное неравенство всегда ложно:

```sql
SELECT *
FROM orders
WHERE 5 > 10;
```

<hr>

[Содержание](#содержание)

## Операторы сравнения. Разные типы данных. Бонусный степ

При сравнении важно, чтобы оба аргумента были одинакового типа. Иногда в ходе сравнения оба аргумента можно легко привести к одному типу, как мы делали в условии `date > '2019-01-15'`, ведь `date` — это тип `DATE`, а `'2019-01-15'` — строка. Так как в колонке date хранится тип данных `DATE`, то есть дата, то сравнение со строкой происходит определенным образом, за счет чего условия ниже отдадут одинаковый результат*:

`date > '2019-01-15'`

`date > '2019.01.15'`

`date > '2019/01/15'`

Но стоит помнить, что порядок год-месяц-день должны быть сохранены.

Когда перевод в другой тип неоднозначен, то запрос может не выполниться или вернет непредсказуемый результат**. Например, такой запрос:

```sql
SELECT *
FROM orders
WHERE total_price > 'Hello';
```

>*Одинаковый результат будет в диалекте MySQL. В работе обычно в явном виде преобразовывают строку в дату. В MySQL для этого есть специальные функции, например, `STR_TO_DATE('15-01-2019', '%d-%m-%Y')` . Или как в Oracle SQL или PostgreSQL: `to_date('15-01-2019', 'dd-mm-yyyy')`.

>**В MySQL такой запрос выдаст все строки, так как в символьной таблице цифры стоят перед буквами, и получается такое выражение будет всегда истинным. А, например, в Oracle SQL запрос не отработает и выдаст ошибку, т.к. типы данных разные.

<hr>

[Содержание](#содержание)

## Операторы сравнения. Разные поля. Бонусный степ

В запросе можно сравнивать данные из разных полей, например:

```sql
SELECT *
FROM orders
WHERE id > user_id;
```

Этот запрос выведет все строки, где значение поля `id` больше `user_id`. Ниже данные строки выделены цветом:

![03](/SQL_Data/img/03_10.png)

<hr>

[Содержание](#содержание)

# 3.4 Фильтрация данных, логические операторы. WHERE

## Логические операторы. Оператор `AND`

Вы отлично справляетесь! Пора переходить к более сложным задачам. Представим, что продуктовый отдел* попросил сделать выборку не по одному, а нескольким условиям, например, цене и дате. Что же делать в таком случае?

Решить проблему можно при помощи логических операторов**. Первый логический оператор, с которым мы познакомимся — оператор `AND` (и).

Оператор `AND` мы используем, когда нам нужно получить записи, которые одновременно удовлетворяют нескольким условиям. Коллеги запросили записи заказов, совершенных до 15 ноября 2020, на сумму больше или равную 3000 рублей. По отдельности эти условия будет выглядеть так: `total_price >=3000` и `date < '2020-11-15'`. А сама конструкция с оператором `AND` будет выглядеть следующим образом:

```sql
WHERE условие_1 AND условие_2 AND условие_3
```

Теперь, когда у нас всё есть, давайте полностью напишем запрос:

```sql
SELECT *
FROM orders
WHERE total_price >= 3000 AND date < '2020-11-15';
```

При выполнении запроса каждая запись будет проверяться на оба условия. Если запись соответствует только одному условию, но не соответствует другому, она не попадет в выборку. Скопируйте запрос в поле ниже и нажмите «Отправить», чтобы посмотреть на результат.
​​
>*Продуктовый отдел или продуктовая команда — сотрудники, которые занимаются развитием и поддержкой определенного продукта: проводят анализ потребностей пользователей, улучшают метрики продукта, предоставляют бизнесу показатели развития продукта.

>**Логическими они называются, потому что проверяют истинность некоторого выражения. ​​​Про логические значения True (истина) и False (ложь) мы упоминали в этом степе.

>Например, оператор AND проверяет выражение: утверждение1 AND утверждение2,  и возвращает истину (1 или True), если они оба верны. В случае с SQL-запросом это означает, что если запись соответствует всем утверждениям (условиям), перечисленным через оператор AND, то ей присваивается значение 1 (True или истина). Все такие записи попадут в результирующую выборку при отработке скрипта. 

Пришло время задач! Коллегам из отдела продаж для дальнейшего анализа нужна выборка заказов.

Выведите id заказа, дату, сумму и поле с примененными купонами из таблицы orders. Ограничьте выборку условиями: сумма заказа больше или равна 5000 рублей, и заказы сделаны с 1 января 2019 года включительно.

Вам понадобятся столбцы id, date, total_price, coupon_id из таблицы orders.

Подсказка
В части с оператором WHERE пропишите 2 условия (на сумму и дату) через логический оператор AND, так как записи в результирующем запросе должны соответствовать двум условиям одновременно. 

```sql
SELECT id, date, total_price, coupon_id
FROM orders
WHERE total_price >= 5000 
  AND date >= '2019-01-01';
```

Отлично! Коллеги посмотрели данные и попросили ограничить выборку первым кварталом 2019 года. К счастью, через оператор AND можно указывать сразу несколько условий.

На основе предыдущего запроса выведите id заказа, дату, сумму и поле с примененными купонами из таблицы orders. Ограничьте выборку условиями: сумма заказа больше или равна 5000 рублей, и заказы сделаны в период с 1 января 2019 года по 31 марта 2019 года включительно.

Вам понадобятся столбцы id, date, total_price, coupon_id из таблицы orders.

**Подсказка**

В части с оператором WHERE пропишите 3 условия: сумму, дату начала периода (date >= '2019-01-01') и дату конца периода (date <= '2019-03-31') через логический оператор AND, так как записи в результирующем запросе должны соответствовать сразу нескольким условиям одновременно. 

```sql
SELECT id, date, total_price, coupon_id
FROM orders
WHERE total_price >= 5000 
  AND date >= '2019-01-01'
  AND date <= '2019-03-31';
```

Ограничение выборки временным периодом — очень частое условие, так как данные обычно анализируются за определенный период, например, год, квартал или месяц. Чтобы лучше понять, как ставить условие на временной период, давайте представим шкалу:

![03](/SQL_Data/img/03_11.png)

Сначала нужно выделить две даты — начало периода и его конец. Если нам нужны данные за март 2019 года, то нашем случае это '2019-03-01' и '2019-03-31'. Именно это и нужно прописать в условиях. Давайте теперь напишем часть c оператором WHERE: дата должна быть больше или равна началу периода и, соответственно, меньше или равна его окончанию:

```sql
WHERE date >= '2019-03-01' AND date <= '2019-03-31'
```

Условие можно переставить местами, от этого выборка не изменится, но, если работаете с датами, рекомендуем ставить сначала условие на дату начала периода, а уже затем на дату конца. В этом случае будет легче воспринимать код и удобнее читать его, в том числе коллегам.

Для удобства чтения кода также можно переносить условия на новые строки, например:

```sql
WHERE date >= '2019-03-01' 
  AND date <= '2019-03-31'
```

Повторите запрос из предыдущего степа, но поменяйте весь фильтр на тот, что выше. То есть условие должно быть только на дату.

```sql
SELECT id, date, total_price, coupon_id
FROM orders
WHERE date >= '2019-03-01' 
  AND date <= '2019-03-31';
```

Недавно в нашем магазине прошла акция. Заказчик из продуктового отдела хочет узнать, какие товары покупатели выбирали в это время. Коллеги из отдела доставки подсказали, что во время акции было сделано 5 заказов: их идентификаторы начинаются с 37 и заканчиваются 44. 

Выведите уникальные `id` товаров (`product_id`), которые входили в заказы с 37 по 44 включительно. Отсортируйте данные по полю `product_id` в порядке возрастания.

Вам понадобятся столбцы `product_id`, `order_id` из таблицы purchases.

```sql
SELECT DISTINCT product_id
FROM purchases
WHERE order_id BETWEEN 37 AND 44
ORDER BY 1;
```

Если условия в запросе противоречат друг другу, он не выдаст ни одной строки. Например, в запросе ниже мы указали, что id заказа должен быть 47 и 97:

```sql
SELECT *
FROM orders
WHERE id = 47 AND id = 97;
```

Логический оператор `AND` обозначает, что оба условия должны быть выполнены одновременно, но `id` заказа не может одновременно принимать два значения. То есть оно может быть равно либо 47, либо 97, но не одновременно 47 и 97. Поэтому наш запрос выдаст пустой результат. Скопируйте его в поле ниже и нажми «Отправить», чтобы убедиться

Отбор записей, удовлетворяющих условию, происходит так же, как описано в степе 3.1.6. Оператор WHERE идет по каждой строчке сверху вниз и выбирает только те из них, которые подходят условию `id = 47` и `id = 97`. Естественно, что строк, где значение id одновременно было бы равно двум разным числам, нет.

<hr>

[Содержание](#содержание)

## Логические операторы. Оператор OR

В прошлом степе мы обсуждали, что если указать через логический оператор AND противоречащие друг другу условия, то скрипт не выдаст ни одной строки:

```sql
SELECT *
FROM orders
WHERE id = 47 AND id = 97;
```

Скрипт выше можно переписать, используя логический оператор OR (или). Оператор OR мы используем, когда нам нужно получить записи, которые удовлетворяют хотя бы одному из указанных условий. Данный оператор устно можно заменить на слово «или». Сама конструкция с оператором OR будет выглядеть следующим образом:

```sql
WHERE условие_1 OR условие_2 OR условие_3
```

Перепишите скрипт выше, используя оператор OR так, чтобы он выдал записи с id заказа 47 или 97.

```sql
SELECT *
FROM orders
WHERE id = 47
   OR id = 97;
```

Отдел по работе с клиентами хочет провести опрос, для которого нужны данные о пользователях, зарегистрировавшихся до 1 января 2020 года или после 7 января 2020 года.

Выгрузите для них данные. Вам понадобятся столбцы name, email, created, phone из таблицы users.

Чтобы упростить запросы пока примем, что в столбце `created` хранятся данные в формате даты, а не даты со временем, то есть 'гггг-мм-дд', а не 'гггг-мм-дд чч:мм:сс'. Используйте именно этот формат 'гггг-мм-дд', чтобы задать фильтр на даты.

**Подсказка**

Используйте оператор `OR` , чтобы  поставить условие на даты `created < '2020-01-01'` и  `created > '2020-01-07'`

```sql
SELECT name, email, created, phone
FROM users
WHERE created < '2020-01-01' 
   OR created >'2020-01-07';
```

<hr>

[Содержание](#содержание)

## Логические операторы. Оператор NOT

Давайте познакомимся с ещё одним логическим оператором — `NOT` (не). С его помощью можно исключать из выборки записи, которые соответствуют определенному условию.

Выгрузите для отдела закупок все записи из таблицы `purchases`, где товары куплены в количестве более 1 штуки. Данное условие можно перефразировать, как «товары, которые купили НЕ в количестве 1 штуки», потому что в данной таблице в поле amount нет нуля или отрицательных значений. И тогда часть WHERE будет выглядеть так: 

```sql
WHERE NOT amount = 1;
```

Используйте фильтр выше, чтобы составить правильный запрос.

Вам понадобится столбец amount из таблицы `purchases`.

```sql
SELECT *
FROM purchases
WHERE NOT amount = 1;
```

Всегда помните, что задачу зачастую можно решить разными путями. Например, задачу из предыдущего степа мы можем решить не только через оператор `NOT`:

```sql
SELECT *
FROM purchases
WHERE NOT amount = 1;
```

но и через операторы сравнения:

+ количество не равно 1:

```sql
SELECT *
FROM purchases
WHERE amount != 1;
```

+ количество больше 1:

```sql
SELECT *
FROM purchases
WHERE amount > 1;
``` 

Стоит быть аккуратным с выбором решения, так как в поле, на которое вы ставите условие, может быть, например, значение `NULL`. И в зависимости от того, какое решение выбрано в результирующую выборку, данная строка может попасть или не попасть. Поэтому, прежде чем принять решения, каким условием лучше воспользоваться, обязательно ознакомьтесь с данными в таблице.

С помощью оператора `NOT` выведите все записи из таблицы заказов, где цена доставки больше `200`.

Вам понадобится столбец `delivery_price` из таблицы `orders`.

**Подсказка**

Используйте фильтр «цена доставки НЕ меньше или равна 200». 

```sql
SELECT *
FROM orders
WHERE NOT delivery_price <= 200;
```

<hr>

[Содержание](#содержание)

## Комбинация нескольких условий

Для выборки данных можно использовать несколько условий с разными логическими операторами.

Логические операторы, как и математические операции, имеют приоритет выполнения: 

1. Сначала выполнятся все выражения с оператором NOT;
2. Потом — все выражения с оператором AND;
3. В самом конце — выражения выражения с оператором OR.

Давайте потренируемся и сделаем выгрузку по техническому заданию: «Требуется выгрузка данных из таблицы заказов, где сумма заказа больше или равна 3000 И заказ сделан до 1 января 2020 года ЛИБО заказ сделан после 31 декабря 2021 года».

Не очень понятное техническое задание, правда? В таких случаях обязательно уточняйте у заказчика, что именно он хочет получить в результате! В нашем случае коллеги готовят квартальную отчетность и не могут уделить нам время на разъяснения. Что ж, тогда придется делать как написано:

```sql
SELECT *
FROM orders
WHERE total_price >= 3000 AND date < '2020-01-01' OR date > '2021-12-31';
```

Так как сначала выполняются условия с оператором `AND`, то мы получим все строки, которые соответствуют условиям `total_price >= 3000 AND date < '2020-01-01'`. То есть мы получим строки, где сумма заказа `3000` или более рублей И эти заказы были сделаны до 1 января 2020 года;

Затем будет рассчитано логическое выражение с оператором `OR`, то есть получаем результат_из_первого_пункта `OR date > '2021-12-31'`.

Получается, что наш скрипт выведет строки:

+ заказы на сумму 3000 и больше, сделанные до 1 января 2020 года;
+ все заказы, сделанные после 31 декабря 2021 года (в них уже не будет ограничения на сумму).

![03](/SQL_Data/img/03_12.png)

Коллеги получили выгрузку и поняли, что ошиблись с условием: им нужно, чтобы сумма заказа была обязательно больше или равна 3000. И такие заказы должны быть сделаны до 1 января 2020 года ЛИБО после 31 декабря 2021 года.

Если мы хотим изменить порядок выполнения выражений, то, как и в математике, мы можем использовать скобки. Выражения в скобках будут выполняться первыми. Преобразовав скрипт, мы изменим порядок выполнения логических операторов и получим совершенно другую выборку: 

```sql
SELECT *
FROM orders
WHERE total_price >= 3000 AND (date < '2020-01-01' OR date > '2021-12-31');
```

В таком случае выражение с `OR` выполнится раньше, и мы получим все заказы, которые были сделаны до 1 января 2020 года ЛИБО после 31 декабря 2021 года. А уже затем с помощью условия `total_price >= 3000` и оператора AND выберем из этих заказов только те, где сумма больше или равна 3000. 

![03](/SQL_Data/img/03_13.png)

Ну что ж, настало время для самой сложной задачи урока! На этот раз необходимо помочь отделу курьерской доставки. Выведите все уникальные идентификаторы пользователей, которые сделали заказы в 2019 году на сумму до 1000 рублей или более 4999.99 рублей.

Вам понадобятся столбцы `user_id`, `date`, `total_price` из таблицы `orders`.

Это сложная задача. Если не получается решить ее сразу, попробуйте сделать её по частям. Например, сначала выведите все строки за указанный период, а уже затем добавьте ограничение на сумму. В конце выведите, как указано в задании, только уникальные значения id пользователей.

**Подсказка**

Условие на сумму должно быть указано в скобках через оператор OR. Условия на начало периода и конец периода должны  быть указаны через оператор AND.

```sql
SELECT DISTINCT user_id
FROM orders
WHERE YEAR(date) = 2019
  AND total_price NOT BETWEEN 1000 AND 4999.99;
```

<hr>

[Содержание](#содержание)

# 3.5 Операторы BETWEEN, IN, LIKE

## Оператор BETWEEN

В этом уроке мы поговорим о некоторых операторах, которые упрощают написание условий в секции `WHERE`. И начать мы хотим с оператора `BETWEEN`.

Этот оператор используется, чтобы проверить попадает ли значение (или выражение) в определенный интервал.

Сама конструкция выглядит так:

```sql
WHERE название_столбца BETWEEN начало_диапазона AND конец_диапазона
```

Тогда, если нам нужно вывести стоки, где, например, id заказа входит в диапазон от 7 до 11,  то мы можем использовать данный оператор:

```sql
WHERE id BETWEEN 7 AND 11
```

Прочитать этот запрос можно следующим образом: находится ли значение столбца id МЕЖДУ 7 И 11? 

Как думаете, попадет ли заказ номер 10 в данный промежуток? Определенно да, посмотрите на картинку: очевидно, что 10 находится между семью и одиннадцатью.

![03](/SQL_Data/img/03_14.png)

А что насчет заказов номер 7 и 11, будут ли они в нашей результирующей выборке? Да! Важно: значения начала и конца интервала будут входить в диапазон, то есть id 7 и 11 будут входить в диапазон [7, 11].

Данное условие можно написать при помощи комбинации двух условий, заданных операторами сравнения. Результат будет таким же:

```sql
WHERE id >= 7 AND id <= 11
```

На склад поступили новые товары. Коллеги из продуктового отдела хотят получить выгрузку их наименований.

Выведите таблицы товаров id и его наименование позиций, чей id больше или равен 14, но меньше или равен 18. Используйте оператор BETWEEN.

Вам понадобятся столбцы id, name из таблицы products.

```sql
SELECT id, name
FROM products
WHERE id BETWEEN 14 AND 18;
```

Отлично! А теперь сделайте еще одну выборку для коллег.

Выведите из таблицы товаров `id` товара, наименование и `id` бренда для позиций, `brand_id` которых больше `1`, но меньше `6`. Используйте оператор `BETWEEN`.

Вам понадобятся столбцы id, name, brand_id из таблицы products.

Помни, что что начало и конец диапазона, указанного с помощью оператора BETWEEN входят в интервал, поэтому будь внимателен с числами в условии.

```sql
SELECT id, name, brand_id
FROM products
WHERE brand_id BETWEEN 2 AND 5;
```

Помните, ранее мы выгружали коллегам данные за первый квартал 2019 года, используя операторы сравнения? Это можно сделать с оператором BETWEEN.

Выведите id заказа, дату, сумму и поле с примененными купонами из таблицы orders, ограничив выборку первым кварталом 2019 года. То есть заказы должны быть сделаны в период с 1 января 2019 года по 31 марта 2019 года включительно.

Вам понадобятся столбцы id, date, total_price, coupon_id из таблицы orders.

```sql
SELECT id, date, total_price, coupon_id
FROM orders
WHERE date BETWEEN '2019-01-01' AND '2019-03-31';
```

Коллеги получили выгрузку и хотят сравнить показатели с 1 кварталом 2020 года.

Выведите id заказа, дату, сумму и поле с примененными купонами из таблицы orders. Выгруженные заказы должны быть сделаны в первом квартале 2019 года ИЛИ в первом квартале 2020 года. Используйте оператор BETWEEN, чтобы задать условия на периоды.

Вам понадобятся столбцы id, date, total_price, coupon_id из таблицы orders.

**Подсказка**

У вас будет два условия с оператором BETWEEN: на первый квартал 2019 года и на первый квартал 2020 года. Так как заказы должны быть сделаны либо в первый период, либо во второй, то дополнительно используйте оператор OR.

Чтобы было удобнее читать и редактировать скрипт, рекомендуем условие на второй период написать с новой строки, как мы рассказывали в этом степе.

```sql
SELECT id, date, total_price, coupon_id
FROM orders
WHERE date BETWEEN '2019-01-01' AND '2019-03-31'
   OR date BETWEEN '2020-01-01' AND '2020-03-31';
```

```sql
SELECT id, date, total_price, coupon_id
FROM orders
WHERE YEAR(date) IN (2019, 2020)
  AND QUARTER(date) = 1;
```

<hr>

[Содержание](#содержание)

## Оператор IN. Введение

Для отдела по работе с клиентами выгрузите всю информацию по пользователям с id 5, 16, 34, 18. Используйте уже изученный оператор OR, чтобы отфильтровать записи.

Вам понадобится столбец `id` из таблицы `users`.

```sql
SELECT *
FROM users
WHERE id IN (5, 16, 34)
   OR id = 18;
```

<hr>

[Содержание](#содержание)

## Оператор IN

Согласитесь, если коллеги попросят добавить еще несколько `id` пользователей в выгрузку, то запрос увеличится настолько, что его будет сложно прочитать и понять. Для таких случаев есть оператор IN, который проверяет входит ли значение поля в указанное множество. Конструкция с оператором IN выглядит следующим образом:

```sql
WHERE название_столбца IN (значение_1, значение_2, значение_3)
```
Тогда запрос из предыдущего степа можно переписать так:

```sql
SELECT *
FROM users
WHERE id IN (5, 16, 34, 18);
```

Для каждого заказа проверяется условие, попадает ли значение поля `id` в множество, состоящее из чисел 5, 16, 34, 18. По-другому это можно интерпретировать так: равно ли значение поля `id` хотя бы одному из чисел 5, 16, 34, 18.

При перечислении множества строковые значения или даты будут указываться в кавычках, например:

```sql
WHERE name IN ('Arthur', 'Инна', 'Дэн', 'Melissa')
```

Коллеги из отдела маркетинга неверно провели рассылку скидочных купонов и теперь считают убытки. Они хотят получить выгрузку заказов, к которым были применены купоны `TRUE`, `TRUECOUPON` и `TRUEHERO`. Номера этих купонов  2, 4 и 12.

Вам нужно найти заказы, к которым были применены купоны под номерами 2, 4 и 12. Выведите их id , дату, сумму и поле с примененными купонами из таблицы `orders`. Используйте оператор `IN`, чтобы задать условие.

Вам понадобятся столбцы `id`, `date`, `total_price`, `coupon_id` из таблицы `orders`.

```sql
SELECT id, date, total_price, coupon_id
FROM orders
WHERE coupon_id IN (2, 4, 12)
```

Для отдела продаж выгрузите заказы, которые сделали покупатели с идентификаторами 3, 17, 20, 23 и 24.

Выведите id заказа, дату, сумму и id покупателя из таблицы orders. Используйте оператор IN, чтобы задать условие на id покупателя.

Вам понадобятся столбцы id, date, total_price, user_id из таблицы orders.

```sql
SELECT id, date, total_price, user_id
FROM orders
WHERE user_id IN (3, 17, 20, 23, 24);
```

Коллегам из отдела продаж также нужны данные за определенные дни. 

Выведите все данные о заказах из таблицы orders, которые были сделаны 1 января 2019 года, 31 декабря 2019 года, 1 января 2020 года и 31 декабря 2020 года. Используйте оператор IN, чтобы задать условие.

Вам понадобится столбец  date из таблицы orders.

Помните, что даты тоже нужно указывать в кавычках. Используйте формат гггг-мм-дд.

```sql
SELECT *
FROM orders
WHERE date IN ('2019-01-01', '2019-12-31', '2020-01-01', '2020-12-31')
```

<hr>

[Содержание](#содержание)

## Оператор LIKE

Если в таблице есть поле с текстовыми данными, иногда может понадобиться отыскать все записи, в которых данные соответствуют какому-то шаблону. Для решения такой задачи используется оператор `LIKE`, который для каждой записи проверяет, соответствует ли значение текстового поля шаблону.

Чтобы задать шаблон, используются специальные символы:

1. Символ % , который обозначает любое количество символов. Например, задав условие `WHERE address like 'Проспект%'`, мы найдем все адреса, которые начинаются со слова «Проспект», и после этого слова имеют любое количество символов: «Проспект», «Проспект » , «Проспект Бабушкинский, дом 10, квартира 11» и т.п. В данную выборку не войдут поля, где перед словом «Проспект» есть какой-либо символ или если слово «Проспект» написано с маленькой буквы*.<br>
Символ `_`, который соответствует только одному любому символу. Например, надпись WHERE name like '___'задает слово состоящее из 3 букв: «Чай», «чай», «???» и т.п.<br>
В условии можно использовать комбинацию данных символов, например, WHERE address like '_ Проспект%'. Тогда мы получим записи, которые начинаются с одного символа, затем идет « Проспект» и далее любое количество символов: «1 Проспект», «2 Проспект Бабушкинский, дом 10, квартира 11», «? Проспект, дом 4» и т.п.

>В MySQL оператор LIKE производит поиск по строке без учета регистра букв. То есть вне зависимости напиcано ли «Проспект» или «проспект», результат выдачи будет один и тот же. Однако в других диалектах, например, Oracle поиск по шаблону будет 1 к 1, то есть с учетом регистра букв. Рекомендуем сразу привыкать использовать шаблоны с учетом регистра.

Приведем пример на основе наших таблиц. В таблице orders есть поле address, в котором хранятся адреса покупателей. Для отдела курьерской доставки важно находить точки, расположенные рядом, чтобы курьер мог составить оптимальный маршрут и эффективно использовать свое время на поездки. Если нам хочется найти все заказы, которые были доставлены по адресу дома Ленина (улица, площадь или переулок — не важно), то запрос получится следующим:

```sql
SELECT * 
FROM orders 
WHERE address LIKE '%Ленина%';
```

>Результат выполнения запроса выглядит так: 

![03](/SQL_Data/img/03_15.png)

Обратите внимание на поле `address`. Оператор `LIKE` сравнил и отобрал только те записи, у которых значение данного поля соответствует  шаблону `'%Ленина%'`, то есть сначала идет любое количество символов, затем слово «Ленина» и далее опять любое количество символов.

Для коллег из продуктового отдела выведите все данные из таблицы `products`, где поле `name` содержит в строке слово «Кофе» или «кофе».

Напоминаем, что в MySQL оператор `LIKE` производит поиск по строке без учета регистра букв. То есть вне зависимости напиcано ли «Кофе» или «кофе», результат выдачи будет один и тот же.

```sql
SELECT *
FROM products
WHERE name LIKE '%кофе%';
```

Выведите все данные из таблицы `orders`, где заказ был сделан в январе любого года.

Вам понадобится столбец date из таблицы `orders`.

>Используйте формат даты: гггг-мм-дд.

```sql
SELECT *
FROM orders
WHERE date LIKE '%-01-%';
```

Вы далеко продвинулись, помогли коллегам из разным отделов и узнали много нового. Так держать!

В следующем уроке вас ждут задания на повторение материала, чтобы проверить и закрепить полученные знания.

![03](/SQL_Data/img/03_16.png)

<hr>

[Содержание](#содержание)

# 3.6 Практика

Привет! Как настрой? Пора проверить, как вы усвоили новый материал. Впереди вас ждут вопросы и задания на написание кода. В этом уроке будет меньше подсказок, чтобы вы смогли немного попрактиковаться. Если что-то не получается — не стесняйтесь оставлять комментарии, преподаватели или другие ученики помогут вам. Также при выполнении заданий тебе поможет описание таблиц, которое можно прочитать в [документации](https://docs.google.com/document/d/10e3ZCCFgRxPa8-WnvEgzDvzVBtIM9sd-/edit#heading=h.gjdgxs).

![03](/SQL_Data/img/03_17.png)

<hr>

[Содержание](#содержание)